import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/abcjs/version.js
var require_version = __commonJS({
  "node_modules/abcjs/version.js"(exports, module) {
    var version = "6.4.4";
    module.exports = version;
  }
});

// node_modules/abcjs/src/api/abc_timing_callbacks.js
var require_abc_timing_callbacks = __commonJS({
  "node_modules/abcjs/src/api/abc_timing_callbacks.js"(exports, module) {
    var TimingCallbacks = function(target, params) {
      var self = this;
      if (!params) params = {};
      self.qpm = params.qpm ? parseInt(params.qpm, 10) : null;
      if (!self.qpm) {
        var tempo = target.metaText ? target.metaText.tempo : null;
        self.qpm = target.getBpm(tempo);
      }
      self.extraMeasuresAtBeginning = params.extraMeasuresAtBeginning ? parseInt(params.extraMeasuresAtBeginning, 10) : 0;
      self.beatCallback = params.beatCallback;
      self.eventCallback = params.eventCallback;
      self.lineEndCallback = params.lineEndCallback;
      self.lineEndAnticipation = params.lineEndAnticipation ? parseInt(params.lineEndAnticipation, 10) : 0;
      self.beatSubdivisions = params.beatSubdivisions ? parseInt(params.beatSubdivisions, 10) : 1;
      self.joggerTimer = null;
      self.replaceTarget = function(newTarget) {
        self.noteTimings = newTarget.setTiming(self.qpm, self.extraMeasuresAtBeginning);
        if (newTarget.noteTimings.length === 0)
          self.noteTimings = newTarget.setTiming(0, 0);
        if (self.lineEndCallback) {
          self.lineEndTimings = getLineEndTimings(newTarget.noteTimings, self.lineEndAnticipation);
        }
        self.startTime = null;
        self.currentBeat = 0;
        self.currentEvent = 0;
        self.currentLine = 0;
        self.currentTime = 0;
        self.isPaused = false;
        self.isRunning = false;
        self.pausedPercent = null;
        self.justUnpaused = false;
        self.newSeekPercent = 0;
        self.lastTimestamp = 0;
        if (self.noteTimings.length === 0)
          return;
        self.millisecondsPerBeat = 1e3 / (self.qpm / 60) / self.beatSubdivisions;
        self.lastMoment = self.noteTimings[self.noteTimings.length - 1].milliseconds;
        self.totalBeats = Math.round(self.lastMoment / self.millisecondsPerBeat);
      };
      self.replaceTarget(target);
      self.doTiming = function(timestamp) {
        if (self.lastTimestamp === timestamp)
          return;
        self.lastTimestamp = timestamp;
        if (!self.startTime) {
          self.startTime = timestamp;
        }
        if (!self.isPaused && self.isRunning) {
          self.currentTime = timestamp - self.startTime;
          self.currentTime += 16;
          while (self.noteTimings.length > self.currentEvent && self.noteTimings[self.currentEvent].milliseconds < self.currentTime) {
            if (self.eventCallback && self.noteTimings[self.currentEvent].type === "event") {
              var thisStartTime = self.startTime;
              self.eventCallback(self.noteTimings[self.currentEvent]);
              if (thisStartTime !== self.startTime) {
                self.currentTime = timestamp - self.startTime;
              }
            }
            self.currentEvent++;
          }
          if (self.lineEndCallback && self.lineEndTimings.length > self.currentLine && self.lineEndTimings[self.currentLine].milliseconds < self.currentTime && self.currentEvent < self.noteTimings.length) {
            var leftEvent = self.noteTimings[self.currentEvent].milliseconds === self.currentTime ? self.noteTimings[self.currentEvent] : self.noteTimings[self.currentEvent - 1];
            self.lineEndCallback(self.lineEndTimings[self.currentLine], leftEvent, { line: self.currentLine, endTimings: self.lineEndTimings, currentTime: self.currentTime });
            self.currentLine++;
          }
          if (self.currentTime < self.lastMoment) {
            requestAnimationFrame(self.doTiming);
            if (self.currentBeat * self.millisecondsPerBeat < self.currentTime) {
              var ret = self.doBeatCallback(timestamp);
              if (ret !== null)
                self.currentTime = ret;
            }
          } else if (self.currentBeat <= self.totalBeats) {
            if (self.beatCallback) {
              var ret2 = self.doBeatCallback(timestamp);
              if (ret2 !== null)
                self.currentTime = ret2;
              requestAnimationFrame(self.doTiming);
            }
          }
          if (self.currentTime >= self.lastMoment) {
            if (self.eventCallback) {
              var promise = self.eventCallback(null);
              self.shouldStop(promise).then(function(shouldStop) {
                if (shouldStop)
                  self.stop();
              });
            } else
              self.stop();
          }
        }
      };
      self.shouldStop = function(promise) {
        return new Promise(function(resolve) {
          if (!promise)
            return resolve(true);
          if (promise === "continue")
            return resolve(false);
          if (promise.then) {
            promise.then(function(result) {
              resolve(result !== "continue");
            });
          }
        });
      };
      self.doBeatCallback = function(timestamp) {
        if (self.beatCallback) {
          var next = self.currentEvent;
          while (next < self.noteTimings.length && self.noteTimings[next].left === null)
            next++;
          var endMs;
          var ev;
          if (next < self.noteTimings.length) {
            endMs = self.noteTimings[next].milliseconds;
            next = Math.max(0, self.currentEvent - 1);
            while (next >= 0 && self.noteTimings[next].left === null)
              next--;
            ev = self.noteTimings[next];
          }
          var position = {};
          var debugInfo = {};
          if (ev) {
            position.top = ev.top;
            position.height = ev.height;
            var offMs = Math.max(0, timestamp - self.startTime - ev.milliseconds);
            var gapMs = endMs - ev.milliseconds;
            var gapPx = ev.endX - ev.left;
            var offPx = gapMs ? offMs * gapPx / gapMs : 0;
            position.left = ev.left + offPx;
            if (self.currentEvent === 0 && ev.milliseconds > timestamp - self.startTime)
              position.left = void 0;
            debugInfo = {
              timestamp,
              startTime: self.startTime,
              ev,
              endMs,
              offMs,
              offPx,
              gapMs,
              gapPx
            };
          } else {
            debugInfo = {
              timestamp,
              startTime: self.startTime
            };
          }
          var thisStartTime = self.startTime;
          self.beatCallback(
            self.currentBeat / self.beatSubdivisions,
            self.totalBeats / self.beatSubdivisions,
            self.lastMoment,
            position,
            debugInfo
          );
          if (thisStartTime !== self.startTime) {
            return timestamp - self.startTime;
          } else
            self.currentBeat++;
        }
        return null;
      };
      var JOGGING_INTERVAL = 60;
      self.animationJogger = function() {
        if (self.isRunning) {
          self.doTiming(performance.now());
          self.joggerTimer = setTimeout(self.animationJogger, JOGGING_INTERVAL);
        }
      };
      self.start = function(offsetPercent, units) {
        self.isRunning = true;
        if (self.isPaused) {
          self.isPaused = false;
          if (offsetPercent === void 0)
            self.justUnpaused = true;
        }
        if (offsetPercent) {
          self.setProgress(offsetPercent, units);
        } else if (offsetPercent === 0) {
          self.reset();
        } else if (self.pausedPercent !== null) {
          var now = performance.now();
          self.currentTime = self.lastMoment * self.pausedPercent;
          self.startTime = now - self.currentTime;
          self.pausedPercent = null;
          self.reportNext = true;
        }
        requestAnimationFrame(self.doTiming);
        self.joggerTimer = setTimeout(self.animationJogger, JOGGING_INTERVAL);
      };
      self.pause = function() {
        self.isPaused = true;
        var now = performance.now();
        self.pausedPercent = (now - self.startTime) / self.lastMoment;
        self.isRunning = false;
        if (self.joggerTimer) {
          clearTimeout(self.joggerTimer);
          self.joggerTimer = null;
        }
      };
      self.currentMillisecond = function() {
        return self.currentTime;
      };
      self.reset = function() {
        self.currentBeat = 0;
        self.currentEvent = 0;
        self.currentLine = 0;
        self.startTime = null;
        self.pausedPercent = null;
      };
      self.stop = function() {
        self.pause();
        self.reset();
      };
      self.setProgress = function(position, units) {
        var percent;
        switch (units) {
          case "seconds":
            self.currentTime = position * 1e3;
            if (self.currentTime < 0) self.currentTime = 0;
            if (self.currentTime > self.lastMoment) self.currentTime = self.lastMoment;
            percent = self.currentTime / self.lastMoment;
            break;
          case "beats":
            self.currentTime = position * self.millisecondsPerBeat * self.beatSubdivisions;
            if (self.currentTime < 0) self.currentTime = 0;
            if (self.currentTime > self.lastMoment) self.currentTime = self.lastMoment;
            percent = self.currentTime / self.lastMoment;
            break;
          default:
            percent = position;
            if (percent < 0) percent = 0;
            if (percent > 1) percent = 1;
            self.currentTime = self.lastMoment * percent;
            break;
        }
        if (!self.isRunning)
          self.pausedPercent = percent;
        var now = performance.now();
        self.startTime = now - self.currentTime;
        var oldEvent = self.currentEvent;
        self.currentEvent = 0;
        while (self.noteTimings.length > self.currentEvent && self.noteTimings[self.currentEvent].milliseconds < self.currentTime) {
          self.currentEvent++;
        }
        if (self.lineEndCallback) {
          self.currentLine = 0;
          while (self.lineEndTimings.length > self.currentLine && self.lineEndTimings[self.currentLine].milliseconds + self.lineEndAnticipation < self.currentTime) {
            self.currentLine++;
          }
        }
        var oldBeat = self.currentBeat;
        self.currentBeat = Math.floor(self.currentTime / self.millisecondsPerBeat);
        if (self.beatCallback && oldBeat !== self.currentBeat)
          self.doBeatCallback(self.startTime + self.currentTime);
        if (self.eventCallback && self.currentEvent >= 0 && self.noteTimings[self.currentEvent].type === "event")
          self.eventCallback(self.noteTimings[self.currentEvent]);
        if (self.lineEndCallback)
          self.lineEndCallback(self.lineEndTimings[self.currentLine], self.noteTimings[self.currentEvent], { line: self.currentLine, endTimings: self.lineEndTimings });
        self.joggerTimer = setTimeout(self.animationJogger, JOGGING_INTERVAL);
      };
    };
    function getLineEndTimings(timings, anticipation) {
      var callbackTimes = [];
      var lastTop = null;
      for (var i2 = 0; i2 < timings.length; i2++) {
        var timing = timings[i2];
        if (timing.type !== "end" && timing.top !== lastTop) {
          callbackTimes.push({ measureNumber: timing.measureNumber, milliseconds: timing.milliseconds - anticipation, top: timing.top, bottom: timing.top + timing.height });
          lastTop = timing.top;
        }
      }
      return callbackTimes;
    }
    module.exports = TimingCallbacks;
  }
});

// node_modules/abcjs/src/api/abc_animation.js
var require_abc_animation = __commonJS({
  "node_modules/abcjs/src/api/abc_animation.js"(exports, module) {
    var TimingCallbacks = require_abc_timing_callbacks();
    var animation = {};
    (function() {
      "use strict";
      var timer;
      var cursor;
      animation.startAnimation = function(paper, tune, options) {
        if (timer) {
          timer.stop();
          timer = void 0;
        }
        if (options.showCursor) {
          cursor = paper.querySelector(".abcjs-cursor");
          if (!cursor) {
            cursor = document.createElement("DIV");
            cursor.className = "abcjs-cursor cursor";
            cursor.style.position = "absolute";
            paper.appendChild(cursor);
            paper.style.position = "relative";
          }
        }
        function hideMeasures(elements) {
          for (var i2 = 0; i2 < elements.length; i2++) {
            var element = elements[i2];
            if (!element.classList.contains("abcjs-bar"))
              element.style.display = "none";
          }
        }
        var lastMeasure;
        function disappearMeasuresAfter(selector) {
          if (lastMeasure) {
            var elements = paper.querySelectorAll(lastMeasure);
            hideMeasures(elements);
          }
          lastMeasure = selector;
        }
        function disappearMeasuresBefore(selector) {
          var elements = paper.querySelectorAll(selector);
          hideMeasures(elements);
        }
        function measureCallback(selector) {
          if (options.hideCurrentMeasure) {
            disappearMeasuresBefore(selector);
          } else if (options.hideFinishedMeasures) {
            disappearMeasuresAfter(selector);
          }
        }
        function getLineAndMeasure(element) {
          return ".abcjs-l" + element.line + ".abcjs-m" + element.measureNumber;
        }
        function setCursor(range) {
          if (range) {
            if (range.measureStart) {
              var selector = getLineAndMeasure(range);
              if (selector)
                measureCallback(selector);
            }
            if (cursor) {
              cursor.style.left = range.left + "px";
              cursor.style.top = range.top + "px";
              cursor.style.width = range.width + "px";
              cursor.style.height = range.height + "px";
            }
          } else {
            timer.stop();
            timer = void 0;
          }
        }
        timer = new TimingCallbacks(tune, {
          qpm: options.bpm,
          eventCallback: setCursor
        });
        timer.start();
      };
      animation.pauseAnimation = function(pause) {
        if (timer) {
          if (pause)
            timer.pause();
          else
            timer.start();
        }
      };
      animation.stopAnimation = function() {
        if (timer) {
          timer.stop();
          timer = void 0;
        }
      };
    })();
    module.exports = animation;
  }
});

// node_modules/abcjs/src/parse/abc_common.js
var require_abc_common = __commonJS({
  "node_modules/abcjs/src/parse/abc_common.js"(exports, module) {
    var parseCommon = {};
    parseCommon.cloneArray = function(source) {
      var destination = [];
      for (var i2 = 0; i2 < source.length; i2++) {
        destination.push(Object.assign({}, source[i2]));
      }
      return destination;
    };
    parseCommon.cloneHashOfHash = function(source) {
      var destination = {};
      for (var property in source)
        if (source.hasOwnProperty(property))
          destination[property] = Object.assign({}, source[property]);
      return destination;
    };
    parseCommon.cloneHashOfArrayOfHash = function(source) {
      var destination = {};
      for (var property in source)
        if (source.hasOwnProperty(property))
          destination[property] = parseCommon.cloneArray(source[property]);
      return destination;
    };
    parseCommon.strip = function(str) {
      return str.replace(/^\s+/, "").replace(/\s+$/, "");
    };
    parseCommon.startsWith = function(str, pattern) {
      return str.indexOf(pattern) === 0;
    };
    parseCommon.endsWith = function(str, pattern) {
      var d = str.length - pattern.length;
      return d >= 0 && str.lastIndexOf(pattern) === d;
    };
    parseCommon.last = function(arr) {
      if (arr.length === 0)
        return null;
      return arr[arr.length - 1];
    };
    module.exports = parseCommon;
  }
});

// node_modules/abcjs/src/parse/abc_parse_directive.js
var require_abc_parse_directive = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_directive.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseDirective = {};
    (function() {
      "use strict";
      var tokenizer;
      var warn;
      var multilineVars;
      var tune;
      var tuneBuilder;
      parseDirective.initialize = function(tokenizer_, warn_, multilineVars_, tune_, tuneBuilder_) {
        tokenizer = tokenizer_;
        warn = warn_;
        multilineVars = multilineVars_;
        tune = tune_;
        tuneBuilder = tuneBuilder_;
        initializeFonts();
      };
      function initializeFonts() {
        multilineVars.annotationfont = { face: "Helvetica", size: 12, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.gchordfont = { face: "Helvetica", size: 12, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.historyfont = { face: '"Times New Roman"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.infofont = { face: '"Times New Roman"', size: 14, weight: "normal", style: "italic", decoration: "none" };
        multilineVars.measurefont = { face: '"Times New Roman"', size: 14, weight: "normal", style: "italic", decoration: "none" };
        multilineVars.partsfont = { face: '"Times New Roman"', size: 15, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.repeatfont = { face: '"Times New Roman"', size: 13, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.textfont = { face: '"Times New Roman"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.tripletfont = { face: "Times", size: 11, weight: "normal", style: "italic", decoration: "none" };
        multilineVars.vocalfont = { face: '"Times New Roman"', size: 13, weight: "bold", style: "normal", decoration: "none" };
        multilineVars.wordsfont = { face: '"Times New Roman"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.composerfont = { face: '"Times New Roman"', size: 14, weight: "normal", style: "italic", decoration: "none" };
        tune.formatting.subtitlefont = { face: '"Times New Roman"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.tempofont = { face: '"Times New Roman"', size: 15, weight: "bold", style: "normal", decoration: "none" };
        tune.formatting.titlefont = { face: '"Times New Roman"', size: 20, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.footerfont = { face: '"Times New Roman"', size: 12, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.headerfont = { face: '"Times New Roman"', size: 12, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.voicefont = { face: '"Times New Roman"', size: 13, weight: "bold", style: "normal", decoration: "none" };
        tune.formatting.tablabelfont = { face: '"Trebuchet MS"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.tabnumberfont = { face: '"Arial"', size: 11, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.tabgracefont = { face: '"Arial"', size: 8, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.annotationfont = multilineVars.annotationfont;
        tune.formatting.gchordfont = multilineVars.gchordfont;
        tune.formatting.historyfont = multilineVars.historyfont;
        tune.formatting.infofont = multilineVars.infofont;
        tune.formatting.measurefont = multilineVars.measurefont;
        tune.formatting.partsfont = multilineVars.partsfont;
        tune.formatting.repeatfont = multilineVars.repeatfont;
        tune.formatting.textfont = multilineVars.textfont;
        tune.formatting.tripletfont = multilineVars.tripletfont;
        tune.formatting.vocalfont = multilineVars.vocalfont;
        tune.formatting.wordsfont = multilineVars.wordsfont;
      }
      var fontTypeCanHaveBox = { gchordfont: true, measurefont: true, partsfont: true, annotationfont: true, composerfont: true, historyfont: true, infofont: true, subtitlefont: true, textfont: true, titlefont: true, voicefont: true };
      var fontTranslation = function(fontFace) {
        switch (fontFace) {
          case "Arial-Italic":
            return { face: "Arial", weight: "normal", style: "italic", decoration: "none" };
          case "Arial-Bold":
            return { face: "Arial", weight: "bold", style: "normal", decoration: "none" };
          case "Bookman-Demi":
            return { face: "Bookman,serif", weight: "bold", style: "normal", decoration: "none" };
          case "Bookman-DemiItalic":
            return { face: "Bookman,serif", weight: "bold", style: "italic", decoration: "none" };
          case "Bookman-Light":
            return { face: "Bookman,serif", weight: "normal", style: "normal", decoration: "none" };
          case "Bookman-LightItalic":
            return { face: "Bookman,serif", weight: "normal", style: "italic", decoration: "none" };
          case "Courier":
            return { face: '"Courier New"', weight: "normal", style: "normal", decoration: "none" };
          case "Courier-Oblique":
            return { face: '"Courier New"', weight: "normal", style: "italic", decoration: "none" };
          case "Courier-Bold":
            return { face: '"Courier New"', weight: "bold", style: "normal", decoration: "none" };
          case "Courier-BoldOblique":
            return { face: '"Courier New"', weight: "bold", style: "italic", decoration: "none" };
          case "AvantGarde-Book":
            return { face: "AvantGarde,Arial", weight: "normal", style: "normal", decoration: "none" };
          case "AvantGarde-BookOblique":
            return { face: "AvantGarde,Arial", weight: "normal", style: "italic", decoration: "none" };
          case "AvantGarde-Demi":
          case "Avant-Garde-Demi":
            return { face: "AvantGarde,Arial", weight: "bold", style: "normal", decoration: "none" };
          case "AvantGarde-DemiOblique":
            return { face: "AvantGarde,Arial", weight: "bold", style: "italic", decoration: "none" };
          case "Helvetica-Oblique":
            return { face: "Helvetica", weight: "normal", style: "italic", decoration: "none" };
          case "Helvetica-Bold":
            return { face: "Helvetica", weight: "bold", style: "normal", decoration: "none" };
          case "Helvetica-BoldOblique":
            return { face: "Helvetica", weight: "bold", style: "italic", decoration: "none" };
          case "Helvetica-Narrow":
            return { face: '"Helvetica Narrow",Helvetica', weight: "normal", style: "normal", decoration: "none" };
          case "Helvetica-Narrow-Oblique":
            return { face: '"Helvetica Narrow",Helvetica', weight: "normal", style: "italic", decoration: "none" };
          case "Helvetica-Narrow-Bold":
            return { face: '"Helvetica Narrow",Helvetica', weight: "bold", style: "normal", decoration: "none" };
          case "Helvetica-Narrow-BoldOblique":
            return { face: '"Helvetica Narrow",Helvetica', weight: "bold", style: "italic", decoration: "none" };
          case "Palatino-Roman":
            return { face: "Palatino", weight: "normal", style: "normal", decoration: "none" };
          case "Palatino-Italic":
            return { face: "Palatino", weight: "normal", style: "italic", decoration: "none" };
          case "Palatino-Bold":
            return { face: "Palatino", weight: "bold", style: "normal", decoration: "none" };
          case "Palatino-BoldItalic":
            return { face: "Palatino", weight: "bold", style: "italic", decoration: "none" };
          case "NewCenturySchlbk-Roman":
            return { face: '"New Century",serif', weight: "normal", style: "normal", decoration: "none" };
          case "NewCenturySchlbk-Italic":
            return { face: '"New Century",serif', weight: "normal", style: "italic", decoration: "none" };
          case "NewCenturySchlbk-Bold":
            return { face: '"New Century",serif', weight: "bold", style: "normal", decoration: "none" };
          case "NewCenturySchlbk-BoldItalic":
            return { face: '"New Century",serif', weight: "bold", style: "italic", decoration: "none" };
          case "Times":
          case "Times-Roman":
          case "Times-Narrow":
          case "Times-Courier":
          case "Times-New-Roman":
            return { face: '"Times New Roman"', weight: "normal", style: "normal", decoration: "none" };
          case "Times-Italic":
          case "Times-Italics":
            return { face: '"Times New Roman"', weight: "normal", style: "italic", decoration: "none" };
          case "Times-Bold":
            return { face: '"Times New Roman"', weight: "bold", style: "normal", decoration: "none" };
          case "Times-BoldItalic":
            return { face: '"Times New Roman"', weight: "bold", style: "italic", decoration: "none" };
          case "ZapfChancery-MediumItalic":
            return { face: '"Zapf Chancery",cursive,serif', weight: "normal", style: "normal", decoration: "none" };
          default:
            return null;
        }
      };
      var getFontParameter = function(tokens, currentSetting, str, position, cmd) {
        function processNumberOnly() {
          var size2 = parseInt(tokens[0].token);
          tokens.shift();
          if (!currentSetting) {
            warn("Can't set just the size of the font since there is no default value.", str, position);
            return { face: '"Times New Roman"', weight: "normal", style: "normal", decoration: "none", size: size2 };
          }
          if (tokens.length === 0) {
            return { face: currentSetting.face, weight: currentSetting.weight, style: currentSetting.style, decoration: currentSetting.decoration, size: size2 };
          }
          if (tokens.length === 1 && tokens[0].token === "box" && fontTypeCanHaveBox[cmd])
            return { face: currentSetting.face, weight: currentSetting.weight, style: currentSetting.style, decoration: currentSetting.decoration, size: size2, box: true };
          warn("Extra parameters in font definition.", str, position);
          return { face: currentSetting.face, weight: currentSetting.weight, style: currentSetting.style, decoration: currentSetting.decoration, size: size2 };
        }
        if (tokens[0].token === "*") {
          tokens.shift();
          if (tokens[0].type === "number")
            return processNumberOnly();
          else {
            warn("Expected font size number after *.", str, position);
          }
        }
        if (tokens[0].type === "number") {
          return processNumberOnly();
        }
        var face = [];
        var size;
        var weight = "normal";
        var style = "normal";
        var decoration = "none";
        var box = false;
        var state = "face";
        var hyphenLast = false;
        while (tokens.length) {
          var currToken = tokens.shift();
          var word = currToken.token.toLowerCase();
          switch (state) {
            case "face":
              if (hyphenLast || word !== "utf" && currToken.type !== "number" && word !== "bold" && word !== "italic" && word !== "underline" && word !== "box") {
                if (face.length > 0 && currToken.token === "-") {
                  hyphenLast = true;
                  face[face.length - 1] = face[face.length - 1] + currToken.token;
                } else {
                  if (hyphenLast) {
                    hyphenLast = false;
                    face[face.length - 1] = face[face.length - 1] + currToken.token;
                  } else
                    face.push(currToken.token);
                }
              } else {
                if (currToken.type === "number") {
                  if (size) {
                    warn("Font size specified twice in font definition.", str, position);
                  } else {
                    size = currToken.token;
                  }
                  state = "modifier";
                } else if (word === "bold")
                  weight = "bold";
                else if (word === "italic")
                  style = "italic";
                else if (word === "underline")
                  decoration = "underline";
                else if (word === "box") {
                  if (fontTypeCanHaveBox[cmd])
                    box = true;
                  else
                    warn(`This font style doesn't support "box"`, str, position);
                  state = "finished";
                } else if (word === "utf") {
                  currToken = tokens.shift();
                  state = "size";
                } else
                  warn("Unknown parameter " + currToken.token + " in font definition.", str, position);
              }
              break;
            case "size":
              if (currToken.type === "number") {
                if (size) {
                  warn("Font size specified twice in font definition.", str, position);
                } else {
                  size = currToken.token;
                }
              } else {
                warn("Expected font size in font definition.", str, position);
              }
              state = "modifier";
              break;
            case "modifier":
              if (word === "bold")
                weight = "bold";
              else if (word === "italic")
                style = "italic";
              else if (word === "underline")
                decoration = "underline";
              else if (word === "box") {
                if (fontTypeCanHaveBox[cmd])
                  box = true;
                else
                  warn(`This font style doesn't support "box"`, str, position);
                state = "finished";
              } else
                warn("Unknown parameter " + currToken.token + " in font definition.", str, position);
              break;
            case "finished":
              warn('Extra characters found after "box" in font definition.', str, position);
              break;
          }
        }
        if (size === void 0) {
          if (!currentSetting) {
            warn("Must specify the size of the font since there is no default value.", str, position);
            size = 12;
          } else
            size = currentSetting.size;
        } else
          size = parseFloat(size);
        face = face.join(" ");
        if (face === "") {
          if (!currentSetting) {
            warn("Must specify the name of the font since there is no default value.", str, position);
            face = "sans-serif";
          } else
            face = currentSetting.face;
        }
        var psFont = fontTranslation(face);
        var font = {};
        if (psFont) {
          font.face = psFont.face;
          font.weight = psFont.weight;
          font.style = psFont.style;
          font.decoration = psFont.decoration;
          font.size = size;
          if (box)
            font.box = true;
          return font;
        }
        font.face = face;
        font.weight = weight;
        font.style = style;
        font.decoration = decoration;
        font.size = size;
        if (box)
          font.box = true;
        return font;
      };
      var getChangingFont = function(cmd, tokens, str) {
        if (tokens.length === 0)
          return 'Directive "' + cmd + '" requires a font as a parameter.';
        multilineVars[cmd] = getFontParameter(tokens, multilineVars[cmd], str, 0, cmd);
        if (multilineVars.is_in_header)
          tune.formatting[cmd] = multilineVars[cmd];
        return null;
      };
      var getGlobalFont = function(cmd, tokens, str) {
        if (tokens.length === 0)
          return 'Directive "' + cmd + '" requires a font as a parameter.';
        tune.formatting[cmd] = getFontParameter(tokens, tune.formatting[cmd], str, 0, cmd);
        return null;
      };
      var setScale = function(cmd, tokens) {
        var scratch = "";
        tokens.forEach(function(tok) {
          scratch += tok.token;
        });
        var num = parseFloat(scratch);
        if (isNaN(num) || num === 0)
          return 'Directive "' + cmd + '" requires a number as a parameter.';
        tune.formatting.scale = num;
      };
      var drumNames = [
        "acoustic-bass-drum",
        "bass-drum-1",
        "side-stick",
        "acoustic-snare",
        "hand-clap",
        "electric-snare",
        "low-floor-tom",
        "closed-hi-hat",
        "high-floor-tom",
        "pedal-hi-hat",
        "low-tom",
        "open-hi-hat",
        "low-mid-tom",
        "hi-mid-tom",
        "crash-cymbal-1",
        "high-tom",
        "ride-cymbal-1",
        "chinese-cymbal",
        "ride-bell",
        "tambourine",
        "splash-cymbal",
        "cowbell",
        "crash-cymbal-2",
        "vibraslap",
        "ride-cymbal-2",
        "hi-bongo",
        "low-bongo",
        "mute-hi-conga",
        "open-hi-conga",
        "low-conga",
        "high-timbale",
        "low-timbale",
        "high-agogo",
        "low-agogo",
        "cabasa",
        "maracas",
        "short-whistle",
        "long-whistle",
        "short-guiro",
        "long-guiro",
        "claves",
        "hi-wood-block",
        "low-wood-block",
        "mute-cuica",
        "open-cuica",
        "mute-triangle",
        "open-triangle"
      ];
      var interpretPercMap = function(restOfString) {
        var tokens = restOfString.split(/\s+/);
        if (tokens.length !== 2 && tokens.length !== 3)
          return { error: 'Expected parameters "abc-note", "drum-sound", and optionally "note-head"' };
        var key = tokens[0];
        var pitch = parseInt(tokens[1], 10);
        if ((isNaN(pitch) || pitch < 35 || pitch > 81) && tokens[1]) {
          pitch = drumNames.indexOf(tokens[1].toLowerCase()) + 35;
        }
        if (isNaN(pitch) || pitch < 35 || pitch > 81)
          return { error: 'Expected drum name, received "' + tokens[1] + '"' };
        var value = { sound: pitch };
        if (tokens.length === 3)
          value.noteHead = tokens[2];
        return { key, value };
      };
      var getRequiredMeasurement = function(cmd, tokens) {
        var points = tokenizer.getMeasurement(tokens);
        if (points.used === 0 || tokens.length !== 0)
          return { error: 'Directive "' + cmd + '" requires a measurement as a parameter.' };
        return points.value;
      };
      var oneParameterMeasurement = function(cmd, tokens) {
        var points = tokenizer.getMeasurement(tokens);
        if (points.used === 0 || tokens.length !== 0)
          return 'Directive "' + cmd + '" requires a measurement as a parameter.';
        tune.formatting[cmd] = points.value;
        return null;
      };
      var addMultilineVar = function(key, cmd, tokens, min, max) {
        if (tokens.length !== 1 || tokens[0].type !== "number")
          return 'Directive "' + cmd + '" requires a number as a parameter.';
        var i2 = tokens[0].intt;
        if (min !== void 0 && i2 < min)
          return 'Directive "' + cmd + '" requires a number greater than or equal to ' + min + " as a parameter.";
        if (max !== void 0 && i2 > max)
          return 'Directive "' + cmd + '" requires a number less than or equal to ' + max + " as a parameter.";
        multilineVars[key] = i2;
        return null;
      };
      var addMultilineVarBool = function(key, cmd, tokens) {
        if (tokens.length === 1 && (tokens[0].token === "true" || tokens[0].token === "false")) {
          multilineVars[key] = tokens[0].token === "true";
          return null;
        }
        var str = addMultilineVar(key, cmd, tokens, 0, 1);
        if (str !== null) return str;
        multilineVars[key] = multilineVars[key] === 1;
        return null;
      };
      var addMultilineVarOneParamChoice = function(key, cmd, tokens, choices) {
        if (tokens.length !== 1)
          return 'Directive "' + cmd + '" requires one of [ ' + choices.join(", ") + " ] as a parameter.";
        var choice = tokens[0].token;
        var found = false;
        for (var i2 = 0; !found && i2 < choices.length; i2++) {
          if (choices[i2] === choice)
            found = true;
        }
        if (!found)
          return 'Directive "' + cmd + '" requires one of [ ' + choices.join(", ") + " ] as a parameter.";
        multilineVars[key] = choice;
        return null;
      };
      var midiCmdParam0 = [
        "nobarlines",
        "barlines",
        "beataccents",
        "nobeataccents",
        "droneon",
        "droneoff",
        "drumon",
        "drumoff",
        "fermatafixed",
        "fermataproportional",
        "gchordon",
        "gchordoff",
        "controlcombo",
        "temperamentnormal",
        "noportamento"
      ];
      var midiCmdParam1String = [
        "gchord",
        "ptstress",
        "beatstring"
      ];
      var midiCmdParam1Integer = [
        "bassvol",
        "chordvol",
        "c",
        "channel",
        "beatmod",
        "deltaloudness",
        "drumbars",
        "gracedivider",
        "makechordchannels",
        "randomchordattack",
        "chordattack",
        "stressmodel",
        "transpose",
        "rtranspose",
        "vol",
        "volinc",
        "gchordbars"
      ];
      var midiCmdParam1Integer1OptionalInteger = [
        "program"
      ];
      var midiCmdParam2Integer = [
        "ratio",
        "snt",
        "bendvelocity",
        "pitchbend",
        "control",
        "temperamentlinear"
      ];
      var midiCmdParam4Integer = [
        "beat"
      ];
      var midiCmdParam5Integer = [
        "drone"
      ];
      var midiCmdParam1String1Integer = [
        "portamento"
      ];
      var midiCmdParamFraction = [
        "expand",
        "grace",
        "trim"
      ];
      var midiCmdParam1StringVariableIntegers = [
        "drum",
        "chordname"
      ];
      var midiCmdParam1Integer1OptionalString = [
        "bassprog",
        "chordprog"
      ];
      var parseMidiCommand = function(midi, tune2, restOfString) {
        var midi_cmd = midi.shift().token;
        var midi_params = [];
        if (midiCmdParam0.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 0)
            warn("Unexpected parameter in MIDI " + midi_cmd, restOfString, 0);
        } else if (midiCmdParam1String.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1)
            warn("Expected one parameter in MIDI " + midi_cmd, restOfString, 0);
          else
            midi_params.push(midi[0].token);
        } else if (midiCmdParam1Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1)
            warn("Expected one parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number")
            warn("Expected one integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else
            midi_params.push(midi[0].intt);
        } else if (midiCmdParam1Integer1OptionalInteger.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1 && midi.length !== 2)
            warn("Expected one or two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number")
            warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi.length === 2 && midi[1].type !== "number")
            warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            if (midi.length === 2)
              midi_params.push(midi[1].intt);
          }
        } else if (midiCmdParam2Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 2)
            warn("Expected two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number" || midi[1].type !== "number")
            warn("Expected two integer parameters in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            midi_params.push(midi[1].intt);
          }
        } else if (midiCmdParam1String1Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 2)
            warn("Expected two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "alpha" || midi[1].type !== "number")
            warn("Expected one string and one integer parameters in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].token);
            midi_params.push(midi[1].intt);
          }
        } else if (midi_cmd === "drummap") {
          if (midi.length === 2 && midi[0].type === "alpha" && midi[1].type === "number") {
            if (!tune2.formatting) tune2.formatting = {};
            if (!tune2.formatting.midi) tune2.formatting.midi = {};
            if (!tune2.formatting.midi.drummap) tune2.formatting.midi.drummap = {};
            tune2.formatting.midi.drummap[midi[0].token] = midi[1].intt;
            midi_params = tune2.formatting.midi.drummap;
          } else if (midi.length === 3 && midi[0].type === "punct" && midi[1].type === "alpha" && midi[2].type === "number") {
            if (!tune2.formatting) tune2.formatting = {};
            if (!tune2.formatting.midi) tune2.formatting.midi = {};
            if (!tune2.formatting.midi.drummap) tune2.formatting.midi.drummap = {};
            tune2.formatting.midi.drummap[midi[0].token + midi[1].token] = midi[2].intt;
            midi_params = tune2.formatting.midi.drummap;
          } else {
            warn("Expected one note name and one integer parameter in MIDI " + midi_cmd, restOfString, 0);
          }
        } else if (midiCmdParamFraction.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 3)
            warn("Expected fraction parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number" || midi[1].token !== "/" || midi[2].type !== "number")
            warn("Expected fraction parameter in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            midi_params.push(midi[2].intt);
          }
        } else if (midiCmdParam4Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 4)
            warn("Expected four parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number" || midi[1].type !== "number" || midi[2].type !== "number" || midi[3].type !== "number")
            warn("Expected four integer parameters in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            midi_params.push(midi[1].intt);
            midi_params.push(midi[2].intt);
            midi_params.push(midi[3].intt);
          }
        } else if (midiCmdParam5Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 5)
            warn("Expected five parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number" || midi[1].type !== "number" || midi[2].type !== "number" || midi[3].type !== "number" || midi[4].type !== "number")
            warn("Expected five integer parameters in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            midi_params.push(midi[1].intt);
            midi_params.push(midi[2].intt);
            midi_params.push(midi[3].intt);
            midi_params.push(midi[4].intt);
          }
        } else if (midiCmdParam1Integer1OptionalInteger.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1 || midi.length !== 4)
            warn("Expected one or two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number")
            warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi.length === 4) {
            if (midi[1].token !== "octave")
              warn("Expected octave parameter in MIDI " + midi_cmd, restOfString, 0);
            if (midi[2].token !== "=")
              warn("Expected octave parameter in MIDI " + midi_cmd, restOfString, 0);
            if (midi[3].type !== "number")
              warn("Expected integer parameter for octave in MIDI " + midi_cmd, restOfString, 0);
          } else {
            midi_params.push(midi[0].intt);
            if (midi.length === 4)
              midi_params.push(midi[3].intt);
          }
        } else if (midiCmdParam1StringVariableIntegers.indexOf(midi_cmd) >= 0) {
          if (midi.length < 2)
            warn("Expected string parameter and at least one integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "alpha")
            warn("Expected string parameter and at least one integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else {
            var p = midi.shift();
            midi_params.push(p.token);
            while (midi.length > 0) {
              p = midi.shift();
              if (p.type !== "number")
                warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
              midi_params.push(p.intt);
            }
          }
        } else if (midiCmdParam1Integer1OptionalString.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1 && midi.length !== 2)
            warn("Expected one or two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number")
            warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi.length === 2 && midi[1].type !== "alpha")
            warn("Expected alpha parameter in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            if (midi.length === 2) {
              var cmd = midi[1].token;
              if (cmd.indexOf("octave=") != -1) {
                cmd = cmd.replace("octave=", "");
                cmd = parseInt(cmd);
                if (!isNaN(cmd)) {
                  if (cmd < -1) {
                    warn("Expected octave= in MIDI " + midi_cmd + " to be >= -1 (recv:" + cmd + ")");
                    cmd = -1;
                  }
                  if (cmd > 3) {
                    warn("Expected octave= in MIDI " + midi_cmd + " to be <= 3 (recv:" + cmd + ")");
                    cmd = 3;
                  }
                  midi_params.push(cmd);
                } else
                  warn("Expected octave value in MIDI" + midi_cmd);
              } else {
                warn("Expected octave= in MIDI" + midi_cmd);
              }
            }
          }
        }
        if (tuneBuilder.hasBeginMusic())
          tuneBuilder.appendElement("midi", -1, -1, { cmd: midi_cmd, params: midi_params });
        else {
          if (tune2.formatting["midi"] === void 0)
            tune2.formatting["midi"] = {};
          tune2.formatting["midi"][midi_cmd] = midi_params;
        }
      };
      parseDirective.parseFontChangeLine = function(textstr) {
        textstr = textstr.replace(/\$\$/g, "");
        var textParts = textstr.split("$");
        if (textParts.length > 1 && multilineVars.setfont) {
          var textarr = [];
          if (textParts[0] !== "")
            textarr.push({ text: textParts[0] });
          for (var i2 = 1; i2 < textParts.length; i2++) {
            if (textParts[i2][0] === "0")
              textarr.push({ text: textParts[i2].substring(1).replace(/\x03/g, "$$") });
            else {
              var whichFont = parseInt(textParts[i2][0], 10);
              if (multilineVars.setfont[whichFont])
                textarr.push({ font: multilineVars.setfont[whichFont], text: textParts[i2].substring(1).replace(/\x03/g, "$$") });
              else
                textarr[textarr.length - 1].text += "$" + textParts[i2].replace(/\x03/g, "$$");
            }
          }
          return textarr;
        }
        return textstr.replace(/\x03/g, "$$");
      };
      var positionChoices = ["auto", "above", "below", "hidden"];
      parseDirective.addDirective = function(str) {
        var tokens = tokenizer.tokenize(str, 0, str.length);
        if (tokens.length === 0 || tokens[0].type !== "alpha") return null;
        var restOfString = str.substring(str.indexOf(tokens[0].token) + tokens[0].token.length);
        restOfString = tokenizer.stripComment(restOfString);
        var cmd = tokens.shift().token.toLowerCase();
        var scratch = "";
        var line;
        switch (cmd) {
          // The following directives were added to abc_parser_lint, but haven't been implemented here.
          // Most of them are direct translations from the directives that will be parsed in. See abcm2ps's format.txt for info on each of these.
          //					alignbars: { type: "number", optional: true },
          //					aligncomposer: { type: "string", Enum: [ 'left', 'center','right' ], optional: true },
          //					bstemdown: { type: "boolean", optional: true },
          //					continueall: { type: "boolean", optional: true },
          //					dynalign: { type: "boolean", optional: true },
          //					exprabove: { type: "boolean", optional: true },
          //					exprbelow: { type: "boolean", optional: true },
          //					gchordbox: { type: "boolean", optional: true },
          //					gracespacebefore: { type: "number", optional: true },
          //					gracespaceinside: { type: "number", optional: true },
          //					gracespaceafter: { type: "number", optional: true },
          //					infospace: { type: "number", optional: true },
          //					lineskipfac: { type: "number", optional: true },
          //					maxshrink: { type: "number", optional: true },
          //					maxstaffsep: { type: "number", optional: true },
          //					maxsysstaffsep: { type: "number", optional: true },
          //					notespacingfactor: { type: "number", optional: true },
          //					parskipfac: { type: "number", optional: true },
          //					slurheight: { type: "number", optional: true },
          //					splittune: { type: "boolean", optional: true },
          //					squarebreve: { type: "boolean", optional: true },
          //					stemheight: { type: "number", optional: true },
          //					straightflags: { type: "boolean", optional: true },
          //					stretchstaff: { type: "boolean", optional: true },
          //					titleformat: { type: "string", optional: true },
          case "bagpipes":
            tune.formatting.bagpipes = true;
            break;
          case "flatbeams":
            tune.formatting.flatbeams = true;
            break;
          case "jazzchords":
            tune.formatting.jazzchords = true;
            break;
          case "accentAbove":
            tune.formatting.accentAbove = true;
            break;
          case "germanAlphabet":
            tune.formatting.germanAlphabet = true;
            break;
          case "landscape":
            multilineVars.landscape = true;
            break;
          case "papersize":
            multilineVars.papersize = restOfString;
            break;
          case "graceslurs":
            if (tokens.length !== 1)
              return "Directive graceslurs requires one parameter: 0 or 1";
            if (tokens[0].token === "0" || tokens[0].token === "false")
              tune.formatting.graceSlurs = false;
            else if (tokens[0].token === "1" || tokens[0].token === "true")
              tune.formatting.graceSlurs = true;
            else
              return "Directive graceslurs requires one parameter: 0 or 1 (received " + tokens[0].token + ")";
            break;
          case "lineThickness":
            var lt = parseStretchLast(tokens);
            if (lt.value !== void 0)
              tune.formatting.lineThickness = lt.value;
            if (lt.error)
              return lt.error;
            break;
          case "stretchlast":
            var sl = parseStretchLast(tokens);
            if (sl.value !== void 0)
              tune.formatting.stretchlast = sl.value;
            if (sl.error)
              return sl.error;
            break;
          case "titlecaps":
            multilineVars.titlecaps = true;
            break;
          case "titleleft":
            tune.formatting.titleleft = true;
            break;
          case "measurebox":
            tune.formatting.measurebox = true;
            break;
          case "vocal":
            return addMultilineVarOneParamChoice("vocalPosition", cmd, tokens, positionChoices);
          case "dynamic":
            return addMultilineVarOneParamChoice("dynamicPosition", cmd, tokens, positionChoices);
          case "gchord":
            return addMultilineVarOneParamChoice("chordPosition", cmd, tokens, positionChoices);
          case "ornament":
            return addMultilineVarOneParamChoice("ornamentPosition", cmd, tokens, positionChoices);
          case "volume":
            return addMultilineVarOneParamChoice("volumePosition", cmd, tokens, positionChoices);
          case "botmargin":
          case "botspace":
          case "composerspace":
          case "indent":
          case "leftmargin":
          case "linesep":
          case "musicspace":
          case "partsspace":
          case "pageheight":
          case "pagewidth":
          case "rightmargin":
          case "stafftopmargin":
          case "staffsep":
          case "staffwidth":
          case "subtitlespace":
          case "sysstaffsep":
          case "systemsep":
          case "textspace":
          case "titlespace":
          case "topmargin":
          case "topspace":
          case "vocalspace":
          case "wordsspace":
            return oneParameterMeasurement(cmd, tokens);
          case "voicescale":
            if (tokens.length !== 1 || tokens[0].type !== "number")
              return "voicescale requires one float as a parameter";
            var voiceScale = tokens.shift();
            if (multilineVars.currentVoice) {
              multilineVars.currentVoice.scale = voiceScale.floatt;
              tuneBuilder.changeVoiceScale(multilineVars.currentVoice.scale);
            }
            return null;
          case "voicecolor":
            if (tokens.length !== 1)
              return "voicecolor requires one string as a parameter";
            var voiceColor = tokens.shift();
            if (multilineVars.currentVoice) {
              multilineVars.currentVoice.color = voiceColor.token;
              tuneBuilder.changeVoiceColor(multilineVars.currentVoice.color);
            }
            return null;
          case "vskip":
            var vskip = Math.round(getRequiredMeasurement(cmd, tokens));
            if (vskip.error)
              return vskip.error;
            tuneBuilder.addSpacing(vskip);
            return null;
          case "scale":
            setScale(cmd, tokens);
            break;
          case "sep":
            if (tokens.length === 0)
              tuneBuilder.addSeparator(14, 14, 85, { startChar: multilineVars.iChar, endChar: multilineVars.iChar + 5 });
            else {
              var points = tokenizer.getMeasurement(tokens);
              if (points.used === 0)
                return 'Directive "' + cmd + '" requires 3 numbers: space above, space below, length of line';
              var spaceAbove = points.value;
              points = tokenizer.getMeasurement(tokens);
              if (points.used === 0)
                return 'Directive "' + cmd + '" requires 3 numbers: space above, space below, length of line';
              var spaceBelow = points.value;
              points = tokenizer.getMeasurement(tokens);
              if (points.used === 0 || tokens.length !== 0)
                return 'Directive "' + cmd + '" requires 3 numbers: space above, space below, length of line';
              var lenLine = points.value;
              tuneBuilder.addSeparator(spaceAbove, spaceBelow, lenLine, { startChar: multilineVars.iChar, endChar: multilineVars.iChar + restOfString.length });
            }
            break;
          case "barsperstaff":
            scratch = addMultilineVar("barsperstaff", cmd, tokens);
            if (scratch !== null) return scratch;
            break;
          case "staffnonote":
            if (tokens.length !== 1)
              return "Directive staffnonote requires one parameter: 0 or 1";
            if (tokens[0].token === "0")
              multilineVars.staffnonote = true;
            else if (tokens[0].token === "1")
              multilineVars.staffnonote = false;
            else
              return "Directive staffnonote requires one parameter: 0 or 1 (received " + tokens[0].token + ")";
            break;
          case "printtempo":
            scratch = addMultilineVarBool("printTempo", cmd, tokens);
            if (scratch !== null) return scratch;
            break;
          case "partsbox":
            scratch = addMultilineVarBool("partsBox", cmd, tokens);
            if (scratch !== null) return scratch;
            multilineVars.partsfont.box = multilineVars.partsBox;
            break;
          case "freegchord":
            scratch = addMultilineVarBool("freegchord", cmd, tokens);
            if (scratch !== null) return scratch;
            break;
          case "measurenb":
          case "barnumbers":
            scratch = addMultilineVar("barNumbers", cmd, tokens);
            if (scratch !== null) return scratch;
            break;
          case "setbarnb":
            if (tokens.length !== 1 || tokens[0].type !== "number") {
              return "Directive setbarnb requires a number as a parameter.";
            }
            multilineVars.currBarNumber = tuneBuilder.setBarNumberImmediate(tokens[0].intt);
            break;
          case "begintext":
            var textBlock = "";
            line = tokenizer.nextLine();
            while (line && line.indexOf("%%endtext") !== 0) {
              if (parseCommon.startsWith(line, "%%"))
                textBlock += line.substring(2) + "\n";
              else
                textBlock += line + "\n";
              line = tokenizer.nextLine();
            }
            tuneBuilder.addText(textBlock, { startChar: multilineVars.iChar, endChar: multilineVars.iChar + textBlock.length + 7 });
            break;
          case "continueall":
            multilineVars.continueall = true;
            break;
          case "beginps":
            line = tokenizer.nextLine();
            while (line && line.indexOf("%%endps") !== 0) {
              tokenizer.nextLine();
            }
            warn("Postscript ignored", str, 0);
            break;
          case "deco":
            if (restOfString.length > 0)
              multilineVars.ignoredDecorations.push(restOfString.substring(0, restOfString.indexOf(" ")));
            warn("Decoration redefinition ignored", str, 0);
            break;
          case "text":
            var textstr = tokenizer.translateString(restOfString);
            tuneBuilder.addText(parseDirective.parseFontChangeLine(textstr), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + restOfString.length + 7 });
            break;
          case "center":
            var centerstr = tokenizer.translateString(restOfString);
            tuneBuilder.addCentered(parseDirective.parseFontChangeLine(centerstr));
            break;
          case "font":
            break;
          case "setfont":
            var sfTokens = tokenizer.tokenize(restOfString, 0, restOfString.length);
            if (sfTokens.length >= 4) {
              if (sfTokens[0].token === "-" && sfTokens[1].type === "number") {
                var sfNum = parseInt(sfTokens[1].token);
                if (sfNum >= 1 && sfNum <= 9) {
                  if (!multilineVars.setfont)
                    multilineVars.setfont = [];
                  sfTokens.shift();
                  sfTokens.shift();
                  multilineVars.setfont[sfNum] = getFontParameter(sfTokens, multilineVars.setfont[sfNum], str, 0, "setfont");
                }
              }
            }
            break;
          case "gchordfont":
          case "partsfont":
          case "tripletfont":
          case "vocalfont":
          case "textfont":
          case "annotationfont":
          case "historyfont":
          case "infofont":
          case "measurefont":
          case "repeatfont":
          case "wordsfont":
            return getChangingFont(cmd, tokens, str);
          case "composerfont":
          case "subtitlefont":
          case "tempofont":
          case "titlefont":
          case "voicefont":
          case "footerfont":
          case "headerfont":
            return getGlobalFont(cmd, tokens, str);
          case "barlabelfont":
          case "barnumberfont":
          case "barnumfont":
            return getChangingFont("measurefont", tokens, str);
          case "staves":
          case "score":
            multilineVars.score_is_present = true;
            var addVoice = function(id, newStaff2, bracket2, brace2, continueBar2) {
              if (newStaff2 || multilineVars.staves.length === 0) {
                multilineVars.staves.push({ index: multilineVars.staves.length, numVoices: 0 });
              }
              var staff = parseCommon.last(multilineVars.staves);
              if (bracket2 !== void 0 && staff.bracket === void 0) staff.bracket = bracket2;
              if (brace2 !== void 0 && staff.brace === void 0) staff.brace = brace2;
              if (continueBar2) staff.connectBarLines = "end";
              if (multilineVars.voices[id] === void 0) {
                multilineVars.voices[id] = { staffNum: staff.index, index: staff.numVoices };
                staff.numVoices++;
              }
            };
            var openParen = false;
            var openBracket = false;
            var openBrace = false;
            var justOpenParen = false;
            var justOpenBracket = false;
            var justOpenBrace = false;
            var continueBar = false;
            var lastVoice;
            var addContinueBar = function() {
              continueBar = true;
              if (lastVoice) {
                var ty = "start";
                if (lastVoice.staffNum > 0) {
                  if (multilineVars.staves[lastVoice.staffNum - 1].connectBarLines === "start" || multilineVars.staves[lastVoice.staffNum - 1].connectBarLines === "continue")
                    ty = "continue";
                }
                multilineVars.staves[lastVoice.staffNum].connectBarLines = ty;
              }
            };
            while (tokens.length) {
              var t = tokens.shift();
              switch (t.token) {
                case "(":
                  if (openParen) warn("Can't nest parenthesis in %%score", str, t.start);
                  else {
                    openParen = true;
                    justOpenParen = true;
                  }
                  break;
                case ")":
                  if (!openParen || justOpenParen) warn("Unexpected close parenthesis in %%score", str, t.start);
                  else openParen = false;
                  break;
                case "[":
                  if (openBracket) warn("Can't nest brackets in %%score", str, t.start);
                  else {
                    openBracket = true;
                    justOpenBracket = true;
                  }
                  break;
                case "]":
                  if (!openBracket || justOpenBracket) warn("Unexpected close bracket in %%score", str, t.start);
                  else {
                    openBracket = false;
                    multilineVars.staves[lastVoice.staffNum].bracket = "end";
                  }
                  break;
                case "{":
                  if (openBrace) warn("Can't nest braces in %%score", str, t.start);
                  else {
                    openBrace = true;
                    justOpenBrace = true;
                  }
                  break;
                case "}":
                  if (!openBrace || justOpenBrace) warn("Unexpected close brace in %%score", str, t.start);
                  else {
                    openBrace = false;
                    multilineVars.staves[lastVoice.staffNum].brace = "end";
                  }
                  break;
                case "|":
                  addContinueBar();
                  break;
                default:
                  var vc = "";
                  while (t.type === "alpha" || t.type === "number") {
                    vc += t.token;
                    if (t.continueId)
                      t = tokens.shift();
                    else
                      break;
                  }
                  var newStaff = !openParen || justOpenParen;
                  var bracket = justOpenBracket ? "start" : openBracket ? "continue" : void 0;
                  var brace = justOpenBrace ? "start" : openBrace ? "continue" : void 0;
                  addVoice(vc, newStaff, bracket, brace, continueBar);
                  justOpenParen = false;
                  justOpenBracket = false;
                  justOpenBrace = false;
                  continueBar = false;
                  lastVoice = multilineVars.voices[vc];
                  if (cmd === "staves")
                    addContinueBar();
                  break;
              }
            }
            break;
          case "newpage":
            var pgNum = tokenizer.getInt(restOfString);
            tuneBuilder.addNewPage(pgNum.digits === 0 ? -1 : pgNum.value);
            break;
          case "abc":
            var arr = restOfString.split(" ");
            switch (arr[0]) {
              case "-copyright":
              case "-creator":
              case "-edited-by":
              case "-version":
              case "-charset":
                var subCmd = arr.shift();
                tuneBuilder.addMetaText(cmd + subCmd, arr.join(" "), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + restOfString.length + 5 });
                break;
              default:
                return "Unknown directive: " + cmd + arr[0];
            }
            break;
          case "header":
          case "footer":
            var footerStr = tokenizer.getMeat(restOfString, 0, restOfString.length);
            footerStr = restOfString.substring(footerStr.start, footerStr.end);
            if (footerStr[0] === '"' && footerStr[footerStr.length - 1] === '"')
              footerStr = footerStr.substring(1, footerStr.length - 1);
            var footerArr = footerStr.split("	");
            var footer = {};
            if (footerArr.length === 1)
              footer = { left: "", center: footerArr[0], right: "" };
            else if (footerArr.length === 2)
              footer = { left: footerArr[0], center: footerArr[1], right: "" };
            else
              footer = { left: footerArr[0], center: footerArr[1], right: footerArr[2] };
            if (footerArr.length > 3)
              warn("Too many tabs in " + cmd + ": " + footerArr.length + " found.", restOfString, 0);
            tuneBuilder.addMetaTextObj(cmd, footer, { startChar: multilineVars.iChar, endChar: multilineVars.iChar + str.length });
            break;
          case "midi":
            var midi = tokenizer.tokenize(restOfString, 0, restOfString.length, true);
            if (midi.length > 0 && midi[0].token === "=")
              midi.shift();
            if (midi.length === 0)
              warn("Expected midi command", restOfString, 0);
            else
              parseMidiCommand(midi, tune, restOfString);
            break;
          case "percmap":
            var percmap = interpretPercMap(restOfString);
            if (percmap.error)
              warn(percmap.error, str, 8);
            else {
              if (!tune.formatting.percmap)
                tune.formatting.percmap = {};
              tune.formatting.percmap[percmap.key] = percmap.value;
            }
            break;
          case "map":
          case "playtempo":
          case "auquality":
          case "continuous":
          case "nobarcheck":
            tune.formatting[cmd] = restOfString;
            break;
          default:
            return "Unknown directive: " + cmd;
        }
        return null;
      };
      parseDirective.globalFormatting = function(formatHash) {
        for (var cmd in formatHash) {
          if (formatHash.hasOwnProperty(cmd)) {
            var value = "" + formatHash[cmd];
            var tokens = tokenizer.tokenize(value, 0, value.length);
            var scratch;
            switch (cmd) {
              case "titlefont":
              case "gchordfont":
              case "composerfont":
              case "footerfont":
              case "headerfont":
              case "historyfont":
              case "infofont":
              case "measurefont":
              case "partsfont":
              case "repeatfont":
              case "subtitlefont":
              case "tempofont":
              case "textfont":
              case "voicefont":
              case "tripletfont":
              case "vocalfont":
              case "wordsfont":
              case "annotationfont":
              case "tablabelfont":
              case "tabnumberfont":
              case "tabgracefont":
                getChangingFont(cmd, tokens, value);
                break;
              case "scale":
                setScale(cmd, tokens);
                break;
              case "partsbox":
                scratch = addMultilineVarBool("partsBox", cmd, tokens);
                if (scratch !== null) warn(scratch);
                multilineVars.partsfont.box = multilineVars.partsBox;
                break;
              case "freegchord":
                scratch = addMultilineVarBool("freegchord", cmd, tokens);
                if (scratch !== null) warn(scratch);
                break;
              case "fontboxpadding":
                if (tokens.length !== 1 || tokens[0].type !== "number")
                  warn('Directive "' + cmd + '" requires a number as a parameter.');
                tune.formatting.fontboxpadding = tokens[0].floatt;
                break;
              case "stafftopmargin":
                if (tokens.length !== 1 || tokens[0].type !== "number")
                  warn('Directive "' + cmd + '" requires a number as a parameter.');
                tune.formatting.stafftopmargin = tokens[0].floatt;
                break;
              case "stretchlast":
                var sl = parseStretchLast(tokens);
                if (sl.value !== void 0)
                  tune.formatting.stretchlast = sl.value;
                if (sl.error)
                  return sl.error;
                break;
              default:
                warn("Formatting directive unrecognized: ", cmd, 0);
            }
          }
        }
      };
      function parseStretchLast(tokens) {
        if (tokens.length === 0)
          return { value: 1 };
        else if (tokens.length === 1) {
          if (tokens[0].type === "number") {
            if (tokens[0].floatt >= 0 || tokens[0].floatt <= 1)
              return { value: tokens[0].floatt };
          } else if (tokens[0].token === "false") {
            return { value: 0 };
          } else if (tokens[0].token === "true") {
            return { value: 1 };
          }
        }
        return { error: "Directive stretchlast requires zero or one parameter: false, true, or number between 0 and 1 (received " + tokens[0].token + ")" };
      }
    })();
    module.exports = parseDirective;
  }
});

// node_modules/abcjs/src/parse/all-notes.js
var require_all_notes = __commonJS({
  "node_modules/abcjs/src/parse/all-notes.js"(exports, module) {
    var allNotes = {};
    var allPitches = [
      "C,,,",
      "D,,,",
      "E,,,",
      "F,,,",
      "G,,,",
      "A,,,",
      "B,,,",
      "C,,",
      "D,,",
      "E,,",
      "F,,",
      "G,,",
      "A,,",
      "B,,",
      "C,",
      "D,",
      "E,",
      "F,",
      "G,",
      "A,",
      "B,",
      "C",
      "D",
      "E",
      "F",
      "G",
      "A",
      "B",
      "c",
      "d",
      "e",
      "f",
      "g",
      "a",
      "b",
      "c'",
      "d'",
      "e'",
      "f'",
      "g'",
      "a'",
      "b'",
      "c''",
      "d''",
      "e''",
      "f''",
      "g''",
      "a''",
      "b''",
      "c'''",
      "d'''",
      "e'''",
      "f'''",
      "g'''",
      "a'''",
      "b'''"
    ];
    allNotes.pitchIndex = function(noteName) {
      return allPitches.indexOf(noteName);
    };
    allNotes.noteName = function(pitchIndex) {
      return allPitches[pitchIndex];
    };
    module.exports = allNotes;
  }
});

// node_modules/abcjs/src/parse/transpose-chord.js
var require_transpose_chord = __commonJS({
  "node_modules/abcjs/src/parse/transpose-chord.js"(exports, module) {
    var sharpChords = ["C", "C♯", "D", "D♯", "E", "F", "F♯", "G", "G♯", "A", "A♯", "B"];
    var flatChords = ["C", "D♭", "D", "E♭", "E", "F", "G♭", "G", "A♭", "A", "B♭", "B"];
    var sharpChordsFree = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    var flatChordsFree = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
    function transposeChordName(chord, steps, preferFlats, freeGCchord) {
      if (!steps || steps % 12 === 0)
        return chord;
      while (steps < 0) steps += 12;
      if (steps > 11) steps = steps % 12;
      var match = chord.match(/^([A-G][b#♭♯]?)([^\/]+)?\/?([A-G][b#♭♯]?)?(.+)?/);
      if (!match)
        return chord;
      var name = match[1];
      var extra1 = match[2];
      var bass = match[3];
      var extra2 = match[4];
      var index = sharpChords.indexOf(name);
      if (index < 0)
        index = flatChords.indexOf(name);
      if (index < 0)
        index = sharpChordsFree.indexOf(name);
      if (index < 0)
        index = flatChordsFree.indexOf(name);
      if (index < 0)
        return chord;
      index += steps;
      index = index % 12;
      if (preferFlats) {
        if (freeGCchord) chord = flatChordsFree[index];
        else chord = flatChords[index];
      } else {
        if (freeGCchord) chord = sharpChordsFree[index];
        else chord = sharpChords[index];
      }
      if (extra1)
        chord += extra1;
      if (bass) {
        var index = sharpChords.indexOf(bass);
        if (index < 0)
          index = flatChords.indexOf(bass);
        if (index < 0)
          index = sharpChordsFree.indexOf(bass);
        if (index < 0)
          index = flatChordsFree.indexOf(bass);
        chord += "/";
        if (index >= 0) {
          index += steps;
          index = index % 12;
          if (preferFlats) {
            if (freeGCchord) chord += flatChordsFree[index];
            else chord += flatChords[index];
          } else {
            if (freeGCchord) chord += sharpChordsFree[index];
            else chord += sharpChords[index];
          }
        } else
          chord += bass;
      }
      if (extra2)
        chord += extra2;
      return chord;
    }
    module.exports = transposeChordName;
  }
});

// node_modules/abcjs/src/const/relative-major.js
var require_relative_major = __commonJS({
  "node_modules/abcjs/src/const/relative-major.js"(exports, module) {
    var keys = {
      "C": { modes: ["CMaj", "Amin", "Am", "GMix", "DDor", "EPhr", "FLyd", "BLoc"], stepsFromC: 0 },
      "Db": { modes: ["DbMaj", "Bbmin", "Bbm", "AbMix", "EbDor", "FPhr", "GbLyd", "CLoc"], stepsFromC: 1 },
      "D": { modes: ["DMaj", "Bmin", "Bm", "AMix", "EDor", "F#Phr", "GLyd", "C#Loc"], stepsFromC: 2 },
      "Eb": { modes: ["EbMaj", "Cmin", "Cm", "BbMix", "FDor", "GPhr", "AbLyd", "DLoc"], stepsFromC: 3 },
      "E": { modes: ["EMaj", "C#min", "C#m", "BMix", "F#Dor", "G#Phr", "ALyd", "D#Loc"], stepsFromC: 4 },
      "F": { modes: ["FMaj", "Dmin", "Dm", "CMix", "GDor", "APhr", "BbLyd", "ELoc"], stepsFromC: 5 },
      "Gb": { modes: ["GbMaj", "Ebmin", "Ebm", "DbMix", "AbDor", "BbPhr", "CbLyd", "FLoc"], stepsFromC: 6 },
      "G": { modes: ["GMaj", "Emin", "Em", "DMix", "ADor", "BPhr", "CLyd", "F#Loc"], stepsFromC: 7 },
      "Ab": { modes: ["AbMaj", "Fmin", "Fm", "EbMix", "BbDor", "CPhr", "DbLyd", "GLoc"], stepsFromC: 8 },
      "A": { modes: ["AMaj", "F#min", "F#m", "EMix", "BDor", "C#Phr", "DLyd", "G#Loc"], stepsFromC: 9 },
      "Bb": { modes: ["BbMaj", "Gmin", "Gm", "FMix", "CDor", "DPhr", "EbLyd", "ALoc"], stepsFromC: 10 },
      "B": { modes: ["BMaj", "G#min", "G#m", "F#Mix", "C#Dor", "D#Phr", "ELyd", "A#Loc"], stepsFromC: 11 },
      // Enharmonic keys
      "C#": { modes: ["C#Maj", "A#min", "A#m", "G#Mix", "D#Dor", "E#Phr", "F#Lyd", "B#Loc"], stepsFromC: 1 },
      "F#": { modes: ["F#Maj", "D#min", "D#m", "C#Mix", "G#Dor", "A#Phr", "BLyd", "E#Loc"], stepsFromC: 6 },
      "Cb": { modes: ["CbMaj", "Abmin", "Abm", "GbMix", "DbDor", "EbPhr", "FbLyd", "BbLoc"], stepsFromC: 11 }
    };
    var keyReverse = null;
    function createKeyReverse() {
      keyReverse = {};
      var allKeys = Object.keys(keys);
      for (var i2 = 0; i2 < allKeys.length; i2++) {
        var keyObj = keys[allKeys[i2]];
        keyReverse[allKeys[i2].toLowerCase()] = allKeys[i2];
        for (var j = 0; j < keyObj.modes.length; j++) {
          var mode = keyObj.modes[j].toLowerCase();
          keyReverse[mode] = allKeys[i2];
        }
      }
    }
    function relativeMajor(key) {
      if (!keyReverse) {
        createKeyReverse();
      }
      var mode = key.toLowerCase().match(/([a-g][b#]?)(maj|min|mix|dor|phr|lyd|loc|m)?/);
      if (!mode || !mode[2])
        return key;
      mode = mode[1] + mode[2];
      var maj = keyReverse[mode];
      if (maj)
        return maj;
      return key;
    }
    function relativeMode(majorKey, mode) {
      var group = keys[majorKey];
      if (!group)
        return majorKey;
      if (mode === "")
        return majorKey;
      var match = mode.toLowerCase().match(/^(maj|min|mix|dor|phr|lyd|loc|m)/);
      if (!match)
        return majorKey;
      var regMode = match[1];
      for (var i2 = 0; i2 < group.modes.length; i2++) {
        var thisMode = group.modes[i2];
        var ind = thisMode.toLowerCase().indexOf(regMode);
        if (ind !== -1 && ind === thisMode.length - regMode.length)
          return thisMode.substring(0, thisMode.length - regMode.length);
      }
      return majorKey;
    }
    function transposeKey(key, steps) {
      var match = keys[key];
      if (!match)
        return key;
      while (steps < 0) steps += 12;
      var fromC = (match.stepsFromC + steps) % 12;
      for (var i2 = 0; i2 < Object.keys(keys).length; i2++) {
        var k = Object.keys(keys)[i2];
        if (keys[k].stepsFromC === fromC)
          return k;
      }
      return key;
    }
    module.exports = { relativeMajor, relativeMode, transposeKey };
  }
});

// node_modules/abcjs/src/const/key-accidentals.js
var require_key_accidentals = __commonJS({
  "node_modules/abcjs/src/const/key-accidentals.js"(exports, module) {
    var { relativeMajor } = require_relative_major();
    var key1sharp = { acc: "sharp", note: "f" };
    var key2sharp = { acc: "sharp", note: "c" };
    var key3sharp = { acc: "sharp", note: "g" };
    var key4sharp = { acc: "sharp", note: "d" };
    var key5sharp = { acc: "sharp", note: "A" };
    var key6sharp = { acc: "sharp", note: "e" };
    var key7sharp = { acc: "sharp", note: "B" };
    var key1flat = { acc: "flat", note: "B" };
    var key2flat = { acc: "flat", note: "e" };
    var key3flat = { acc: "flat", note: "A" };
    var key4flat = { acc: "flat", note: "d" };
    var key5flat = { acc: "flat", note: "G" };
    var key6flat = { acc: "flat", note: "c" };
    var key7flat = { acc: "flat", note: "F" };
    var keys = {
      "C#": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
      "F#": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
      "B": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
      "E": [key1sharp, key2sharp, key3sharp, key4sharp],
      "A": [key1sharp, key2sharp, key3sharp],
      "D": [key1sharp, key2sharp],
      "G": [key1sharp],
      "C": [],
      "F": [key1flat],
      "Bb": [key1flat, key2flat],
      "Eb": [key1flat, key2flat, key3flat],
      "Cm": [key1flat, key2flat, key3flat],
      "Ab": [key1flat, key2flat, key3flat, key4flat],
      "Db": [key1flat, key2flat, key3flat, key4flat, key5flat],
      "Gb": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
      "Cb": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
      // The following are not in the 2.0 spec, but seem normal enough.
      // TODO-PER: These SOUND the same as what's written, but they aren't right
      "A#": [key1flat, key2flat],
      "B#": [],
      "D#": [key1flat, key2flat, key3flat],
      "E#": [key1flat],
      "G#": [key1flat, key2flat, key3flat, key4flat],
      "none": []
    };
    function keyAccidentals(key) {
      var newKey = keys[relativeMajor(key)];
      if (!newKey)
        return null;
      return JSON.parse(JSON.stringify(newKey));
    }
    module.exports = keyAccidentals;
  }
});

// node_modules/abcjs/src/parse/abc_transpose.js
var require_abc_transpose = __commonJS({
  "node_modules/abcjs/src/parse/abc_transpose.js"(exports, module) {
    var allNotes = require_all_notes();
    var transposeChordName = require_transpose_chord();
    var keyAccidentals = require_key_accidentals();
    var transpose = {};
    var keyIndex = {
      "C": 0,
      "C#": 1,
      "Db": 1,
      "D": 2,
      "D#": 3,
      "Eb": 3,
      "E": 4,
      "F": 5,
      "F#": 6,
      "Gb": 6,
      "G": 7,
      "G#": 8,
      "Ab": 8,
      "A": 9,
      "A#": 10,
      "Bb": 10,
      "B": 11
    };
    var newKey = ["C", "Db", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"];
    var newKeyMinor = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "Bb", "B"];
    transpose.keySignature = function(multilineVars, keyName, root, acc, localTranspose) {
      if (multilineVars.clef.type === "perc" || multilineVars.clef.type === "none")
        return { accidentals: keyAccidentals(keyName), root, acc };
      if (!localTranspose) localTranspose = 0;
      multilineVars.localTransposeVerticalMovement = 0;
      multilineVars.localTransposePreferFlats = false;
      var k = keyAccidentals(keyName);
      if (!k) return multilineVars.key;
      multilineVars.localTranspose = (multilineVars.globalTranspose ? multilineVars.globalTranspose : 0) + localTranspose;
      if (!multilineVars.localTranspose)
        return { accidentals: k, root, acc };
      multilineVars.globalTransposeOrigKeySig = k;
      if (multilineVars.localTranspose % 12 === 0) {
        multilineVars.localTransposeVerticalMovement = multilineVars.localTranspose / 12 * 7;
        return { accidentals: k, root, acc };
      }
      var baseKey = keyName[0];
      if (keyName[1] === "b" || keyName[1] === "#") {
        baseKey += keyName[1];
        keyName = keyName.substr(2);
      } else
        keyName = keyName.substr(1);
      var thisKeyIndex = keyIndex[baseKey];
      var recognized = thisKeyIndex !== void 0;
      if (!recognized) {
        thisKeyIndex = 0;
        baseKey = "C";
        keyName = "";
      }
      var index = thisKeyIndex + multilineVars.localTranspose;
      while (index < 0) index += 12;
      if (index > 11) index = index % 12;
      var newKeyName = keyName[0] === "m" ? newKeyMinor[index] : newKey[index];
      var transposedKey = newKeyName + keyName;
      var newKeySig = keyAccidentals(transposedKey);
      if (newKeySig.length > 0 && newKeySig[0].acc === "flat")
        multilineVars.localTransposePreferFlats = true;
      var distance = transposedKey.charCodeAt(0) - baseKey.charCodeAt(0);
      if (multilineVars.localTranspose > 0) {
        if (distance < 0)
          distance += 7;
        else if (distance === 0) {
          if (baseKey[1] === "#" || transposedKey[1] === "b")
            distance += 7;
        }
      } else if (multilineVars.localTranspose < 0) {
        if (distance > 0)
          distance -= 7;
        else if (distance === 0) {
          if (baseKey[1] === "b" || transposedKey[1] === "#")
            distance -= 7;
        }
      }
      if (multilineVars.localTranspose > 0)
        multilineVars.localTransposeVerticalMovement = distance + Math.floor(multilineVars.localTranspose / 12) * 7;
      else
        multilineVars.localTransposeVerticalMovement = distance + Math.ceil(multilineVars.localTranspose / 12) * 7;
      if (recognized)
        return { accidentals: newKeySig, root: newKeyName[0], acc: newKeyName.length > 1 ? newKeyName[1] : "" };
      else
        return { accidentals: [], root, acc };
    };
    transpose.chordName = function(multilineVars, chord) {
      return transposeChordName(chord, multilineVars.localTranspose, multilineVars.localTransposePreferFlats, multilineVars.freegchord);
    };
    var pitchToLetter = ["c", "d", "e", "f", "g", "a", "b"];
    function accidentalChange(origPitch, newPitch, accidental, origKeySig, newKeySig) {
      var origPitchLetter = pitchToLetter[(origPitch + 49) % 7];
      var origAccidental = 0;
      for (var i2 = 0; i2 < origKeySig.length; i2++) {
        if (origKeySig[i2].note.toLowerCase() === origPitchLetter)
          origAccidental = accidentals[origKeySig[i2].acc];
      }
      var currentAccidental = accidentals[accidental];
      var delta = currentAccidental - origAccidental;
      var newPitchLetter = pitchToLetter[(newPitch + 49) % 7];
      var newAccidental = 0;
      for (var j = 0; j < newKeySig.accidentals.length; j++) {
        if (newKeySig.accidentals[j].note.toLowerCase() === newPitchLetter)
          newAccidental = accidentals[newKeySig.accidentals[j].acc];
      }
      var calcAccidental = delta + newAccidental;
      if (calcAccidental < -2) {
        newPitch--;
        calcAccidental += newPitchLetter === "c" || newPitchLetter === "f" ? 1 : 2;
      }
      if (calcAccidental > 2) {
        newPitch++;
        calcAccidental -= newPitchLetter === "b" || newPitchLetter === "e" ? 1 : 2;
      }
      return [newPitch, calcAccidental];
    }
    var accidentals = {
      dblflat: -2,
      flat: -1,
      natural: 0,
      sharp: 1,
      dblsharp: 2
    };
    var accidentals2 = {
      "-2": "dblflat",
      "-1": "flat",
      "0": "natural",
      "1": "sharp",
      "2": "dblsharp"
    };
    var accidentals3 = {
      "-2": "__",
      "-1": "_",
      "0": "=",
      "1": "^",
      "2": "^^"
    };
    transpose.note = function(multilineVars, el) {
      if (!multilineVars.localTranspose || multilineVars.clef.type === "perc")
        return;
      var origPitch = el.pitch;
      if (multilineVars.localTransposeVerticalMovement) {
        el.pitch = el.pitch + multilineVars.localTransposeVerticalMovement;
        if (el.name) {
          var actual = el.accidental ? el.name.substring(1) : el.name;
          var acc = el.accidental ? el.name[0] : "";
          var p = allNotes.pitchIndex(actual);
          el.name = acc + allNotes.noteName(p + multilineVars.localTransposeVerticalMovement);
        }
      }
      if (el.accidental) {
        var ret = accidentalChange(origPitch, el.pitch, el.accidental, multilineVars.globalTransposeOrigKeySig, multilineVars.targetKey);
        el.pitch = ret[0];
        el.accidental = accidentals2[ret[1]];
        if (el.name) {
          el.name = accidentals3[ret[1]] + el.name.replace(/[_^=]/g, "");
        }
      }
    };
    module.exports = transpose;
  }
});

// node_modules/abcjs/src/parse/abc_parse_key_voice.js
var require_abc_parse_key_voice = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_key_voice.js"(exports, module) {
    var parseDirective = require_abc_parse_directive();
    var transpose = require_abc_transpose();
    var parseKeyVoice = {};
    (function() {
      var tokenizer;
      var warn;
      var multilineVars;
      var tune;
      var tuneBuilder;
      parseKeyVoice.initialize = function(tokenizer_, warn_, multilineVars_, tune_, tuneBuilder_) {
        tokenizer = tokenizer_;
        warn = warn_;
        multilineVars = multilineVars_;
        tune = tune_;
        tuneBuilder = tuneBuilder_;
      };
      parseKeyVoice.standardKey = function(keyName, root, acc, localTranspose) {
        return transpose.keySignature(multilineVars, keyName, root, acc, localTranspose);
      };
      var clefLines = {
        "treble": { clef: "treble", pitch: 4, mid: 0 },
        "treble+8": { clef: "treble+8", pitch: 4, mid: 0 },
        "treble-8": { clef: "treble-8", pitch: 4, mid: 0 },
        "treble^8": { clef: "treble+8", pitch: 4, mid: 0 },
        "treble_8": { clef: "treble-8", pitch: 4, mid: 0 },
        "treble1": { clef: "treble", pitch: 2, mid: 2 },
        "treble2": { clef: "treble", pitch: 4, mid: 0 },
        "treble3": { clef: "treble", pitch: 6, mid: -2 },
        "treble4": { clef: "treble", pitch: 8, mid: -4 },
        "treble5": { clef: "treble", pitch: 10, mid: -6 },
        "perc": { clef: "perc", pitch: 6, mid: 0 },
        "none": { clef: "none", mid: 0 },
        "bass": { clef: "bass", pitch: 8, mid: -12 },
        "bass+8": { clef: "bass+8", pitch: 8, mid: -12 },
        "bass-8": { clef: "bass-8", pitch: 8, mid: -12 },
        "bass^8": { clef: "bass+8", pitch: 8, mid: -12 },
        "bass_8": { clef: "bass-8", pitch: 8, mid: -12 },
        "bass+16": { clef: "bass", pitch: 8, mid: -12 },
        "bass-16": { clef: "bass", pitch: 8, mid: -12 },
        "bass^16": { clef: "bass", pitch: 8, mid: -12 },
        "bass_16": { clef: "bass", pitch: 8, mid: -12 },
        "bass1": { clef: "bass", pitch: 2, mid: -6 },
        "bass2": { clef: "bass", pitch: 4, mid: -8 },
        "bass3": { clef: "bass", pitch: 6, mid: -10 },
        "bass4": { clef: "bass", pitch: 8, mid: -12 },
        "bass5": { clef: "bass", pitch: 10, mid: -14 },
        "tenor": { clef: "alto", pitch: 8, mid: -8 },
        "tenor1": { clef: "alto", pitch: 2, mid: -2 },
        "tenor2": { clef: "alto", pitch: 4, mid: -4 },
        "tenor3": { clef: "alto", pitch: 6, mid: -6 },
        "tenor4": { clef: "alto", pitch: 8, mid: -8 },
        "tenor5": { clef: "alto", pitch: 10, mid: -10 },
        "alto": { clef: "alto", pitch: 6, mid: -6 },
        "alto1": { clef: "alto", pitch: 2, mid: -2 },
        "alto2": { clef: "alto", pitch: 4, mid: -4 },
        "alto3": { clef: "alto", pitch: 6, mid: -6 },
        "alto4": { clef: "alto", pitch: 8, mid: -8 },
        "alto5": { clef: "alto", pitch: 10, mid: -10 },
        "alto+8": { clef: "alto+8", pitch: 6, mid: -6 },
        "alto-8": { clef: "alto-8", pitch: 6, mid: -6 },
        "alto^8": { clef: "alto+8", pitch: 6, mid: -6 },
        "alto_8": { clef: "alto-8", pitch: 6, mid: -6 }
      };
      var calcMiddle = function(clef, oct) {
        var value = clefLines[clef];
        var mid = value ? value.mid : 0;
        return mid + oct;
      };
      parseKeyVoice.fixClef = function(clef) {
        var value = clefLines[clef.type];
        if (value) {
          clef.clefPos = value.pitch;
          clef.type = value.clef;
        }
      };
      parseKeyVoice.deepCopyKey = function(key) {
        var ret = { accidentals: [], root: key.root, acc: key.acc, mode: key.mode };
        key.accidentals.forEach(function(k) {
          ret.accidentals.push(Object.assign({}, k));
        });
        return ret;
      };
      var pitches = { A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11 };
      parseKeyVoice.addPosToKey = function(clef, key) {
        var mid = clef.verticalPos;
        key.accidentals.forEach(function(acc) {
          var pitch = pitches[acc.note];
          pitch = pitch - mid;
          acc.verticalPos = pitch;
        });
        if (key.impliedNaturals)
          key.impliedNaturals.forEach(function(acc) {
            var pitch = pitches[acc.note];
            pitch = pitch - mid;
            acc.verticalPos = pitch;
          });
        if (mid < -10) {
          key.accidentals.forEach(function(acc) {
            acc.verticalPos -= 7;
            if (acc.verticalPos >= 11 || acc.verticalPos === 10 && acc.acc === "flat")
              acc.verticalPos -= 7;
            if (acc.note === "A" && acc.acc === "sharp")
              acc.verticalPos -= 7;
            if ((acc.note === "G" || acc.note === "F") && acc.acc === "flat")
              acc.verticalPos -= 7;
          });
          if (key.impliedNaturals)
            key.impliedNaturals.forEach(function(acc) {
              acc.verticalPos -= 7;
              if (acc.verticalPos >= 11 || acc.verticalPos === 10 && acc.acc === "flat")
                acc.verticalPos -= 7;
              if (acc.note === "A" && acc.acc === "sharp")
                acc.verticalPos -= 7;
              if ((acc.note === "G" || acc.note === "F") && acc.acc === "flat")
                acc.verticalPos -= 7;
            });
        } else if (mid < -4) {
          key.accidentals.forEach(function(acc) {
            acc.verticalPos -= 7;
            if (mid === -8 && (acc.note === "f" || acc.note === "g") && acc.acc === "sharp")
              acc.verticalPos -= 7;
          });
          if (key.impliedNaturals)
            key.impliedNaturals.forEach(function(acc) {
              acc.verticalPos -= 7;
              if (mid === -8 && (acc.note === "f" || acc.note === "g") && acc.acc === "sharp")
                acc.verticalPos -= 7;
            });
        } else if (mid >= 7) {
          key.accidentals.forEach(function(acc) {
            acc.verticalPos += 7;
          });
          if (key.impliedNaturals)
            key.impliedNaturals.forEach(function(acc) {
              acc.verticalPos += 7;
            });
        }
      };
      parseKeyVoice.fixKey = function(clef, key) {
        var fixedKey = Object.assign({}, key);
        parseKeyVoice.addPosToKey(clef, fixedKey);
        return fixedKey;
      };
      var parseMiddle = function(str) {
        var i2 = 0;
        var p = str[i2++];
        if (p === "^" || p === "_")
          p = str[i2++];
        var mid = pitches[p];
        if (mid === void 0)
          mid = 6;
        for (; i2 < str.length; i2++) {
          if (str[i2] === ",") mid -= 7;
          else if (str[i2] === "'") mid += 7;
          else break;
        }
        return { mid: mid - 6, str: str.substring(i2) };
      };
      var normalizeAccidentals = function(accs) {
        for (var i2 = 0; i2 < accs.length; i2++) {
          if (accs[i2].note === "b")
            accs[i2].note = "B";
          else if (accs[i2].note === "a")
            accs[i2].note = "A";
          else if (accs[i2].note === "F")
            accs[i2].note = "f";
          else if (accs[i2].note === "E")
            accs[i2].note = "e";
          else if (accs[i2].note === "D")
            accs[i2].note = "d";
          else if (accs[i2].note === "C")
            accs[i2].note = "c";
          else if (accs[i2].note === "G" && accs[i2].acc === "sharp")
            accs[i2].note = "g";
          else if (accs[i2].note === "g" && accs[i2].acc === "flat")
            accs[i2].note = "G";
        }
      };
      parseKeyVoice.parseKey = function(str, isInline) {
        if (str.length === 0) {
          str = "none";
        }
        var tokens = tokenizer.tokenize(str, 0, str.length);
        var ret = {};
        if (tokens.length === 0) {
          warn("Must pass in key signature.", str, 0);
          return ret;
        }
        switch (tokens[0].token) {
          case "HP":
            parseDirective.addDirective("bagpipes");
            multilineVars.key = { root: "HP", accidentals: [], acc: "", mode: "" };
            ret.foundKey = true;
            tokens.shift();
            break;
          case "Hp":
            parseDirective.addDirective("bagpipes");
            multilineVars.key = { root: "Hp", accidentals: [{ acc: "natural", note: "g" }, { acc: "sharp", note: "f" }, { acc: "sharp", note: "c" }], acc: "", mode: "" };
            ret.foundKey = true;
            tokens.shift();
            break;
          case "none":
            multilineVars.key = { root: "none", accidentals: [], acc: "", mode: "" };
            ret.foundKey = true;
            tokens.shift();
            break;
          default:
            var retPitch = tokenizer.getKeyPitch(tokens[0].token);
            if (retPitch.len > 0) {
              ret.foundKey = true;
              var acc = "";
              var mode = "";
              if (tokens[0].token.length > 1)
                tokens[0].token = tokens[0].token.substring(1);
              else
                tokens.shift();
              var key = retPitch.token;
              if (tokens.length > 0) {
                var retAcc = tokenizer.getSharpFlat(tokens[0].token);
                if (retAcc.len > 0) {
                  if (tokens[0].token.length > 1)
                    tokens[0].token = tokens[0].token.substring(1);
                  else
                    tokens.shift();
                  key += retAcc.token;
                  acc = retAcc.token;
                }
                if (tokens.length > 0) {
                  var retMode = tokenizer.getMode(tokens[0].token);
                  if (retMode.len > 0) {
                    tokens.shift();
                    key += retMode.token;
                    mode = retMode.token;
                  }
                }
                if (parseKeyVoice.standardKey(key, retPitch.token, acc, 0) === void 0) {
                  warn("Unsupported key signature: " + key, str, 0);
                  return ret;
                }
              }
              var oldKey = parseKeyVoice.deepCopyKey(multilineVars.key);
              var keyCompensate = !isInline && multilineVars.globalTranspose ? -multilineVars.globalTranspose : 0;
              var savedOrigKey;
              if (isInline)
                savedOrigKey = multilineVars.globalTransposeOrigKeySig;
              multilineVars.key = parseKeyVoice.deepCopyKey(parseKeyVoice.standardKey(key, retPitch.token, acc, keyCompensate));
              if (isInline)
                multilineVars.globalTransposeOrigKeySig = savedOrigKey;
              multilineVars.key.mode = mode;
              if (oldKey) {
                var kk;
                for (var k = 0; k < multilineVars.key.accidentals.length; k++) {
                  for (kk = 0; kk < oldKey.accidentals.length; kk++) {
                    if (oldKey.accidentals[kk].note && multilineVars.key.accidentals[k].note.toLowerCase() === oldKey.accidentals[kk].note.toLowerCase())
                      oldKey.accidentals[kk].note = null;
                  }
                }
                for (kk = 0; kk < oldKey.accidentals.length; kk++) {
                  if (oldKey.accidentals[kk].note) {
                    if (!multilineVars.key.impliedNaturals)
                      multilineVars.key.impliedNaturals = [];
                    multilineVars.key.impliedNaturals.push({ acc: "natural", note: oldKey.accidentals[kk].note });
                  }
                }
              }
            }
            break;
        }
        if (tokens.length === 0) return ret;
        if (tokens[0].token === "exp") tokens.shift();
        if (tokens.length === 0) return ret;
        if (tokens[0].token === "oct") tokens.shift();
        if (tokens.length === 0) return ret;
        var accs = tokenizer.getKeyAccidentals2(tokens);
        if (accs.warn)
          warn(accs.warn, str, 0);
        if (accs.accs) {
          if (!ret.foundKey) {
            ret.foundKey = true;
            multilineVars.key = { root: "none", acc: "", mode: "", accidentals: [] };
          }
          normalizeAccidentals(accs.accs);
          for (var i2 = 0; i2 < accs.accs.length; i2++) {
            var found = false;
            for (var j = 0; j < multilineVars.key.accidentals.length && !found; j++) {
              if (multilineVars.key.accidentals[j].note === accs.accs[i2].note) {
                found = true;
                if (multilineVars.key.accidentals[j].acc !== accs.accs[i2].acc) {
                  multilineVars.key.accidentals[j].acc = accs.accs[i2].acc;
                  if (!multilineVars.key.explicitAccidentals)
                    multilineVars.key.explicitAccidentals = [];
                  multilineVars.key.explicitAccidentals.push(accs.accs[i2]);
                }
              }
            }
            if (!found) {
              if (!multilineVars.key.explicitAccidentals)
                multilineVars.key.explicitAccidentals = [];
              multilineVars.key.explicitAccidentals.push(accs.accs[i2]);
              multilineVars.key.accidentals.push(accs.accs[i2]);
              if (multilineVars.key.impliedNaturals) {
                for (var kkk = 0; kkk < multilineVars.key.impliedNaturals.length; kkk++) {
                  if (multilineVars.key.impliedNaturals[kkk].note === accs.accs[i2].note)
                    multilineVars.key.impliedNaturals.splice(kkk, 1);
                }
              }
            }
          }
        }
        var token;
        while (tokens.length > 0) {
          switch (tokens[0].token) {
            case "m":
            case "middle":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after middle", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after middle", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after middle=", str, 0);
                return ret;
              }
              var pitch = tokenizer.getPitchFromTokens(tokens);
              if (pitch.warn)
                warn(pitch.warn, str, 0);
              if (pitch.position)
                multilineVars.clef.verticalPos = pitch.position - 6;
              break;
            case "transpose":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after transpose", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after transpose", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after transpose=", str, 0);
                return ret;
              }
              if (tokens[0].type !== "number") {
                warn("Expected number after transpose", str, tokens[0].start);
                break;
              }
              multilineVars.clef.transpose = tokens[0].intt;
              tokens.shift();
              break;
            case "stafflines":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after stafflines", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after stafflines", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after stafflines=", str, 0);
                return ret;
              }
              if (tokens[0].type !== "number") {
                warn("Expected number after stafflines", str, tokens[0].start);
                break;
              }
              multilineVars.clef.stafflines = tokens[0].intt;
              tokens.shift();
              break;
            case "staffscale":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after staffscale", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after staffscale", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after staffscale=", str, 0);
                return ret;
              }
              if (tokens[0].type !== "number") {
                warn("Expected number after staffscale", str, tokens[0].start);
                break;
              }
              multilineVars.clef.staffscale = tokens[0].floatt;
              tokens.shift();
              break;
            case "octave":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after octave", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after octave", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after octave=", str, 0);
                return ret;
              }
              if (tokens[0].type !== "number") {
                warn("Expected number after octave", str, tokens[0].start);
                break;
              }
              multilineVars.octave = tokens[0].intt;
              tokens.shift();
              break;
            case "style":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after style", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after style", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after style=", str, 0);
                return ret;
              }
              switch (tokens[0].token) {
                case "normal":
                case "harmonic":
                case "rhythm":
                case "x":
                case "triangle":
                  multilineVars.style = tokens[0].token;
                  tokens.shift();
                  break;
                default:
                  warn("error parsing style element: " + tokens[0].token, str, tokens[0].start);
                  break;
              }
              break;
            case "clef":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after clef", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after clef", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after clef=", str, 0);
                return ret;
              }
            //break; yes, we want to fall through. That allows "clef=" to be optional.
            case "treble":
            case "bass":
            case "alto":
            case "tenor":
            case "perc":
            case "none":
              var clef = tokens.shift();
              switch (clef.token) {
                case "treble":
                case "tenor":
                case "alto":
                case "bass":
                case "perc":
                case "none":
                  break;
                case "C":
                  clef.token = "alto";
                  break;
                case "F":
                  clef.token = "bass";
                  break;
                case "G":
                  clef.token = "treble";
                  break;
                case "c":
                  clef.token = "alto";
                  break;
                case "f":
                  clef.token = "bass";
                  break;
                case "g":
                  clef.token = "treble";
                  break;
                default:
                  warn("Expected clef name. Found " + clef.token, str, clef.start);
                  break;
              }
              if (tokens.length > 0 && tokens[0].type === "number") {
                clef.token += tokens[0].token;
                tokens.shift();
              }
              if (tokens.length > 1 && (tokens[0].token === "-" || tokens[0].token === "+" || tokens[0].token === "^" || tokens[0].token === "_") && tokens[1].token === "8") {
                clef.token += tokens[0].token + tokens[1].token;
                tokens.shift();
                tokens.shift();
              }
              multilineVars.clef = { type: clef.token, verticalPos: calcMiddle(clef.token, 0) };
              if (multilineVars.currentVoice && multilineVars.currentVoice.transpose !== void 0)
                multilineVars.clef.transpose = multilineVars.currentVoice.transpose;
              ret.foundClef = true;
              break;
            default:
              warn("Unknown parameter: " + tokens[0].token, str, tokens[0].start);
              tokens.shift();
          }
        }
        return ret;
      };
      var setCurrentVoice = function(id) {
        var currentVoice = multilineVars.voices[id];
        if (multilineVars.currentVoice) {
          if (multilineVars.currentVoice.index === currentVoice.index && multilineVars.currentVoice.staffNum === currentVoice.staffNum)
            return;
        }
        multilineVars.currentVoice = currentVoice;
        return tuneBuilder.setCurrentVoice(currentVoice.staffNum, currentVoice.index, id);
      };
      parseKeyVoice.parseVoice = function(line, i2, e) {
        var ret = tokenizer.getMeat(line, i2, e);
        var start = ret.start;
        var end = ret.end;
        var id = tokenizer.getToken(line, start, end);
        if (id.length === 0) {
          warn("Expected a voice id", line, start);
          return;
        }
        var isNew = false;
        if (multilineVars.voices[id] === void 0) {
          multilineVars.voices[id] = {};
          isNew = true;
          if (multilineVars.score_is_present)
            warn("Can't have an unknown V: id when the %score directive is present", line, start);
        }
        start += id.length;
        start += tokenizer.eatWhiteSpace(line, start);
        var staffInfo = { startStaff: isNew };
        var addNextTokenToStaffInfo = function(name) {
          var attr2 = tokenizer.getVoiceToken(line, start, end);
          if (attr2.warn !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.warn, line, start);
          else if (attr2.err !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.err, line, start);
          else if (attr2.token.length === 0 && line[start] !== '"')
            warn("Expected value for " + name + " in voice", line, start);
          else
            staffInfo[name] = attr2.token;
          start += attr2.len;
        };
        var addNextTokenToVoiceInfo = function(id2, name, type) {
          var attr2 = tokenizer.getVoiceToken(line, start, end);
          if (attr2.warn !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.warn, line, start);
          else if (attr2.err !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.err, line, start);
          else if (attr2.token.length === 0 && line[start] !== '"')
            warn("Expected value for " + name + " in voice", line, start);
          else {
            if (type === "number")
              attr2.token = parseFloat(attr2.token);
            multilineVars.voices[id2][name] = attr2.token;
          }
          start += attr2.len;
        };
        var getNextToken = function(name, type) {
          var attr2 = tokenizer.getVoiceToken(line, start, end);
          if (attr2.warn !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.warn, line, start);
          else if (attr2.err !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.err, line, start);
          else if (attr2.token.length === 0 && line[start] !== '"')
            warn("Expected value for " + name + " in voice", line, start);
          else {
            if (type === "number")
              attr2.token = parseFloat(attr2.token);
            return attr2.token;
          }
          start += attr2.len;
        };
        var addNextNoteTokenToVoiceInfo = function(id2, name) {
          var noteToTransposition = {
            "_B": 2,
            "_E": 9,
            "_b": -10,
            "_e": -3
          };
          var attr2 = tokenizer.getVoiceToken(line, start, end);
          if (attr2.warn !== void 0)
            warn("Expected one of (_B, _E, _b, _e) for " + name + " in voice: " + attr2.warn, line, start);
          else if (attr2.token.length === 0 && line[start] !== '"')
            warn("Expected one of (_B, _E, _b, _e) for " + name + " in voice", line, start);
          else {
            var t = noteToTransposition[attr2.token];
            if (!t)
              warn("Expected one of (_B, _E, _b, _e) for " + name + " in voice", line, start);
            else
              multilineVars.voices[id2][name] = t;
          }
          start += attr2.len;
        };
        while (start < end) {
          var token = tokenizer.getVoiceToken(line, start, end);
          start += token.len;
          if (token.warn) {
            warn("Error parsing voice: " + token.warn, line, start);
          } else {
            var attr = null;
            switch (token.token) {
              case "clef":
              case "cl":
                addNextTokenToStaffInfo("clef");
                var oct = 0;
                if (staffInfo.clef !== void 0) {
                  staffInfo.clef = staffInfo.clef.replace(/[',]/g, "");
                  if (staffInfo.clef.indexOf("+16") !== -1) {
                    oct += 14;
                    staffInfo.clef = staffInfo.clef.replace("+16", "");
                  }
                  staffInfo.verticalPos = calcMiddle(staffInfo.clef, oct);
                }
                break;
              case "treble":
              case "bass":
              case "tenor":
              case "alto":
              case "perc":
              case "none":
              case "treble'":
              case "bass'":
              case "tenor'":
              case "alto'":
              case "none'":
              case "treble''":
              case "bass''":
              case "tenor''":
              case "alto''":
              case "none''":
              case "treble,":
              case "bass,":
              case "tenor,":
              case "alto,":
              case "none,":
              case "treble,,":
              case "bass,,":
              case "tenor,,":
              case "alto,,":
              case "none,,":
                var oct2 = 0;
                staffInfo.clef = token.token.replace(/[',]/g, "");
                staffInfo.verticalPos = calcMiddle(staffInfo.clef, oct2);
                multilineVars.voices[id].clef = token.token;
                break;
              case "staves":
              case "stave":
              case "stv":
                addNextTokenToStaffInfo("staves");
                break;
              case "brace":
              case "brc":
                addNextTokenToStaffInfo("brace");
                break;
              case "bracket":
              case "brk":
                addNextTokenToStaffInfo("bracket");
                break;
              case "name":
              case "nm":
                addNextTokenToStaffInfo("name");
                break;
              case "subname":
              case "sname":
              case "snm":
                addNextTokenToStaffInfo("subname");
                break;
              case "merge":
                staffInfo.startStaff = false;
                break;
              case "stem":
              case "stems":
                attr = tokenizer.getVoiceToken(line, start, end);
                if (attr.warn !== void 0)
                  warn("Expected value for stems in voice: " + attr.warn, line, start);
                else if (attr.err !== void 0)
                  warn("Expected value for stems in voice: " + attr.err, line, start);
                else if (attr.token === "up" || attr.token === "down")
                  multilineVars.voices[id].stem = attr.token;
                else
                  warn("Expected up or down for voice stem", line, start);
                start += attr.len;
                break;
              case "up":
              case "down":
                multilineVars.voices[id].stem = token.token;
                break;
              case "middle":
              case "m":
                addNextTokenToStaffInfo("verticalPos");
                staffInfo.verticalPos = parseMiddle(staffInfo.verticalPos).mid;
                break;
              case "gchords":
              case "gch":
                multilineVars.voices[id].suppressChords = true;
                attr = tokenizer.getVoiceToken(line, start, end);
                if (attr.token === "0")
                  start = start + attr.len;
                break;
              case "space":
              case "spc":
                addNextTokenToStaffInfo("spacing");
                break;
              case "scale":
                addNextTokenToVoiceInfo(id, "scale", "number");
                break;
              case "score":
                addNextNoteTokenToVoiceInfo(id, "scoreTranspose");
                break;
              case "transpose":
                addNextTokenToVoiceInfo(id, "transpose", "number");
                break;
              case "stafflines":
                addNextTokenToVoiceInfo(id, "stafflines", "number");
                break;
              case "staffscale":
                addNextTokenToVoiceInfo(id, "staffscale", "number");
                break;
              case "octave":
                addNextTokenToVoiceInfo(id, "octave", "number");
                break;
              case "volume":
                addNextTokenToVoiceInfo(id, "volume", "number");
                break;
              case "cue":
                var cue = getNextToken("cue", "string");
                if (cue === "on")
                  multilineVars.voices[id].scale = 0.6;
                else multilineVars.voices[id].scale = 1;
                break;
              case "style":
                attr = tokenizer.getVoiceToken(line, start, end);
                if (attr.warn !== void 0)
                  warn("Expected value for style in voice: " + attr.warn, line, start);
                else if (attr.err !== void 0)
                  warn("Expected value for style in voice: " + attr.err, line, start);
                else if (attr.token === "normal" || attr.token === "harmonic" || attr.token === "rhythm" || attr.token === "x" || attr.token === "triangle")
                  multilineVars.voices[id].style = attr.token;
                else
                  warn("Expected one of [normal, harmonic, rhythm, x, triangle] for voice style", line, start);
                start += attr.len;
                break;
            }
          }
          start += tokenizer.eatWhiteSpace(line, start);
        }
        if (staffInfo.startStaff || multilineVars.staves.length === 0) {
          multilineVars.staves.push({ index: multilineVars.staves.length, meter: multilineVars.origMeter });
          if (!multilineVars.score_is_present)
            multilineVars.staves[multilineVars.staves.length - 1].numVoices = 0;
        }
        if (multilineVars.voices[id].staffNum === void 0) {
          multilineVars.voices[id].staffNum = multilineVars.staves.length - 1;
          var vi = 0;
          for (var v2 in multilineVars.voices) {
            if (multilineVars.voices.hasOwnProperty(v2)) {
              if (multilineVars.voices[v2].staffNum === multilineVars.voices[id].staffNum)
                vi++;
            }
          }
          multilineVars.voices[id].index = vi - 1;
        }
        var s2 = multilineVars.staves[multilineVars.voices[id].staffNum];
        if (!multilineVars.score_is_present)
          s2.numVoices++;
        if (staffInfo.clef) s2.clef = { type: staffInfo.clef, verticalPos: staffInfo.verticalPos };
        if (staffInfo.spacing) s2.spacing_below_offset = staffInfo.spacing;
        if (staffInfo.verticalPos) s2.verticalPos = staffInfo.verticalPos;
        if (staffInfo.name) {
          if (s2.name) s2.name.push(staffInfo.name);
          else s2.name = [staffInfo.name];
        }
        if (staffInfo.subname) {
          if (s2.subname) s2.subname.push(staffInfo.subname);
          else s2.subname = [staffInfo.subname];
        }
        return setCurrentVoice(id);
      };
    })();
    module.exports = parseKeyVoice;
  }
});

// node_modules/abcjs/src/parse/abc_parse_header.js
var require_abc_parse_header = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_header.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseDirective = require_abc_parse_directive();
    var parseKeyVoice = require_abc_parse_key_voice();
    var ParseHeader = function(tokenizer, warn, multilineVars, tune, tuneBuilder) {
      this.reset = function(tokenizer2, warn2, multilineVars2, tune2) {
        parseKeyVoice.initialize(tokenizer2, warn2, multilineVars2, tune2, tuneBuilder);
        parseDirective.initialize(tokenizer2, warn2, multilineVars2, tune2, tuneBuilder);
      };
      this.reset(tokenizer, warn, multilineVars, tune);
      this.setTitle = function(title, origSize) {
        if (multilineVars.hasMainTitle)
          tuneBuilder.addSubtitle(title, { startChar: multilineVars.iChar, endChar: multilineVars.iChar + origSize + 2 });
        else {
          tuneBuilder.addMetaText("title", title, { startChar: multilineVars.iChar, endChar: multilineVars.iChar + origSize + 2 });
          multilineVars.hasMainTitle = true;
        }
      };
      this.setMeter = function(line) {
        line = tokenizer.stripComment(line);
        if (line === "C") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "common_time" };
        } else if (line === "C|") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "cut_time" };
        } else if (line === "o") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "tempus_perfectum" };
        } else if (line === "c") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "tempus_imperfectum" };
        } else if (line === "o.") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "tempus_perfectum_prolatio" };
        } else if (line === "c.") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "tempus_imperfectum_prolatio" };
        } else if (line.length === 0 || line.toLowerCase() === "none") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return null;
        } else {
          var tokens = tokenizer.tokenize(line, 0, line.length);
          try {
            var parseNum = function() {
              var ret2 = { value: 0, num: "" };
              var tok = tokens.shift();
              if (tok.token === "(")
                tok = tokens.shift();
              while (1) {
                if (tok.type !== "number") throw "Expected top number of meter";
                ret2.value += parseInt(tok.token);
                ret2.num += tok.token;
                if (tokens.length === 0 || tokens[0].token === "/") return ret2;
                tok = tokens.shift();
                if (tok.token === ")") {
                  if (tokens.length === 0 || tokens[0].token === "/") return ret2;
                  throw "Unexpected paren in meter";
                }
                if (tok.token !== "." && tok.token !== "+") throw "Expected top number of meter";
                ret2.num += tok.token;
                if (tokens.length === 0) throw "Expected top number of meter";
                tok = tokens.shift();
              }
              return ret2;
            };
            var parseFraction = function() {
              var ret2 = parseNum();
              if (tokens.length === 0) return ret2;
              var tok = tokens.shift();
              if (tok.token !== "/") throw "Expected slash in meter";
              tok = tokens.shift();
              if (tok.type !== "number") throw "Expected bottom number of meter";
              ret2.den = tok.token;
              ret2.value = ret2.value / parseInt(ret2.den);
              return ret2;
            };
            if (tokens.length === 0) throw "Expected meter definition in M: line";
            var meter = { type: "specified", value: [] };
            var totalLength = 0;
            while (1) {
              var ret = parseFraction();
              totalLength += ret.value;
              var mv = { num: ret.num };
              if (ret.den !== void 0)
                mv.den = ret.den;
              meter.value.push(mv);
              if (tokens.length === 0) break;
            }
            if (multilineVars.havent_set_length === true) {
              multilineVars.default_length = totalLength < 0.75 ? 0.0625 : 0.125;
              multilineVars.havent_set_length = false;
            }
            return meter;
          } catch (e) {
            warn(e, line, 0);
          }
        }
        return null;
      };
      this.calcTempo = function(relTempo) {
        var dur = 1 / 4;
        if (multilineVars.meter && multilineVars.meter.type === "specified") {
          dur = 1 / parseInt(multilineVars.meter.value[0].den);
        } else if (multilineVars.origMeter && multilineVars.origMeter.type === "specified") {
          dur = 1 / parseInt(multilineVars.origMeter.value[0].den);
        }
        for (var i2 = 0; i2 < relTempo.duration; i2++)
          relTempo.duration[i2] = dur * relTempo.duration[i2];
        return relTempo;
      };
      this.resolveTempo = function() {
        if (multilineVars.tempo) {
          this.calcTempo(multilineVars.tempo);
          tune.metaText.tempo = multilineVars.tempo;
          delete multilineVars.tempo;
        }
      };
      this.addUserDefinition = function(line, start, end) {
        var equals = line.indexOf("=", start);
        if (equals === -1) {
          warn("Need an = in a macro definition", line, start);
          return;
        }
        var before = parseCommon.strip(line.substring(start, equals));
        var after = parseCommon.strip(line.substring(equals + 1));
        if (before.length !== 1) {
          warn("Macro definitions can only be one character", line, start);
          return;
        }
        var legalChars = "HIJKLMNOPQRSTUVWXYhijklmnopqrstuvw~";
        if (legalChars.indexOf(before) === -1) {
          warn("Macro definitions must be H-Y, h-w, or tilde", line, start);
          return;
        }
        if (after.length === 0) {
          warn("Missing macro definition", line, start);
          return;
        }
        if (multilineVars.macros === void 0)
          multilineVars.macros = {};
        multilineVars.macros[before] = after;
      };
      this.setDefaultLength = function(line, start, end) {
        var len = line.substring(start, end).replace(/ /g, "");
        var len_arr = len.split("/");
        if (len_arr.length === 2) {
          var n = parseInt(len_arr[0]);
          var d = parseInt(len_arr[1]);
          if (d > 0) {
            multilineVars.default_length = n / d;
            multilineVars.havent_set_length = false;
          }
        } else if (len_arr.length === 1 && len_arr[0] === "1") {
          multilineVars.default_length = 1;
          multilineVars.havent_set_length = false;
        }
      };
      var tempoString = {
        larghissimo: 20,
        adagissimo: 24,
        sostenuto: 28,
        grave: 32,
        largo: 40,
        lento: 50,
        larghetto: 60,
        adagio: 68,
        adagietto: 74,
        andante: 80,
        andantino: 88,
        "marcia moderato": 84,
        "andante moderato": 100,
        moderato: 112,
        allegretto: 116,
        "allegro moderato": 120,
        allegro: 126,
        animato: 132,
        agitato: 140,
        veloce: 148,
        "mosso vivo": 156,
        vivace: 164,
        vivacissimo: 172,
        allegrissimo: 176,
        presto: 184,
        prestissimo: 210
      };
      this.setTempo = function(line, start, end, iChar) {
        try {
          var tokens = tokenizer.tokenize(line, start, end);
          if (tokens.length === 0) throw "Missing parameter in Q: field";
          var tempo = { startChar: iChar + start - 2, endChar: iChar + end };
          var delaySet = true;
          var token = tokens.shift();
          if (token.type === "quote") {
            tempo.preString = token.token;
            token = tokens.shift();
            if (tokens.length === 0) {
              if (tempoString[tempo.preString.toLowerCase()]) {
                tempo.bpm = tempoString[tempo.preString.toLowerCase()];
                tempo.suppressBpm = true;
              }
              return { type: "immediate", tempo };
            }
          }
          if (token.type === "alpha" && token.token === "C") {
            if (tokens.length === 0) throw "Missing tempo after C in Q: field";
            token = tokens.shift();
            if (token.type === "punct" && token.token === "=") {
              if (tokens.length === 0) throw "Missing tempo after = in Q: field";
              token = tokens.shift();
              if (token.type !== "number") throw "Expected number after = in Q: field";
              tempo.duration = [1];
              tempo.bpm = parseInt(token.token);
            } else if (token.type === "number") {
              tempo.duration = [parseInt(token.token)];
              if (tokens.length === 0) throw "Missing = after duration in Q: field";
              token = tokens.shift();
              if (token.type !== "punct" || token.token !== "=") throw "Expected = after duration in Q: field";
              if (tokens.length === 0) throw "Missing tempo after = in Q: field";
              token = tokens.shift();
              if (token.type !== "number") throw "Expected number after = in Q: field";
              tempo.bpm = parseInt(token.token);
            } else throw "Expected number or equal after C in Q: field";
          } else if (token.type === "number") {
            var num = parseInt(token.token);
            if (tokens.length === 0 || tokens[0].type === "quote") {
              tempo.duration = [1];
              tempo.bpm = num;
            } else {
              delaySet = false;
              token = tokens.shift();
              if (token.type !== "punct" && token.token !== "/") throw "Expected fraction in Q: field";
              token = tokens.shift();
              if (token.type !== "number") throw "Expected fraction in Q: field";
              var den = parseInt(token.token);
              tempo.duration = [num / den];
              while (tokens.length > 0 && tokens[0].token !== "=" && tokens[0].type !== "quote") {
                token = tokens.shift();
                if (token.type !== "number") throw "Expected fraction in Q: field";
                num = parseInt(token.token);
                token = tokens.shift();
                if (token.type !== "punct" && token.token !== "/") throw "Expected fraction in Q: field";
                token = tokens.shift();
                if (token.type !== "number") throw "Expected fraction in Q: field";
                den = parseInt(token.token);
                tempo.duration.push(num / den);
              }
              token = tokens.shift();
              if (token.type !== "punct" && token.token !== "=") throw "Expected = in Q: field";
              token = tokens.shift();
              if (token.type !== "number") throw "Expected tempo in Q: field";
              tempo.bpm = parseInt(token.token);
            }
          } else throw "Unknown value in Q: field";
          if (tokens.length !== 0) {
            token = tokens.shift();
            if (token.type === "quote") {
              tempo.postString = token.token;
              token = tokens.shift();
            }
            if (tokens.length !== 0) throw "Unexpected string at end of Q: field";
          }
          if (multilineVars.printTempo === false)
            tempo.suppress = true;
          return { type: delaySet ? "delaySet" : "immediate", tempo };
        } catch (msg) {
          warn(msg, line, start);
          return { type: "none" };
        }
      };
      this.letter_to_inline_header = function(line, i2, startLine) {
        var needsNewLine = false;
        var ws = tokenizer.eatWhiteSpace(line, i2);
        i2 += ws;
        if (line.length >= i2 + 5 && line[i2] === "[" && line[i2 + 2] === ":") {
          var e = line.indexOf("]", i2);
          var startChar = multilineVars.iChar + i2;
          var endChar = multilineVars.iChar + e + 1;
          switch (line.substring(i2, i2 + 3)) {
            case "[I:":
              var err = parseDirective.addDirective(line.substring(i2 + 3, e));
              if (err) warn(err, line, i2);
              return [e - i2 + 1 + ws];
            case "[M:":
              var meter = this.setMeter(line.substring(i2 + 3, e));
              if (tuneBuilder.hasBeginMusic() && meter)
                tuneBuilder.appendStartingElement("meter", startChar, endChar, meter);
              else
                multilineVars.meter = meter;
              return [e - i2 + 1 + ws];
            case "[K:":
              var result = parseKeyVoice.parseKey(line.substring(i2 + 3, e), true);
              if (result.foundClef && tuneBuilder.hasBeginMusic())
                tuneBuilder.appendStartingElement("clef", startChar, endChar, multilineVars.clef);
              if (result.foundKey && tuneBuilder.hasBeginMusic())
                tuneBuilder.appendStartingElement("key", startChar, endChar, parseKeyVoice.fixKey(multilineVars.clef, multilineVars.key));
              return [e - i2 + 1 + ws];
            case "[P:":
              var part = parseDirective.parseFontChangeLine(line.substring(i2 + 3, e));
              if (startLine || tune.lines.length <= tune.lineNum)
                multilineVars.partForNextLine = { title: part, startChar, endChar };
              else
                tuneBuilder.appendElement("part", startChar, endChar, { title: part });
              return [e - i2 + 1 + ws];
            case "[L:":
              this.setDefaultLength(line, i2 + 3, e);
              return [e - i2 + 1 + ws];
            case "[Q:":
              if (e > 0) {
                var tempo = this.setTempo(line, i2 + 3, e, multilineVars.iChar);
                if (tempo.type === "delaySet") {
                  if (tuneBuilder.hasBeginMusic())
                    tuneBuilder.appendElement("tempo", startChar, endChar, this.calcTempo(tempo.tempo));
                  else
                    multilineVars.tempoForNextLine = ["tempo", startChar, endChar, this.calcTempo(tempo.tempo)];
                } else if (tempo.type === "immediate") {
                  if (!startLine && tuneBuilder.hasBeginMusic())
                    tuneBuilder.appendElement("tempo", startChar, endChar, tempo.tempo);
                  else
                    multilineVars.tempoForNextLine = ["tempo", startChar, endChar, tempo.tempo];
                }
                return [e - i2 + 1 + ws, line[i2 + 1], line.substring(i2 + 3, e)];
              }
              break;
            case "[V:":
              if (e > 0) {
                needsNewLine = parseKeyVoice.parseVoice(line, i2 + 3, e);
                return [e - i2 + 1 + ws, line[i2 + 1], line.substring(i2 + 3, e), needsNewLine];
              }
              break;
            case "[r:":
              return [e - i2 + 1 + ws];
            default:
          }
        }
        return [0];
      };
      this.letter_to_body_header = function(line, i2) {
        var needsNewLine = false;
        if (line.length >= i2 + 3) {
          switch (line.substring(i2, i2 + 2)) {
            case "I:":
              var err = parseDirective.addDirective(line.substring(i2 + 2));
              if (err) warn(err, line, i2);
              return [line.length];
            case "M:":
              var meter = this.setMeter(line.substring(i2 + 2));
              if (tuneBuilder.hasBeginMusic() && meter)
                tuneBuilder.appendStartingElement("meter", multilineVars.iChar + i2, multilineVars.iChar + line.length, meter);
              return [line.length];
            case "K:":
              var result = parseKeyVoice.parseKey(line.substring(i2 + 2), tuneBuilder.hasBeginMusic());
              if (result.foundClef && tuneBuilder.hasBeginMusic())
                tuneBuilder.appendStartingElement("clef", multilineVars.iChar + i2, multilineVars.iChar + line.length, multilineVars.clef);
              if (result.foundKey && tuneBuilder.hasBeginMusic())
                tuneBuilder.appendStartingElement("key", multilineVars.iChar + i2, multilineVars.iChar + line.length, parseKeyVoice.fixKey(multilineVars.clef, multilineVars.key));
              return [line.length];
            case "P:":
              if (tuneBuilder.hasBeginMusic())
                tuneBuilder.appendElement("part", multilineVars.iChar + i2, multilineVars.iChar + line.length, { title: line.substring(i2 + 2) });
              return [line.length];
            case "L:":
              this.setDefaultLength(line, i2 + 2, line.length);
              return [line.length];
            case "Q:":
              var e = line.indexOf("", i2 + 2);
              if (e === -1) e = line.length;
              var tempo = this.setTempo(line, i2 + 2, e, multilineVars.iChar);
              if (tempo.type === "delaySet") tuneBuilder.appendElement("tempo", multilineVars.iChar + i2, multilineVars.iChar + line.length, this.calcTempo(tempo.tempo));
              else if (tempo.type === "immediate") tuneBuilder.appendElement("tempo", multilineVars.iChar + i2, multilineVars.iChar + line.length, tempo.tempo);
              return [e, line[i2], parseCommon.strip(line.substring(i2 + 2))];
            case "V:":
              needsNewLine = parseKeyVoice.parseVoice(line, i2 + 2, line.length);
              return [line.length, line[i2], parseCommon.strip(line.substring(i2 + 2)), needsNewLine];
            default:
          }
        }
        return [0];
      };
      var metaTextHeaders = {
        A: "author",
        B: "book",
        C: "composer",
        D: "discography",
        F: "url",
        G: "group",
        I: "instruction",
        N: "notes",
        O: "origin",
        R: "rhythm",
        S: "source",
        W: "unalignedWords",
        Z: "transcription"
      };
      this.parseHeader = function(line) {
        var field = metaTextHeaders[line[0]];
        var origSize = line.length - 2;
        var restOfLine = tokenizer.translateString(tokenizer.stripComment(line.substring(2)));
        if (field === "unalignedWords" || field === "notes") {
          tuneBuilder.addMetaTextArray(field, parseDirective.parseFontChangeLine(restOfLine), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + line.length });
        } else if (field !== void 0) {
          tuneBuilder.addMetaText(field, parseDirective.parseFontChangeLine(restOfLine), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + line.length });
        } else {
          var startChar = multilineVars.iChar;
          var endChar = startChar + line.length;
          switch (line[0]) {
            case "H":
              tuneBuilder.addMetaTextArray("history", parseDirective.parseFontChangeLine(restOfLine), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + line.length });
              line = tokenizer.peekLine();
              while (line && line[1] !== ":") {
                tokenizer.nextLine();
                tuneBuilder.addMetaTextArray("history", parseDirective.parseFontChangeLine(tokenizer.translateString(tokenizer.stripComment(line))), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + line.length });
                line = tokenizer.peekLine();
              }
              break;
            case "K":
              this.resolveTempo();
              var result = parseKeyVoice.parseKey(line.substring(2), false);
              if (!multilineVars.is_in_header && tuneBuilder.hasBeginMusic()) {
                if (result.foundClef)
                  tuneBuilder.appendStartingElement("clef", startChar, endChar, multilineVars.clef);
                if (result.foundKey)
                  tuneBuilder.appendStartingElement("key", startChar, endChar, parseKeyVoice.fixKey(multilineVars.clef, multilineVars.key));
              }
              multilineVars.is_in_header = false;
              break;
            case "L":
              this.setDefaultLength(line, 2, line.length);
              break;
            case "M":
              multilineVars.origMeter = multilineVars.meter = this.setMeter(line.substring(2));
              break;
            case "P":
              if (multilineVars.is_in_header)
                tuneBuilder.addMetaText("partOrder", parseDirective.parseFontChangeLine(restOfLine), { startChar: multilineVars.iChar, endChar: multilineVars.iChar + line.length });
              else
                multilineVars.partForNextLine = { title: restOfLine, startChar, endChar };
              break;
            case "Q":
              var tempo = this.setTempo(line, 2, line.length, multilineVars.iChar);
              if (tempo.type === "delaySet") multilineVars.tempo = tempo.tempo;
              else if (tempo.type === "immediate") {
                if (!tune.metaText.tempo)
                  tune.metaText.tempo = tempo.tempo;
                else
                  multilineVars.tempoForNextLine = ["tempo", startChar, endChar, tempo.tempo];
              }
              break;
            case "T":
              if (multilineVars.titlecaps)
                restOfLine = restOfLine.toUpperCase();
              this.setTitle(parseDirective.parseFontChangeLine(tokenizer.theReverser(restOfLine)), origSize);
              break;
            case "U":
              this.addUserDefinition(line, 2, line.length);
              break;
            case "V":
              parseKeyVoice.parseVoice(line, 2, line.length);
              if (!multilineVars.is_in_header)
                return { newline: true };
              break;
            case "s":
              return { symbols: true };
            case "w":
              return { words: true };
            case "X":
              break;
            case "E":
            case "m":
              warn("Ignored header", line, 0);
              break;
            default:
              return { regular: true };
          }
        }
        return {};
      };
    };
    module.exports = ParseHeader;
  }
});

// node_modules/abcjs/src/parse/abc_parse_settings.js
var require_abc_parse_settings = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_settings.js"(exports, module) {
    module.exports.legalAccents = [
      "trill",
      "lowermordent",
      "uppermordent",
      "mordent",
      "pralltriller",
      "accent",
      "fermata",
      "invertedfermata",
      "tenuto",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "+",
      "wedge",
      "open",
      "thumb",
      "snap",
      "turn",
      "roll",
      "breath",
      "shortphrase",
      "mediumphrase",
      "longphrase",
      "segno",
      "coda",
      "D.S.",
      "D.C.",
      "fine",
      "beambr1",
      "beambr2",
      "slide",
      "marcato",
      "upbow",
      "downbow",
      "/",
      "//",
      "///",
      "////",
      "trem1",
      "trem2",
      "trem3",
      "trem4",
      "turnx",
      "invertedturn",
      "invertedturnx",
      "trill(",
      "trill)",
      "arpeggio",
      "xstem",
      "mark",
      "umarcato",
      "style=normal",
      "style=harmonic",
      "style=rhythm",
      "style=x",
      "style=triangle",
      "D.C.alcoda",
      "D.C.alfine",
      "D.S.alcoda",
      "D.S.alfine",
      "editorial",
      "courtesy"
    ];
    module.exports.volumeDecorations = [
      "p",
      "pp",
      "f",
      "ff",
      "mf",
      "mp",
      "ppp",
      "pppp",
      "fff",
      "ffff",
      "sfz"
    ];
    module.exports.dynamicDecorations = [
      "crescendo(",
      "crescendo)",
      "diminuendo(",
      "diminuendo)",
      "glissando(",
      "glissando)",
      "~(",
      "~)"
    ];
    module.exports.accentPseudonyms = [
      ["<", "accent"],
      [">", "accent"],
      ["tr", "trill"],
      ["plus", "+"],
      ["emphasis", "accent"],
      ["^", "umarcato"],
      ["marcato", "umarcato"]
    ];
    module.exports.accentDynamicPseudonyms = [
      ["<(", "crescendo("],
      ["<)", "crescendo)"],
      [">(", "diminuendo("],
      [">)", "diminuendo)"]
    ];
    module.exports.nonDecorations = "ABCDEFGabcdefgxyzZ[]|^_{";
    module.exports.durations = [
      0.5,
      0.75,
      0.875,
      0.9375,
      0.96875,
      0.984375,
      0.25,
      0.375,
      0.4375,
      0.46875,
      0.484375,
      0.4921875,
      0.125,
      0.1875,
      0.21875,
      0.234375,
      0.2421875,
      0.24609375,
      0.0625,
      0.09375,
      0.109375,
      0.1171875,
      0.12109375,
      0.123046875,
      0.03125,
      0.046875,
      0.0546875,
      0.05859375,
      0.060546875,
      0.0615234375,
      0.015625,
      0.0234375,
      0.02734375,
      0.029296875,
      0.0302734375,
      0.03076171875
    ];
    module.exports.pitches = {
      A: 5,
      B: 6,
      C: 0,
      D: 1,
      E: 2,
      F: 3,
      G: 4,
      a: 12,
      b: 13,
      c: 7,
      d: 8,
      e: 9,
      f: 10,
      g: 11
    };
    module.exports.rests = {
      x: "invisible",
      X: "invisible-multimeasure",
      y: "spacer",
      z: "rest",
      Z: "multimeasure"
    };
    module.exports.accMap = {
      dblflat: "__",
      flat: "_",
      natural: "=",
      sharp: "^",
      dblsharp: "^^",
      quarterflat: "_/",
      quartersharp: "^/"
    };
    module.exports.tripletQ = {
      2: 3,
      3: 2,
      4: 3,
      5: 2,
      // TODO-PER: not handling 6/8 rhythm yet
      6: 2,
      7: 2,
      // TODO-PER: not handling 6/8 rhythm yet
      8: 3,
      9: 2
      // TODO-PER: not handling 6/8 rhythm yet
    };
  }
});

// node_modules/abcjs/src/parse/abc_parse_music.js
var require_abc_parse_music = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_music.js"(exports, module) {
    var parseKeyVoice = require_abc_parse_key_voice();
    var transpose = require_abc_transpose();
    var tokenizer;
    var warn;
    var multilineVars;
    var tune;
    var tuneBuilder;
    var header;
    var {
      legalAccents,
      volumeDecorations,
      dynamicDecorations,
      accentPseudonyms,
      accentDynamicPseudonyms,
      nonDecorations,
      durations,
      pitches,
      rests,
      accMap,
      tripletQ
    } = require_abc_parse_settings();
    var MusicParser = function(_tokenizer, _warn, _multilineVars, _tune, _tuneBuilder, _header) {
      tokenizer = _tokenizer;
      warn = _warn;
      multilineVars = _multilineVars;
      tune = _tune;
      tuneBuilder = _tuneBuilder;
      header = _header;
      this.lineContinuation = false;
    };
    var isInTie = function(multilineVars2, overlayLevel, el2) {
      if (multilineVars2.inTie[overlayLevel] === void 0)
        return false;
      var voiceIndex = multilineVars2.currentVoice ? multilineVars2.currentVoice.staffNum * 100 + multilineVars2.currentVoice.index : 0;
      if (multilineVars2.inTie[overlayLevel][voiceIndex]) {
        if (el2.pitches !== void 0 || el2.rest.type !== "spacer")
          return true;
      }
      return false;
    };
    var el = {};
    MusicParser.prototype.parseMusic = function(line) {
      header.resolveTempo();
      multilineVars.is_in_header = false;
      var i2 = 0;
      var startOfLine = multilineVars.iChar;
      while (tokenizer.isWhiteSpace(line[i2]) && i2 < line.length)
        i2++;
      if (i2 === line.length || line[i2] === "%")
        return;
      var delayStartNewLine = multilineVars.start_new_line;
      if (multilineVars.continueall === void 0)
        multilineVars.start_new_line = true;
      else
        multilineVars.start_new_line = false;
      var tripletNotesLeft = 0;
      var retHeader = header.letter_to_body_header(line, i2);
      if (retHeader[0] > 0) {
        i2 += retHeader[0];
        if (retHeader[1] === "V")
          this.startNewLine();
      }
      var overlayLevel = 0;
      while (i2 < line.length) {
        var startI = i2;
        if (line[i2] === "%")
          break;
        var retInlineHeader = header.letter_to_inline_header(line, i2, delayStartNewLine);
        if (retInlineHeader[0] > 0) {
          i2 += retInlineHeader[0];
          if (retInlineHeader[1] === "V")
            delayStartNewLine = true;
        } else {
          if (!tuneBuilder.hasBeginMusic() || delayStartNewLine && !this.lineContinuation) {
            this.startNewLine();
            delayStartNewLine = false;
          }
          var ret;
          while (1) {
            ret = tokenizer.eatWhiteSpace(line, i2);
            if (ret > 0) {
              i2 += ret;
            }
            if (i2 > 0 && line[i2 - 1] === "") {
              ret = header.letter_to_body_header(line, i2);
              if (ret[0] > 0) {
                if (ret[1] === "V")
                  this.startNewLine();
                i2 = ret[0];
                multilineVars.start_new_line = false;
              }
            }
            ret = letter_to_spacer(line, i2);
            if (ret[0] > 0) {
              i2 += ret[0];
            }
            ret = letter_to_chord(line, i2);
            if (ret[0] > 0) {
              if (!el.chord)
                el.chord = [];
              var chordName = tokenizer.translateString(ret[1]);
              chordName = chordName.replace(/;/g, "\n");
              var addedChord = false;
              for (var ci = 0; ci < el.chord.length; ci++) {
                if (el.chord[ci].position === ret[2]) {
                  addedChord = true;
                  el.chord[ci].name += "\n" + chordName;
                }
              }
              if (addedChord === false) {
                if (ret[2] === null && ret[3])
                  el.chord.push({ name: chordName, rel_position: ret[3] });
                else
                  el.chord.push({ name: chordName, position: ret[2] });
              }
              i2 += ret[0];
              var ii = tokenizer.skipWhiteSpace(line.substring(i2));
              if (ii > 0)
                el.force_end_beam_last = true;
              i2 += ii;
            } else {
              if (nonDecorations.indexOf(line[i2]) === -1)
                ret = letter_to_accent(line, i2);
              else ret = [0];
              if (ret[0] > 0) {
                if (ret[1] === null) {
                  if (i2 + 1 < line.length)
                    this.startNewLine();
                } else if (ret[1].length > 0) {
                  if (ret[1].indexOf("style=") === 0) {
                    el.style = ret[1].substr(6);
                  } else {
                    if (el.decoration === void 0)
                      el.decoration = [];
                    if (ret[1] === "beambr1")
                      el.beambr = 1;
                    else if (ret[1] === "beambr2")
                      el.beambr = 2;
                    else el.decoration.push(ret[1]);
                  }
                }
                i2 += ret[0];
              } else {
                ret = letter_to_grace(line, i2);
                if (ret[0] > 0) {
                  el.gracenotes = ret[1];
                  i2 += ret[0];
                } else
                  break;
              }
            }
          }
          ret = letter_to_bar(line, i2);
          if (ret[0] > 0) {
            overlayLevel = 0;
            if (el.gracenotes !== void 0) {
              el.rest = { type: "spacer" };
              el.duration = 0.125;
              multilineVars.addFormattingOptions(el, tune.formatting, "note");
              tuneBuilder.appendElement("note", startOfLine + i2, startOfLine + i2 + ret[0], el);
              multilineVars.measureNotEmpty = true;
              el = {};
            }
            var bar = { type: ret[1] };
            if (bar.type.length === 0)
              warn("Unknown bar type", line, i2);
            else {
              if (multilineVars.inEnding && bar.type !== "bar_thin") {
                bar.endEnding = true;
                multilineVars.inEnding = false;
              }
              if (ret[2]) {
                bar.startEnding = ret[2];
                if (multilineVars.inEnding)
                  bar.endEnding = true;
                multilineVars.inEnding = true;
                if (ret[1] === "bar_right_repeat") {
                  multilineVars.restoreStartEndingHoldOvers();
                } else {
                  multilineVars.duplicateStartEndingHoldOvers();
                }
              }
              if (el.decoration !== void 0)
                bar.decoration = el.decoration;
              if (el.chord !== void 0)
                bar.chord = el.chord;
              if (bar.startEnding && multilineVars.barFirstEndingNum === void 0)
                multilineVars.barFirstEndingNum = multilineVars.currBarNumber;
              else if (bar.startEnding && bar.endEnding && multilineVars.barFirstEndingNum)
                multilineVars.currBarNumber = multilineVars.barFirstEndingNum;
              else if (bar.endEnding)
                multilineVars.barFirstEndingNum = void 0;
              if (bar.type !== "bar_invisible" && multilineVars.measureNotEmpty) {
                if (isFirstVoice()) {
                  multilineVars.currBarNumber++;
                  if (multilineVars.barNumbers && multilineVars.currBarNumber % multilineVars.barNumbers === 0)
                    bar.barNumber = multilineVars.currBarNumber;
                }
              }
              multilineVars.addFormattingOptions(el, tune.formatting, "bar");
              tuneBuilder.appendElement("bar", startOfLine + startI, startOfLine + i2 + ret[0], bar);
              multilineVars.measureNotEmpty = false;
              el = {};
            }
            i2 += ret[0];
          } else if (line[i2] === "&") {
            ret = letter_to_overlay(line, i2);
            if (ret[0] > 0) {
              tuneBuilder.appendElement("overlay", startOfLine, startOfLine + 1, {});
              i2 += 1;
              overlayLevel++;
            }
          } else {
            ret = letter_to_open_slurs_and_triplets(line, i2);
            if (ret.consumed > 0) {
              if (ret.startSlur !== void 0)
                el.startSlur = ret.startSlur;
              if (ret.dottedSlur)
                el.dottedSlur = true;
              if (ret.triplet !== void 0) {
                if (tripletNotesLeft > 0)
                  warn("Can't nest triplets", line, i2);
                else {
                  el.startTriplet = ret.triplet;
                  el.tripletMultiplier = ret.tripletQ / ret.triplet;
                  el.tripletR = ret.num_notes;
                  tripletNotesLeft = ret.num_notes === void 0 ? ret.triplet : ret.num_notes;
                }
              }
              i2 += ret.consumed;
            }
            if (line[i2] === "[") {
              var chordStartChar = i2;
              i2++;
              var chordDuration = null;
              var rememberEndBeam = false;
              var done = false;
              while (!done) {
                var accent = letter_to_accent(line, i2);
                if (accent[0] > 0) {
                  i2 += accent[0];
                }
                var chordNote = getCoreNote(line, i2, {}, false);
                if (chordNote !== null && chordNote.pitch !== void 0) {
                  if (accent[0] > 0) {
                    if (accent[1].indexOf("style=") !== 0) {
                      if (el.decoration === void 0)
                        el.decoration = [];
                      el.decoration.push(accent[1]);
                    }
                  }
                  if (chordNote.end_beam) {
                    el.end_beam = true;
                    delete chordNote.end_beam;
                  }
                  if (el.pitches === void 0) {
                    el.duration = chordNote.duration;
                    el.pitches = [chordNote];
                  } else
                    el.pitches.push(chordNote);
                  delete chordNote.duration;
                  if (accent[0] > 0) {
                    if (accent[1].indexOf("style=") === 0) {
                      el.pitches[el.pitches.length - 1].style = accent[1].substr(6);
                    }
                  }
                  if (multilineVars.inTieChord[el.pitches.length]) {
                    chordNote.endTie = true;
                    multilineVars.inTieChord[el.pitches.length] = void 0;
                  }
                  if (chordNote.startTie)
                    multilineVars.inTieChord[el.pitches.length] = true;
                  i2 = chordNote.endChar;
                  delete chordNote.endChar;
                } else if (line[i2] === " ") {
                  warn("Spaces are not allowed in chords", line, i2);
                  i2++;
                } else {
                  if (i2 < line.length && line[i2] === "]") {
                    i2++;
                    if (multilineVars.next_note_duration !== 0) {
                      el.duration = el.duration * multilineVars.next_note_duration;
                      multilineVars.next_note_duration = 0;
                    }
                    if (isInTie(multilineVars, overlayLevel, el)) {
                      el.pitches.forEach(function(pitch) {
                        pitch.endTie = true;
                      });
                      setIsInTie(multilineVars, overlayLevel, false);
                    }
                    if (tripletNotesLeft > 0 && !(el.rest && el.rest.type === "spacer")) {
                      tripletNotesLeft--;
                      if (tripletNotesLeft === 0) {
                        el.endTriplet = true;
                      }
                    }
                    var postChordDone = false;
                    while (i2 < line.length && !postChordDone) {
                      switch (line[i2]) {
                        case " ":
                        case "	":
                          addEndBeam(el);
                          break;
                        case ")":
                          if (el.endSlur === void 0) el.endSlur = 1;
                          else el.endSlur++;
                          break;
                        case "-":
                          el.pitches.forEach(function(pitch) {
                            pitch.startTie = {};
                          });
                          setIsInTie(multilineVars, overlayLevel, true);
                          break;
                        case ">":
                        case "<":
                          var br2 = getBrokenRhythm(line, i2);
                          i2 += br2[0] - 1;
                          multilineVars.next_note_duration = br2[2];
                          if (chordDuration)
                            chordDuration = chordDuration * br2[1];
                          else
                            chordDuration = br2[1];
                          break;
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "8":
                        case "9":
                        case "/":
                          var fraction = tokenizer.getFraction(line, i2);
                          chordDuration = fraction.value;
                          i2 = fraction.index;
                          var ch = line[i2];
                          if (ch === " ")
                            rememberEndBeam = true;
                          if (ch === "-" || ch === ")" || ch === " " || ch === "<" || ch === ">")
                            i2--;
                          else
                            postChordDone = true;
                          break;
                        case "0":
                          chordDuration = 0;
                          break;
                        default:
                          postChordDone = true;
                          break;
                      }
                      if (!postChordDone) {
                        i2++;
                      }
                    }
                  } else
                    warn("Expected ']' to end the chords", line, i2);
                  if (el.pitches !== void 0) {
                    if (chordDuration !== null) {
                      el.duration = el.duration * chordDuration;
                      if (rememberEndBeam)
                        addEndBeam(el);
                    }
                    multilineVars.addFormattingOptions(el, tune.formatting, "note");
                    tuneBuilder.appendElement("note", startOfLine + startI, startOfLine + i2, el);
                    multilineVars.measureNotEmpty = true;
                    el = {};
                  }
                  done = true;
                }
              }
            } else {
              var el2 = {};
              var core = getCoreNote(line, i2, el2, true);
              if (el2.endTie !== void 0) setIsInTie(multilineVars, overlayLevel, true);
              if (core !== null) {
                if (core.pitch !== void 0) {
                  el.pitches = [{}];
                  if (core.accidental !== void 0) el.pitches[0].accidental = core.accidental;
                  el.pitches[0].pitch = core.pitch;
                  el.pitches[0].name = core.name;
                  if (core.midipitch || core.midipitch === 0)
                    el.pitches[0].midipitch = core.midipitch;
                  if (core.endSlur !== void 0) el.pitches[0].endSlur = core.endSlur;
                  if (core.endTie !== void 0) el.pitches[0].endTie = core.endTie;
                  if (core.startSlur !== void 0) el.pitches[0].startSlur = core.startSlur;
                  if (el.startSlur !== void 0) el.pitches[0].startSlur = el.startSlur;
                  if (el.dottedSlur !== void 0) el.pitches[0].dottedSlur = true;
                  if (core.startTie !== void 0) el.pitches[0].startTie = core.startTie;
                  if (el.startTie !== void 0) el.pitches[0].startTie = el.startTie;
                } else {
                  el.rest = core.rest;
                  if (core.rest.type === "multimeasure" && isFirstVoice())
                    multilineVars.currBarNumber += core.rest.text - 1;
                  if (core.endSlur !== void 0) el.endSlur = core.endSlur;
                  if (core.endTie !== void 0) el.rest.endTie = core.endTie;
                  if (core.startSlur !== void 0) el.startSlur = core.startSlur;
                  if (core.startTie !== void 0) el.rest.startTie = core.startTie;
                  if (el.startTie !== void 0) el.rest.startTie = el.startTie;
                }
                if (core.chord !== void 0) el.chord = core.chord;
                if (core.duration !== void 0) el.duration = core.duration;
                if (core.decoration !== void 0) el.decoration = core.decoration;
                if (core.graceNotes !== void 0) el.graceNotes = core.graceNotes;
                delete el.startSlur;
                delete el.dottedSlur;
                if (isInTie(multilineVars, overlayLevel, el)) {
                  if (el.pitches !== void 0) {
                    el.pitches[0].endTie = true;
                  } else if (el.rest.type !== "spacer") {
                    el.rest.endTie = true;
                  }
                  setIsInTie(multilineVars, overlayLevel, false);
                }
                if (core.startTie || el.startTie)
                  setIsInTie(multilineVars, overlayLevel, true);
                i2 = core.endChar;
                if (tripletNotesLeft > 0 && !(core.rest && core.rest.type === "spacer")) {
                  tripletNotesLeft--;
                  if (tripletNotesLeft === 0) {
                    el.endTriplet = true;
                  }
                }
                if (core.end_beam)
                  addEndBeam(el);
                if (el.rest && el.rest.type === "rest" && el.duration === 1 && durationOfMeasure(multilineVars) <= 1) {
                  el.rest.type = "whole";
                  el.duration = durationOfMeasure(multilineVars);
                }
                if (el.duration < 1 && durations.indexOf(el.duration) === -1 && el.duration !== 0) {
                  if (!el.rest || el.rest.type !== "spacer")
                    warn("Duration not representable: " + line.substring(startI, i2), line, i2);
                }
                multilineVars.addFormattingOptions(el, tune.formatting, "note");
                var succeeded = tuneBuilder.appendElement("note", startOfLine + startI, startOfLine + i2, el);
                if (!succeeded) {
                  this.startNewLine();
                  tuneBuilder.appendElement("note", startOfLine + startI, startOfLine + i2, el);
                }
                multilineVars.measureNotEmpty = true;
                el = {};
              }
            }
            if (i2 === startI) {
              if (line[i2] !== " " && line[i2] !== "`")
                warn("Unknown character ignored", line, i2);
              i2++;
            }
          }
        }
      }
      this.lineContinuation = line.indexOf("") >= 0 || retHeader[0] > 0;
      if (!this.lineContinuation) {
        el = {};
      }
    };
    var setIsInTie = function(multilineVars2, overlayLevel, value) {
      var voiceIndex = multilineVars2.currentVoice ? multilineVars2.currentVoice.staffNum * 100 + multilineVars2.currentVoice.index : 0;
      if (multilineVars2.inTie[overlayLevel] === void 0)
        multilineVars2.inTie[overlayLevel] = [];
      multilineVars2.inTie[overlayLevel][voiceIndex] = value;
    };
    var letter_to_chord = function(line, i2) {
      if (line[i2] === '"') {
        var chord = tokenizer.getBrackettedSubstring(line, i2, 5);
        if (!chord[2])
          warn("Missing the closing quote while parsing the chord symbol", line, i2);
        if (chord[0] > 0 && chord[1].length > 0 && chord[1][0] === "^") {
          chord[1] = chord[1].substring(1);
          chord[2] = "above";
        } else if (chord[0] > 0 && chord[1].length > 0 && chord[1][0] === "_") {
          chord[1] = chord[1].substring(1);
          chord[2] = "below";
        } else if (chord[0] > 0 && chord[1].length > 0 && chord[1][0] === "<") {
          chord[1] = chord[1].substring(1);
          chord[2] = "left";
        } else if (chord[0] > 0 && chord[1].length > 0 && chord[1][0] === ">") {
          chord[1] = chord[1].substring(1);
          chord[2] = "right";
        } else if (chord[0] > 0 && chord[1].length > 0 && chord[1][0] === "@") {
          chord[1] = chord[1].substring(1);
          var x = tokenizer.getFloat(chord[1]);
          if (x.digits === 0) {
            warn("Missing first position in absolutely positioned annotation.", line, i2);
            chord[1] = chord[1].replace("@", "");
            chord[2] = "above";
            return chord;
          }
          chord[1] = chord[1].substring(x.digits);
          if (chord[1][0] !== ",") {
            warn("Missing comma absolutely positioned annotation.", line, i2);
            chord[1] = chord[1].replace("@", "");
            chord[2] = "above";
            return chord;
          }
          chord[1] = chord[1].substring(1);
          var y = tokenizer.getFloat(chord[1]);
          if (y.digits === 0) {
            warn("Missing second position in absolutely positioned annotation.", line, i2);
            chord[1] = chord[1].replace("@", "");
            chord[2] = "above";
            return chord;
          }
          chord[1] = chord[1].substring(y.digits);
          var ws = tokenizer.skipWhiteSpace(chord[1]);
          chord[1] = chord[1].substring(ws);
          chord[2] = null;
          chord[3] = {
            x: x.value,
            y: y.value
          };
        } else {
          if (multilineVars.freegchord !== true) {
            chord[1] = chord[1].replace(/([ABCDEFG0-9])b/g, "$1♭");
            chord[1] = chord[1].replace(/([ABCDEFG0-9])#/g, "$1♯");
            chord[1] = chord[1].replace(/^([ABCDEFG])([♯♭]?)o([^A-Za-z])/g, "$1$2°$3");
            chord[1] = chord[1].replace(/^([ABCDEFG])([♯♭]?)o$/g, "$1$2°");
            chord[1] = chord[1].replace(/^([ABCDEFG])([♯♭]?)0([^A-Za-z])/g, "$1$2ø$3");
            chord[1] = chord[1].replace(/^([ABCDEFG])([♯♭]?)\^([^A-Za-z])/g, "$1$2∆$3");
          }
          chord[2] = "default";
          chord[1] = transpose.chordName(multilineVars, chord[1]);
        }
        return chord;
      }
      return [0, ""];
    };
    var letter_to_grace = function(line, i2) {
      if (line[i2] === "{") {
        var gra = tokenizer.getBrackettedSubstring(line, i2, 1, "}");
        if (!gra[2])
          warn("Missing the closing '}' while parsing grace note", line, i2);
        if (line[i2 + gra[0]] === ")") {
          gra[0]++;
          gra[1] += ")";
        }
        var gracenotes = [];
        var ii = 0;
        var inTie = false;
        while (ii < gra[1].length) {
          var acciaccatura = false;
          if (gra[1][ii] === "/") {
            acciaccatura = true;
            ii++;
          }
          var note = getCoreNote(gra[1], ii, {}, false);
          if (note !== null) {
            note.duration = note.duration / (multilineVars.default_length * 8);
            if (acciaccatura)
              note.acciaccatura = true;
            if (note.rest) {
              warn("Rests not allowed as grace notes '" + gra[1][ii] + "' while parsing grace note", line, i2);
            } else
              gracenotes.push(note);
            if (inTie) {
              note.endTie = true;
              inTie = false;
            }
            if (note.startTie)
              inTie = true;
            ii = note.endChar;
            delete note.endChar;
            if (note.end_beam) {
              note.endBeam = true;
              delete note.end_beam;
            }
          } else {
            if (gra[1][ii] === " ") {
              if (gracenotes.length > 0)
                gracenotes[gracenotes.length - 1].endBeam = true;
            } else
              warn("Unknown character '" + gra[1][ii] + "' while parsing grace note", line, i2);
            ii++;
          }
        }
        if (gracenotes.length)
          return [gra[0], gracenotes];
      }
      return [0];
    };
    function letter_to_overlay(line, i2) {
      if (line[i2] === "&") {
        var start = i2;
        while (line[i2] && line[i2] !== ":" && line[i2] !== "|")
          i2++;
        return [i2 - start, line.substring(start + 1, i2)];
      }
      return [0];
    }
    function durationOfMeasure(multilineVars2) {
      var meter = multilineVars2.origMeter;
      if (!meter || meter.type !== "specified")
        return 1;
      if (!meter.value || meter.value.length === 0)
        return 1;
      return parseInt(meter.value[0].num, 10) / parseInt(meter.value[0].den, 10);
    }
    var letter_to_accent = function(line, i2) {
      var macro = multilineVars.macros[line[i2]];
      if (macro !== void 0) {
        if (macro[0] === "!" || macro[0] === "+")
          macro = macro.substring(1);
        if (macro[macro.length - 1] === "!" || macro[macro.length - 1] === "+")
          macro = macro.substring(0, macro.length - 1);
        if (legalAccents.includes(macro))
          return [1, macro];
        else if (volumeDecorations.includes(macro)) {
          if (multilineVars.volumePosition === "hidden")
            macro = "";
          return [1, macro];
        } else if (dynamicDecorations.includes(macro)) {
          if (multilineVars.dynamicPosition === "hidden")
            macro = "";
          return [1, macro];
        } else {
          if (!multilineVars.ignoredDecorations.includes(macro))
            warn("Unknown macro: " + macro, line, i2);
          return [1, ""];
        }
      }
      switch (line[i2]) {
        case ".":
          if (line[i2 + 1] === "(" || line[i2 + 1] === "-")
            break;
          return [1, "staccato"];
        case "u":
          return [1, "upbow"];
        case "v":
          return [1, "downbow"];
        case "~":
          return [1, "irishroll"];
        case "!":
        case "+":
          var ret = tokenizer.getBrackettedSubstring(line, i2, 5);
          if (ret[1].length > 1 && (ret[1][0] === "^" || ret[1][0] === "_"))
            ret[1] = ret[1].substring(1);
          if (legalAccents.includes(ret[1]))
            return ret;
          if (volumeDecorations.includes(ret[1])) {
            if (multilineVars.volumePosition === "hidden")
              ret[1] = "";
            return ret;
          }
          if (dynamicDecorations.includes(ret[1])) {
            if (multilineVars.dynamicPosition === "hidden")
              ret[1] = "";
            return ret;
          }
          var ind = accentPseudonyms.findIndex(function(acc) {
            return ret[1] === acc[0];
          });
          if (ind >= 0) {
            ret[1] = accentPseudonyms[ind][1];
            return ret;
          }
          ind = accentDynamicPseudonyms.findIndex(function(acc) {
            return ret[1] === acc[0];
          });
          if (ind >= 0) {
            ret[1] = accentDynamicPseudonyms[ind][1];
            if (multilineVars.dynamicPosition === "hidden")
              ret[1] = "";
            return ret;
          }
          if (line[i2] === "!" && (ret[0] === 1 || line[i2 + ret[0] - 1] !== "!"))
            return [1, null];
          warn("Unknown decoration: " + ret[1], line, i2);
          ret[1] = "";
          return ret;
        case "H":
          return [1, "fermata"];
        case "J":
          return [1, "slide"];
        case "L":
          return [1, "accent"];
        case "M":
          return [1, "mordent"];
        case "O":
          return [1, "coda"];
        case "P":
          return [1, "pralltriller"];
        case "R":
          return [1, "roll"];
        case "S":
          return [1, "segno"];
        case "T":
          return [1, "trill"];
      }
      return [0, 0];
    };
    var letter_to_spacer = function(line, i2) {
      var start = i2;
      while (tokenizer.isWhiteSpace(line[i2]))
        i2++;
      return [i2 - start];
    };
    var letter_to_bar = function(line, curr_pos) {
      var ret = tokenizer.getBarLine(line, curr_pos);
      if (ret.len === 0)
        return [0, ""];
      if (ret.warn) {
        warn(ret.warn, line, curr_pos);
        return [ret.len, ""];
      }
      for (var ws = 0; ws < line.length; ws++)
        if (line[curr_pos + ret.len + ws] !== " ")
          break;
      var orig_bar_len = ret.len;
      if (line[curr_pos + ret.len + ws] === "[") {
        ret.len += ws + 1;
      }
      if (line[curr_pos + ret.len] === '"' && line[curr_pos + ret.len - 1] === "[") {
        var ending = tokenizer.getBrackettedSubstring(line, curr_pos + ret.len, 5);
        return [ret.len + ending[0], ret.token, ending[1]];
      }
      var retRep = tokenizer.getTokenOf(line.substring(curr_pos + ret.len), "1234567890-,");
      if (retRep.len === 0 || retRep.token[0] === "-")
        return [orig_bar_len, ret.token];
      return [ret.len + retRep.len, ret.token, retRep.token];
    };
    var letter_to_open_slurs_and_triplets = function(line, i2) {
      var ret = {};
      var start = i2;
      if (line[i2] === "." && line[i2 + 1] === "(") {
        ret.dottedSlur = true;
        i2++;
      }
      while (line[i2] === "(" || tokenizer.isWhiteSpace(line[i2])) {
        if (line[i2] === "(") {
          if (i2 + 1 < line.length && (line[i2 + 1] >= "2" && line[i2 + 1] <= "9")) {
            if (ret.triplet !== void 0)
              warn("Can't nest triplets", line, i2);
            else {
              ret.triplet = line[i2 + 1] - "0";
              ret.tripletQ = tripletQ[ret.triplet];
              ret.num_notes = ret.triplet;
              if (i2 + 2 < line.length && line[i2 + 2] === ":") {
                if (i2 + 3 < line.length && line[i2 + 3] === ":") {
                  if (i2 + 4 < line.length && (line[i2 + 4] >= "1" && line[i2 + 4] <= "9")) {
                    ret.num_notes = line[i2 + 4] - "0";
                    i2 += 3;
                  } else
                    warn("expected number after the two colons after the triplet to mark the duration", line, i2);
                } else if (i2 + 3 < line.length && (line[i2 + 3] >= "1" && line[i2 + 3] <= "9")) {
                  ret.tripletQ = line[i2 + 3] - "0";
                  if (i2 + 4 < line.length && line[i2 + 4] === ":") {
                    if (i2 + 5 < line.length && (line[i2 + 5] >= "1" && line[i2 + 5] <= "9")) {
                      ret.num_notes = line[i2 + 5] - "0";
                      i2 += 4;
                    }
                  } else {
                    i2 += 2;
                  }
                } else
                  warn("expected number after the triplet to mark the duration", line, i2);
              }
            }
            i2++;
          } else {
            if (ret.startSlur === void 0)
              ret.startSlur = 1;
            else
              ret.startSlur++;
          }
        }
        i2++;
      }
      ret.consumed = i2 - start;
      return ret;
    };
    MusicParser.prototype.startNewLine = function() {
      var params = { startChar: -1, endChar: -1 };
      if (multilineVars.partForNextLine.title)
        params.part = multilineVars.partForNextLine;
      params.clef = multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].clef !== void 0 ? Object.assign({}, multilineVars.staves[multilineVars.currentVoice.staffNum].clef) : Object.assign({}, multilineVars.clef);
      var scoreTranspose = multilineVars.currentVoice ? multilineVars.currentVoice.scoreTranspose : 0;
      params.key = parseKeyVoice.standardKey(multilineVars.key.root + multilineVars.key.acc + multilineVars.key.mode, multilineVars.key.root, multilineVars.key.acc, scoreTranspose);
      params.key.mode = multilineVars.key.mode;
      if (multilineVars.key.impliedNaturals)
        params.key.impliedNaturals = multilineVars.key.impliedNaturals;
      if (multilineVars.key.explicitAccidentals) {
        for (var i2 = 0; i2 < multilineVars.key.explicitAccidentals.length; i2++) {
          var found = false;
          for (var j = 0; j < params.key.accidentals.length; j++) {
            if (params.key.accidentals[j].note === multilineVars.key.explicitAccidentals[i2].note) {
              params.key.accidentals[j].acc = multilineVars.key.explicitAccidentals[i2].acc;
              found = true;
            }
          }
          if (!found)
            params.key.accidentals.push(multilineVars.key.explicitAccidentals[i2]);
        }
      }
      multilineVars.targetKey = params.key;
      if (params.key.explicitAccidentals)
        delete params.key.explicitAccidentals;
      parseKeyVoice.addPosToKey(params.clef, params.key);
      if (multilineVars.meter !== null) {
        if (multilineVars.currentVoice) {
          multilineVars.staves.forEach(function(st) {
            st.meter = multilineVars.meter;
          });
          params.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;
          multilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;
        } else
          params.meter = multilineVars.meter;
        multilineVars.meter = null;
      } else if (multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].meter) {
        params.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;
        multilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;
      }
      if (multilineVars.currentVoice && multilineVars.currentVoice.name)
        params.name = multilineVars.currentVoice.name;
      if (multilineVars.vocalfont)
        params.vocalfont = multilineVars.vocalfont;
      if (multilineVars.tripletfont)
        params.tripletfont = multilineVars.tripletfont;
      if (multilineVars.gchordfont)
        params.gchordfont = multilineVars.gchordfont;
      if (multilineVars.style)
        params.style = multilineVars.style;
      if (multilineVars.currentVoice) {
        var staff = multilineVars.staves[multilineVars.currentVoice.staffNum];
        if (staff.brace) params.brace = staff.brace;
        if (staff.bracket) params.bracket = staff.bracket;
        if (staff.connectBarLines) params.connectBarLines = staff.connectBarLines;
        if (staff.name) params.name = staff.name[multilineVars.currentVoice.index];
        if (staff.subname) params.subname = staff.subname[multilineVars.currentVoice.index];
        if (multilineVars.currentVoice.stem)
          params.stem = multilineVars.currentVoice.stem;
        if (multilineVars.currentVoice.stafflines)
          params.stafflines = multilineVars.currentVoice.stafflines;
        if (multilineVars.currentVoice.staffscale)
          params.staffscale = multilineVars.currentVoice.staffscale;
        if (multilineVars.currentVoice.scale)
          params.scale = multilineVars.currentVoice.scale;
        if (multilineVars.currentVoice.color)
          params.color = multilineVars.currentVoice.color;
        if (multilineVars.currentVoice.style)
          params.style = multilineVars.currentVoice.style;
        if (multilineVars.currentVoice.transpose)
          params.clef.transpose = multilineVars.currentVoice.transpose;
        params.currentVoice = multilineVars.currentVoice;
        var voices = Object.keys(multilineVars.voices);
        for (var mv = 0; mv < voices.length; mv++) {
          if (params.currentVoice.staffNum === multilineVars.voices[voices[mv]].staffNum && params.currentVoice.index === multilineVars.voices[voices[mv]].index)
            params.currentVoiceName = voices[mv];
        }
      }
      if (multilineVars.barNumbers === 0 && isFirstVoice() && multilineVars.currBarNumber !== 1)
        params.barNumber = multilineVars.currBarNumber;
      tuneBuilder.startNewLine(params);
      if (multilineVars.key.impliedNaturals)
        delete multilineVars.key.impliedNaturals;
      multilineVars.partForNextLine = {};
      if (multilineVars.tempoForNextLine.length === 4)
        tuneBuilder.appendElement(multilineVars.tempoForNextLine[0], multilineVars.tempoForNextLine[1], multilineVars.tempoForNextLine[2], multilineVars.tempoForNextLine[3]);
      multilineVars.tempoForNextLine = [];
    };
    var addEndBeam = function(el2) {
      if (el2.duration !== void 0 && el2.duration < 0.25)
        el2.end_beam = true;
      return el2;
    };
    var getCoreNote = function(line, index, el2, canHaveBrokenRhythm) {
      var isComplete = function(state2) {
        return state2 === "octave" || state2 === "duration" || state2 === "Zduration" || state2 === "broken_rhythm" || state2 === "end_slur";
      };
      var dottedTie;
      if (line[index] === "." && line[index + 1] === "-") {
        dottedTie = true;
        index++;
      }
      var state = "startSlur";
      var durationSetByPreviousNote = false;
      while (1) {
        switch (line[index]) {
          case "(":
            if (state === "startSlur") {
              if (el2.startSlur === void 0) el2.startSlur = 1;
              else el2.startSlur++;
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else return null;
            break;
          case ")":
            if (isComplete(state)) {
              if (el2.endSlur === void 0) el2.endSlur = 1;
              else el2.endSlur++;
            } else return null;
            break;
          case "^":
            if (state === "startSlur") {
              el2.accidental = "sharp";
              state = "sharp2";
            } else if (state === "sharp2") {
              el2.accidental = "dblsharp";
              state = "pitch";
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else return null;
            break;
          case "_":
            if (state === "startSlur") {
              el2.accidental = "flat";
              state = "flat2";
            } else if (state === "flat2") {
              el2.accidental = "dblflat";
              state = "pitch";
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else return null;
            break;
          case "=":
            if (state === "startSlur") {
              el2.accidental = "natural";
              state = "pitch";
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else return null;
            break;
          case "A":
          case "B":
          case "C":
          case "D":
          case "E":
          case "F":
          case "G":
          case "a":
          case "b":
          case "c":
          case "d":
          case "e":
          case "f":
          case "g":
            if (state === "startSlur" || state === "sharp2" || state === "flat2" || state === "pitch") {
              el2.pitch = pitches[line[index]];
              el2.pitch += 7 * (multilineVars.currentVoice && multilineVars.currentVoice.octave !== void 0 ? multilineVars.currentVoice.octave : multilineVars.octave);
              el2.name = line[index];
              if (el2.accidental)
                el2.name = accMap[el2.accidental] + el2.name;
              transpose.note(multilineVars, el2);
              state = "octave";
              if (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {
                el2.duration = multilineVars.default_length * multilineVars.next_note_duration;
                multilineVars.next_note_duration = 0;
                durationSetByPreviousNote = true;
              } else
                el2.duration = multilineVars.default_length;
              if (multilineVars.clef && multilineVars.clef.type === "perc" || multilineVars.currentVoice && multilineVars.currentVoice.clef === "perc") {
                var key = line[index];
                if (el2.accidental) {
                  key = accMap[el2.accidental] + key;
                }
                if (tune.formatting && tune.formatting.midi && tune.formatting.midi.drummap)
                  el2.midipitch = tune.formatting.midi.drummap[key];
              }
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else return null;
            break;
          case ",":
            if (state === "octave") {
              el2.pitch -= 7;
              el2.name += ",";
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else return null;
            break;
          case "'":
            if (state === "octave") {
              el2.pitch += 7;
              el2.name += "'";
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else return null;
            break;
          case "x":
          case "X":
          case "y":
          case "z":
          case "Z":
            if (state === "startSlur") {
              el2.rest = { type: rests[line[index]] };
              delete el2.accidental;
              delete el2.startSlur;
              delete el2.startTie;
              delete el2.endSlur;
              delete el2.endTie;
              delete el2.end_beam;
              delete el2.grace_notes;
              if (el2.rest.type.indexOf("multimeasure") >= 0) {
                el2.duration = tune.getBarLength();
                el2.rest.text = 1;
                state = "Zduration";
              } else {
                if (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {
                  el2.duration = multilineVars.default_length * multilineVars.next_note_duration;
                  multilineVars.next_note_duration = 0;
                  durationSetByPreviousNote = true;
                } else
                  el2.duration = multilineVars.default_length;
                state = "duration";
              }
            } else if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            } else return null;
            break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
          case "0":
          case "/":
            if (state === "octave" || state === "duration") {
              var fraction = tokenizer.getFraction(line, index);
              el2.duration = el2.duration * fraction.value;
              el2.endChar = fraction.index;
              while (fraction.index < line.length && (tokenizer.isWhiteSpace(line[fraction.index]) || line[fraction.index] === "-")) {
                if (line[fraction.index] === "-")
                  el2.startTie = {};
                else
                  el2 = addEndBeam(el2);
                fraction.index++;
              }
              index = fraction.index - 1;
              state = "broken_rhythm";
            } else if (state === "sharp2") {
              el2.accidental = "quartersharp";
              state = "pitch";
            } else if (state === "flat2") {
              el2.accidental = "quarterflat";
              state = "pitch";
            } else if (state === "Zduration") {
              var num = tokenizer.getNumber(line, index);
              el2.duration = num.num * tune.getBarLength();
              el2.rest.text = num.num;
              el2.endChar = num.index;
              return el2;
            } else return null;
            break;
          case "-":
            if (state === "startSlur") {
              tuneBuilder.addTieToLastNote(dottedTie);
              el2.endTie = true;
            } else if (state === "octave" || state === "duration" || state === "end_slur") {
              el2.startTie = {};
              if (!durationSetByPreviousNote && canHaveBrokenRhythm)
                state = "broken_rhythm";
              else {
                if (tokenizer.isWhiteSpace(line[index + 1]))
                  addEndBeam(el2);
                el2.endChar = index + 1;
                return el2;
              }
            } else if (state === "broken_rhythm") {
              el2.endChar = index;
              return el2;
            } else return null;
            break;
          case " ":
          case "	":
            if (isComplete(state)) {
              el2.end_beam = true;
              dottedTie = false;
              do {
                if (line[index] === "." && line[index + 1] === "-") {
                  dottedTie = true;
                  index++;
                }
                if (line[index] === "-") {
                  el2.startTie = {};
                  if (dottedTie)
                    el2.startTie.style = "dotted";
                }
                index++;
              } while (index < line.length && (tokenizer.isWhiteSpace(line[index]) || line[index] === "-") || line[index] === "." && line[index + 1] === "-");
              el2.endChar = index;
              if (!durationSetByPreviousNote && canHaveBrokenRhythm && (line[index] === "<" || line[index] === ">")) {
                index--;
                state = "broken_rhythm";
              } else
                return el2;
            } else return null;
            break;
          case ">":
          case "<":
            if (isComplete(state)) {
              if (canHaveBrokenRhythm) {
                var br2 = getBrokenRhythm(line, index);
                index += br2[0] - 1;
                multilineVars.next_note_duration = br2[2];
                el2.duration = br2[1] * el2.duration;
                state = "end_slur";
              } else {
                el2.endChar = index;
                return el2;
              }
            } else
              return null;
            break;
          default:
            if (isComplete(state)) {
              el2.endChar = index;
              return el2;
            }
            return null;
        }
        index++;
        if (index === line.length) {
          if (isComplete(state)) {
            el2.endChar = index;
            return el2;
          } else return null;
        }
      }
      return null;
    };
    var getBrokenRhythm = function(line, index) {
      switch (line[index]) {
        case ">":
          if (index < line.length - 2 && line[index + 1] === ">" && line[index + 2] === ">")
            return [3, 1.875, 0.125];
          else if (index < line.length - 1 && line[index + 1] === ">")
            return [2, 1.75, 0.25];
          else
            return [1, 1.5, 0.5];
        case "<":
          if (index < line.length - 2 && line[index + 1] === "<" && line[index + 2] === "<")
            return [3, 0.125, 1.875];
          else if (index < line.length - 1 && line[index + 1] === "<")
            return [2, 0.25, 1.75];
          else
            return [1, 0.5, 1.5];
      }
      return null;
    };
    function isFirstVoice() {
      return multilineVars.currentVoice === void 0 || multilineVars.currentVoice.staffNum === 0 && multilineVars.currentVoice.index === 0;
    }
    module.exports = MusicParser;
  }
});

// node_modules/abcjs/src/parse/abc_tokenizer.js
var require_abc_tokenizer = __commonJS({
  "node_modules/abcjs/src/parse/abc_tokenizer.js"(exports, module) {
    var parseCommon = require_abc_common();
    var Tokenizer = function(lines, multilineVars) {
      this.lineIndex = 0;
      this.lines = lines;
      this.multilineVars = multilineVars;
      this.skipWhiteSpace = function(str) {
        for (var i2 = 0; i2 < str.length; i2++) {
          if (!this.isWhiteSpace(str[i2]))
            return i2;
        }
        return str.length;
      };
      var finished = function(str, i2) {
        return i2 >= str.length;
      };
      this.eatWhiteSpace = function(line, index) {
        for (var i2 = index; i2 < line.length; i2++) {
          if (!this.isWhiteSpace(line[i2]))
            return i2 - index;
        }
        return i2 - index;
      };
      this.getKeyPitch = function(str) {
        var i2 = this.skipWhiteSpace(str);
        if (finished(str, i2))
          return { len: 0 };
        switch (str[i2]) {
          case "A":
            return { len: i2 + 1, token: "A" };
          case "B":
            return { len: i2 + 1, token: "B" };
          case "C":
            return { len: i2 + 1, token: "C" };
          case "D":
            return { len: i2 + 1, token: "D" };
          case "E":
            return { len: i2 + 1, token: "E" };
          case "F":
            return { len: i2 + 1, token: "F" };
          case "G":
            return { len: i2 + 1, token: "G" };
        }
        return { len: 0 };
      };
      this.getSharpFlat = function(str) {
        if (str === "bass")
          return { len: 0 };
        switch (str[0]) {
          case "#":
            return { len: 1, token: "#" };
          case "b":
            return { len: 1, token: "b" };
        }
        return { len: 0 };
      };
      this.getMode = function(str) {
        var skipAlpha = function(str2, start) {
          while (start < str2.length && (str2[start] >= "a" && str2[start] <= "z" || str2[start] >= "A" && str2[start] <= "Z"))
            start++;
          return start;
        };
        var i2 = this.skipWhiteSpace(str);
        if (finished(str, i2))
          return { len: 0 };
        var firstThree = str.substring(i2, i2 + 3).toLowerCase();
        if (firstThree.length > 1 && firstThree[1] === " " || firstThree[1] === "^" || firstThree[1] === "_" || firstThree[1] === "=") firstThree = firstThree[0];
        switch (firstThree) {
          case "mix":
            return { len: skipAlpha(str, i2), token: "Mix" };
          case "dor":
            return { len: skipAlpha(str, i2), token: "Dor" };
          case "phr":
            return { len: skipAlpha(str, i2), token: "Phr" };
          case "lyd":
            return { len: skipAlpha(str, i2), token: "Lyd" };
          case "loc":
            return { len: skipAlpha(str, i2), token: "Loc" };
          case "aeo":
            return { len: skipAlpha(str, i2), token: "m" };
          case "maj":
            return { len: skipAlpha(str, i2), token: "" };
          case "ion":
            return { len: skipAlpha(str, i2), token: "" };
          case "min":
            return { len: skipAlpha(str, i2), token: "m" };
          case "m":
            return { len: skipAlpha(str, i2), token: "m" };
        }
        return { len: 0 };
      };
      this.getClef = function(str, bExplicitOnly) {
        var strOrig = str;
        var i2 = this.skipWhiteSpace(str);
        if (finished(str, i2))
          return { len: 0 };
        var needsClef = false;
        var strClef = str.substring(i2);
        if (parseCommon.startsWith(strClef, "clef=")) {
          needsClef = true;
          strClef = strClef.substring(5);
          i2 += 5;
        }
        if (strClef.length === 0 && needsClef)
          return { len: i2 + 5, warn: "No clef specified: " + strOrig };
        var j = this.skipWhiteSpace(strClef);
        if (finished(strClef, j))
          return { len: 0 };
        if (j > 0) {
          i2 += j;
          strClef = strClef.substring(j);
        }
        var name = null;
        if (parseCommon.startsWith(strClef, "treble"))
          name = "treble";
        else if (parseCommon.startsWith(strClef, "bass3"))
          name = "bass3";
        else if (parseCommon.startsWith(strClef, "bass"))
          name = "bass";
        else if (parseCommon.startsWith(strClef, "tenor"))
          name = "tenor";
        else if (parseCommon.startsWith(strClef, "alto2"))
          name = "alto2";
        else if (parseCommon.startsWith(strClef, "alto1"))
          name = "alto1";
        else if (parseCommon.startsWith(strClef, "alto"))
          name = "alto";
        else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, "none")))
          name = "none";
        else if (parseCommon.startsWith(strClef, "perc"))
          name = "perc";
        else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, "C")))
          name = "tenor";
        else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, "F")))
          name = "bass";
        else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, "G")))
          name = "treble";
        else
          return { len: i2 + 5, warn: "Unknown clef specified: " + strOrig };
        strClef = strClef.substring(name.length);
        j = this.isMatch(strClef, "+8");
        if (j > 0)
          name += "+8";
        else {
          j = this.isMatch(strClef, "-8");
          if (j > 0)
            name += "-8";
        }
        return { len: i2 + name.length, token: name, explicit: needsClef };
      };
      this.getBarLine = function(line, i2) {
        switch (line[i2]) {
          case "]":
            ++i2;
            switch (line[i2]) {
              case "|":
                return { len: 2, token: "bar_thick_thin" };
              case "[":
                ++i2;
                if (line[i2] >= "1" && line[i2] <= "9" || line[i2] === '"')
                  return { len: 2, token: "bar_invisible" };
                return { len: 1, warn: "Unknown bar symbol" };
              default:
                return { len: 1, token: "bar_invisible" };
            }
            break;
          case ":":
            ++i2;
            switch (line[i2]) {
              case ":":
                return { len: 2, token: "bar_dbl_repeat" };
              case "|":
                ++i2;
                switch (line[i2]) {
                  case "]":
                    ++i2;
                    switch (line[i2]) {
                      case "|":
                        ++i2;
                        if (line[i2] === ":") return { len: 5, token: "bar_dbl_repeat" };
                        return { len: 3, token: "bar_right_repeat" };
                      default:
                        return { len: 3, token: "bar_right_repeat" };
                    }
                    break;
                  case "|":
                    ++i2;
                    if (line[i2] === ":") return { len: 4, token: "bar_dbl_repeat" };
                    return { len: 3, token: "bar_right_repeat" };
                  default:
                    return { len: 2, token: "bar_right_repeat" };
                }
                break;
              default:
                return { len: 1, warn: "Unknown bar symbol" };
            }
            break;
          case "[":
            ++i2;
            if (line[i2] === "|") {
              ++i2;
              switch (line[i2]) {
                case ":":
                  return { len: 3, token: "bar_left_repeat" };
                case "]":
                  return { len: 3, token: "bar_invisible" };
                default:
                  return { len: 2, token: "bar_thick_thin" };
              }
            } else {
              if (line[i2] >= "1" && line[i2] <= "9" || line[i2] === '"')
                return { len: 1, token: "bar_invisible" };
              return { len: 0 };
            }
            break;
          case "|":
            ++i2;
            switch (line[i2]) {
              case "]":
                return { len: 2, token: "bar_thin_thick" };
              case "|":
                ++i2;
                if (line[i2] === ":") return { len: 3, token: "bar_left_repeat" };
                return { len: 2, token: "bar_thin_thin" };
              case ":":
                var colons = 0;
                while (line[i2 + colons] === ":") colons++;
                return { len: 1 + colons, token: "bar_left_repeat" };
              default:
                return { len: 1, token: "bar_thin" };
            }
            break;
        }
        return { len: 0 };
      };
      this.getTokenOf = function(str, legalChars) {
        for (var i2 = 0; i2 < str.length; i2++) {
          if (legalChars.indexOf(str[i2]) < 0)
            return { len: i2, token: str.substring(0, i2) };
        }
        return { len: i2, token: str };
      };
      this.getToken = function(str, start, end) {
        var i2 = start;
        while (i2 < end && !this.isWhiteSpace(str[i2]))
          i2++;
        return str.substring(start, i2);
      };
      this.isMatch = function(str, match) {
        var i2 = this.skipWhiteSpace(str);
        if (finished(str, i2))
          return 0;
        if (parseCommon.startsWith(str.substring(i2), match))
          return i2 + match.length;
        return 0;
      };
      this.getPitchFromTokens = function(tokens) {
        var ret = {};
        var pitches = { A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11 };
        ret.position = pitches[tokens[0].token];
        if (ret.position === void 0)
          return { warn: "Pitch expected. Found: " + tokens[0].token };
        tokens.shift();
        while (tokens.length) {
          switch (tokens[0].token) {
            case ",":
              ret.position -= 7;
              tokens.shift();
              break;
            case "'":
              ret.position += 7;
              tokens.shift();
              break;
            default:
              return ret;
          }
        }
        return ret;
      };
      this.getKeyAccidentals2 = function(tokens) {
        var accs;
        while (tokens.length > 0) {
          var acc;
          if (tokens[0].token === "^") {
            acc = "sharp";
            tokens.shift();
            if (tokens.length === 0) return { accs, warn: "Expected note name after " + acc };
            switch (tokens[0].token) {
              case "^":
                acc = "dblsharp";
                tokens.shift();
                break;
              case "/":
                acc = "quartersharp";
                tokens.shift();
                break;
            }
          } else if (tokens[0].token === "=") {
            acc = "natural";
            tokens.shift();
          } else if (tokens[0].token === "_") {
            acc = "flat";
            tokens.shift();
            if (tokens.length === 0) return { accs, warn: "Expected note name after " + acc };
            switch (tokens[0].token) {
              case "_":
                acc = "dblflat";
                tokens.shift();
                break;
              case "/":
                acc = "quarterflat";
                tokens.shift();
                break;
            }
          } else {
            return { accs };
          }
          if (tokens.length === 0) return { accs, warn: "Expected note name after " + acc };
          switch (tokens[0].token[0]) {
            case "a":
            case "b":
            case "c":
            case "d":
            case "e":
            case "f":
            case "g":
            case "A":
            case "B":
            case "C":
            case "D":
            case "E":
            case "F":
            case "G":
              if (accs === void 0)
                accs = [];
              accs.push({ acc, note: tokens[0].token[0] });
              if (tokens[0].token.length === 1)
                tokens.shift();
              else
                tokens[0].token = tokens[0].token.substring(1);
              break;
            default:
              return { accs, warn: "Expected note name after " + acc + " Found: " + tokens[0].token };
          }
        }
        return { accs };
      };
      this.getKeyAccidental = function(str) {
        var accTranslation = {
          "^": "sharp",
          "^^": "dblsharp",
          "=": "natural",
          "_": "flat",
          "__": "dblflat",
          "_/": "quarterflat",
          "^/": "quartersharp"
        };
        var i2 = this.skipWhiteSpace(str);
        if (finished(str, i2))
          return { len: 0 };
        var acc = null;
        switch (str[i2]) {
          case "^":
          case "_":
          case "=":
            acc = str[i2];
            break;
          default:
            return { len: 0 };
        }
        i2++;
        if (finished(str, i2))
          return { len: 1, warn: "Expected note name after accidental" };
        switch (str[i2]) {
          case "a":
          case "b":
          case "c":
          case "d":
          case "e":
          case "f":
          case "g":
          case "A":
          case "B":
          case "C":
          case "D":
          case "E":
          case "F":
          case "G":
            return { len: i2 + 1, token: { acc: accTranslation[acc], note: str[i2] } };
          case "^":
          case "_":
          case "/":
            acc += str[i2];
            i2++;
            if (finished(str, i2))
              return { len: 2, warn: "Expected note name after accidental" };
            switch (str[i2]) {
              case "a":
              case "b":
              case "c":
              case "d":
              case "e":
              case "f":
              case "g":
              case "A":
              case "B":
              case "C":
              case "D":
              case "E":
              case "F":
              case "G":
                return { len: i2 + 1, token: { acc: accTranslation[acc], note: str[i2] } };
              default:
                return { len: 2, warn: "Expected note name after accidental" };
            }
            break;
          default:
            return { len: 1, warn: "Expected note name after accidental" };
        }
      };
      this.isWhiteSpace = function(ch) {
        return ch === " " || ch === "	" || ch === "";
      };
      this.getMeat = function(line, start, end) {
        var comment = line.indexOf("%", start);
        if (comment >= 0 && comment < end)
          end = comment;
        while (start < end && (line[start] === " " || line[start] === "	" || line[start] === ""))
          start++;
        while (start < end && (line[end - 1] === " " || line[end - 1] === "	" || line[end - 1] === ""))
          end--;
        return { start, end };
      };
      var isLetter = function(ch) {
        return ch >= "A" && ch <= "Z" || ch >= "a" && ch <= "z";
      };
      var isNumber = function(ch) {
        return ch >= "0" && ch <= "9";
      };
      this.tokenize = function(line, start, end, alphaUntilWhiteSpace) {
        var ret = this.getMeat(line, start, end);
        start = ret.start;
        end = ret.end;
        var tokens = [];
        var i2;
        while (start < end) {
          if (line[start] === '"') {
            i2 = start + 1;
            while (i2 < end && line[i2] !== '"') i2++;
            tokens.push({ type: "quote", token: line.substring(start + 1, i2), start: start + 1, end: i2 });
            i2++;
          } else if (isLetter(line[start])) {
            i2 = start + 1;
            if (alphaUntilWhiteSpace)
              while (i2 < end && !this.isWhiteSpace(line[i2])) i2++;
            else
              while (i2 < end && isLetter(line[i2])) i2++;
            tokens.push({ type: "alpha", token: line.substring(start, i2), continueId: isNumber(line[i2]), start, end: i2 });
            start = i2 + 1;
          } else if (line[start] === "." && isNumber(line[i2 + 1])) {
            i2 = start + 1;
            var int2 = null;
            var float2 = null;
            while (i2 < end && isNumber(line[i2])) i2++;
            float2 = parseFloat(line.substring(start, i2));
            tokens.push({ type: "number", token: line.substring(start, i2), intt: int2, floatt: float2, continueId: isLetter(line[i2]), start, end: i2 });
            start = i2 + 1;
          } else if (isNumber(line[start]) || line[start] === "-" && isNumber(line[i2 + 1])) {
            i2 = start + 1;
            var intt = null;
            var floatt = null;
            while (i2 < end && isNumber(line[i2])) i2++;
            if (line[i2] === "." && isNumber(line[i2 + 1])) {
              i2++;
              while (i2 < end && isNumber(line[i2])) i2++;
            } else
              intt = parseInt(line.substring(start, i2));
            floatt = parseFloat(line.substring(start, i2));
            tokens.push({ type: "number", token: line.substring(start, i2), intt, floatt, continueId: isLetter(line[i2]), start, end: i2 });
            start = i2 + 1;
          } else if (line[start] === " " || line[start] === "	") {
            i2 = start + 1;
          } else {
            tokens.push({ type: "punct", token: line[start], start, end: start + 1 });
            i2 = start + 1;
          }
          start = i2;
        }
        return tokens;
      };
      this.getVoiceToken = function(line, start, end) {
        var i2 = start;
        while (i2 < end && this.isWhiteSpace(line[i2]) || line[i2] === "=")
          i2++;
        if (line[i2] === '"') {
          var close = line.indexOf('"', i2 + 1);
          if (close === -1 || close >= end)
            return { len: 1, err: "Missing close quote" };
          return { len: close - start + 1, token: this.translateString(line.substring(i2 + 1, close)) };
        } else {
          var ii = i2;
          while (ii < end && !this.isWhiteSpace(line[ii]) && line[ii] !== "=")
            ii++;
          return { len: ii - start + 1, token: line.substring(i2, ii) };
        }
      };
      var charMap = {
        "`a": "à",
        "'a": "á",
        "^a": "â",
        "~a": "ã",
        '"a': "ä",
        "oa": "å",
        "aa": "å",
        "=a": "ā",
        "ua": "ă",
        ";a": "ą",
        "`e": "è",
        "'e": "é",
        "^e": "ê",
        '"e': "ë",
        "=e": "ē",
        "ue": "ĕ",
        ";e": "ę",
        ".e": "ė",
        "`i": "ì",
        "'i": "í",
        "^i": "î",
        '"i': "ï",
        "=i": "ī",
        "ui": "ĭ",
        ";i": "į",
        "`o": "ò",
        "'o": "ó",
        "^o": "ô",
        "~o": "õ",
        '"o': "ö",
        "=o": "ō",
        "uo": "ŏ",
        "/o": "ø",
        "`u": "ù",
        "'u": "ú",
        "^u": "û",
        "~u": "ũ",
        '"u': "ü",
        "ou": "ů",
        "=u": "ū",
        "uu": "ŭ",
        ";u": "ų",
        "`A": "À",
        "'A": "Á",
        "^A": "Â",
        "~A": "Ã",
        '"A': "Ä",
        "oA": "Å",
        "AA": "Å",
        "=A": "Ā",
        "uA": "Ă",
        ";A": "Ą",
        "`E": "È",
        "'E": "É",
        "^E": "Ê",
        '"E': "Ë",
        "=E": "Ē",
        "uE": "Ĕ",
        ";E": "Ę",
        ".E": "Ė",
        "`I": "Ì",
        "'I": "Í",
        "^I": "Î",
        "~I": "Ĩ",
        '"I': "Ï",
        "=I": "Ī",
        "uI": "Ĭ",
        ";I": "Į",
        ".I": "İ",
        "`O": "Ò",
        "'O": "Ó",
        "^O": "Ô",
        "~O": "Õ",
        '"O': "Ö",
        "=O": "Ō",
        "uO": "Ŏ",
        "/O": "Ø",
        "`U": "Ù",
        "'U": "Ú",
        "^U": "Û",
        "~U": "Ũ",
        '"U': "Ü",
        "oU": "Ů",
        "=U": "Ū",
        "uU": "Ŭ",
        ";U": "Ų",
        "ae": "æ",
        "AE": "Æ",
        "oe": "œ",
        "OE": "Œ",
        "ss": "ß",
        "'c": "ć",
        "^c": "ĉ",
        "uc": "č",
        "cc": "ç",
        ".c": "ċ",
        "cC": "Ç",
        "'C": "Ć",
        "^C": "Ĉ",
        "uC": "Č",
        ".C": "Ċ",
        "~N": "Ñ",
        "~n": "ñ",
        "=s": "š",
        "vs": "š",
        "DH": "Ð",
        "dh": "ð",
        "HO": "Ő",
        "Ho": "ő",
        "HU": "Ű",
        "Hu": "ű",
        "'Y": "Ý",
        "'y": "ý",
        "^Y": "Ŷ",
        "^y": "ŷ",
        '"Y': "Ÿ",
        '"y': "ÿ",
        "vS": "Š",
        "vZ": "Ž",
        "vz": "ž"
        // More chars: Ĳ ĳ Ď ď Đ đ Ĝ ĝ Ğ ğ Ġ ġ Ģ ģ Ĥ ĥ Ħ ħ Ĵ ĵ Ķ ķ ĸ Ĺ ĺ Ļ ļ Ľ ľ Ŀ ŀ Ł ł Ń ń Ņ ņ Ň ň ŉ Ŋ ŋ Ŕ ŕ Ŗ ŗ Ř ř Ś ś Ŝ ŝ Ş ş Š Ţ ţ Ť ť Ŧ ŧ Ŵ ŵ Ź ź Ż ż Ž
      };
      var charMap1 = {
        "#": "♯",
        "b": "♭",
        "=": "♮"
      };
      var charMap2 = {
        "201": "♯",
        "202": "♭",
        "203": "♮",
        "241": "¡",
        "242": "¢",
        "252": "a",
        "262": "2",
        "272": "o",
        "302": "Â",
        "312": "Ê",
        "322": "Ò",
        "332": "Ú",
        "342": "â",
        "352": "ê",
        "362": "ò",
        "372": "ú",
        "243": "£",
        "253": "«",
        "263": "3",
        "273": "»",
        "303": "Ã",
        "313": "Ë",
        "323": "Ó",
        "333": "Û",
        "343": "ã",
        "353": "ë",
        "363": "ó",
        "373": "û",
        "244": "¤",
        "254": "¬",
        "264": "  ́",
        "274": "1⁄4",
        "304": "Ä",
        "314": "Ì",
        "324": "Ô",
        "334": "Ü",
        "344": "ä",
        "354": "ì",
        "364": "ô",
        "374": "ü",
        "245": "¥",
        "255": "-",
        "265": "μ",
        "275": "1⁄2",
        "305": "Å",
        "315": "Í",
        "325": "Õ",
        "335": "Ý",
        "345": "å",
        "355": "í",
        "365": "õ",
        "375": "ý",
        "246": "¦",
        "256": "®",
        "266": "¶",
        "276": "3⁄4",
        "306": "Æ",
        "316": "Î",
        "326": "Ö",
        "336": "Þ",
        "346": "æ",
        "356": "î",
        "366": "ö",
        "376": "þ",
        "247": "§",
        "257": " ̄",
        "267": "·",
        "277": "¿",
        "307": "Ç",
        "317": "Ï",
        "327": "×",
        "337": "ß",
        "347": "ç",
        "357": "ï",
        "367": "÷",
        "377": "ÿ",
        "250": " ̈",
        "260": "°",
        "270": " ̧",
        "300": "À",
        "310": "È",
        "320": "Ð",
        "330": "Ø",
        "340": "à",
        "350": "è",
        "360": "ð",
        "370": "ø",
        "251": "©",
        "261": "±",
        "271": "1",
        "301": "Á",
        "311": "É",
        "321": "Ñ",
        "331": "Ù",
        "341": "á",
        "351": "é",
        "361": "ñ",
        "371": "ù"
      };
      this.translateString = function(str) {
        var arr = str.split("\\");
        if (arr.length === 1) return str;
        var out = null;
        arr.forEach(function(s2) {
          if (out === null)
            out = s2;
          else {
            var c = charMap[s2.substring(0, 2)];
            if (c !== void 0)
              out += c + s2.substring(2);
            else {
              c = charMap2[s2.substring(0, 3)];
              if (c !== void 0)
                out += c + s2.substring(3);
              else {
                c = charMap1[s2.substring(0, 1)];
                if (c !== void 0)
                  out += c + s2.substring(1);
                else
                  out += "\\" + s2;
              }
            }
          }
        });
        return out;
      };
      this.getNumber = function(line, index) {
        var num = 0;
        while (index < line.length) {
          switch (line[index]) {
            case "0":
              num = num * 10;
              index++;
              break;
            case "1":
              num = num * 10 + 1;
              index++;
              break;
            case "2":
              num = num * 10 + 2;
              index++;
              break;
            case "3":
              num = num * 10 + 3;
              index++;
              break;
            case "4":
              num = num * 10 + 4;
              index++;
              break;
            case "5":
              num = num * 10 + 5;
              index++;
              break;
            case "6":
              num = num * 10 + 6;
              index++;
              break;
            case "7":
              num = num * 10 + 7;
              index++;
              break;
            case "8":
              num = num * 10 + 8;
              index++;
              break;
            case "9":
              num = num * 10 + 9;
              index++;
              break;
            default:
              return { num, index };
          }
        }
        return { num, index };
      };
      this.getFraction = function(line, index) {
        var num = 1;
        var den = 1;
        if (line[index] !== "/") {
          var ret = this.getNumber(line, index);
          num = ret.num;
          index = ret.index;
        }
        if (line[index] === "/") {
          index++;
          if (line[index] === "/") {
            var div = 0.5;
            while (line[index++] === "/")
              div = div / 2;
            return { value: num * div, index: index - 1 };
          } else {
            var iSave = index;
            var ret2 = this.getNumber(line, index);
            if (ret2.num === 0 && iSave === index)
              ret2.num = 2;
            if (ret2.num !== 0)
              den = ret2.num;
            index = ret2.index;
          }
        }
        return { value: num / den, index };
      };
      function getTitleNumber(str) {
        const regex = /^(\d+)\./;
        const match = regex.exec(str);
        if (match) {
          const foundNumber = match[1];
          return foundNumber;
        } else {
          return null;
        }
      }
      var thePatterns = [
        { match: /,\s*[Tt]he$/, replace: "The " },
        { match: /,\s*[Aa]$/, replace: "A " },
        { match: /,\s*[Aa]n$/, replace: "An " }
      ];
      this.theReverser = function(str) {
        for (var i2 = 0; i2 < thePatterns.length; i2++) {
          var thisPattern = thePatterns[i2];
          var match = str.match(thisPattern.match);
          if (match) {
            var theTitleNumber = getTitleNumber(str);
            if (theTitleNumber) {
              str = str.replace(theTitleNumber + ".", "");
              str = str.trim();
            }
            var len = match[0].length;
            var result = thisPattern.replace + str.substring(0, str.length - len);
            if (theTitleNumber) {
              result = theTitleNumber + ". " + result;
            }
            return result;
          }
        }
        return str;
      };
      this.stripComment = function(str) {
        var i2 = str.indexOf("%");
        if (i2 >= 0)
          return parseCommon.strip(str.substring(0, i2));
        return parseCommon.strip(str);
      };
      this.getInt = function(str) {
        var x = parseInt(str);
        if (isNaN(x))
          return { digits: 0 };
        var s2 = "" + x;
        var i2 = str.indexOf(s2);
        return { value: x, digits: i2 + s2.length };
      };
      this.getFloat = function(str) {
        var x = parseFloat(str);
        if (isNaN(x))
          return { digits: 0 };
        var s2 = "" + x;
        var i2 = str.indexOf(s2);
        return { value: x, digits: i2 + s2.length };
      };
      this.getMeasurement = function(tokens) {
        if (tokens.length === 0) return { used: 0 };
        var used = 1;
        var num = "";
        if (tokens[0].token === "-") {
          tokens.shift();
          num = "-";
          used++;
        } else if (tokens[0].type !== "number") return { used: 0 };
        num += tokens.shift().token;
        if (tokens.length === 0) return { used: 1, value: parseInt(num) };
        var x = tokens.shift();
        if (x.token === ".") {
          used++;
          if (tokens.length === 0) return { used, value: parseInt(num) };
          if (tokens[0].type === "number") {
            x = tokens.shift();
            num = num + "." + x.token;
            used++;
            if (tokens.length === 0) return { used, value: parseFloat(num) };
          }
          x = tokens.shift();
        }
        switch (x.token) {
          case "pt":
            return { used: used + 1, value: parseFloat(num) };
          case "px":
            return { used: used + 1, value: parseFloat(num) };
          case "cm":
            return { used: used + 1, value: parseFloat(num) / 2.54 * 72 };
          case "in":
            return { used: used + 1, value: parseFloat(num) * 72 };
          default:
            tokens.unshift(x);
            return { used, value: parseFloat(num) };
        }
      };
      var substInChord = function(str) {
        str = str.replace(/\\n/g, "\n");
        str = str.replace(/\\"/g, '"');
        return str;
      };
      this.getBrackettedSubstring = function(line, i2, maxErrorChars, _matchChar) {
        var matchChar = _matchChar || line[i2];
        var pos = i2 + 1;
        var esc = false;
        while (pos < line.length && (esc || line[pos] !== matchChar)) {
          esc = line[pos] === "\\";
          ++pos;
        }
        if (line[pos] === matchChar)
          return [pos - i2 + 1, substInChord(line.substring(i2 + 1, pos)), true];
        else {
          pos = i2 + maxErrorChars;
          if (pos > line.length - 1)
            pos = line.length - 1;
          return [pos - i2 + 1, substInChord(line.substring(i2 + 1, pos)), false];
        }
      };
    };
    Tokenizer.prototype.peekLine = function() {
      return this.lines[this.lineIndex];
    };
    Tokenizer.prototype.nextLine = function() {
      if (this.lineIndex > 0) {
        this.multilineVars.iChar += this.lines[this.lineIndex - 1].length + 1;
      }
      if (this.lineIndex < this.lines.length) {
        var result = this.lines[this.lineIndex];
        this.lineIndex++;
        return result;
      }
      return null;
    };
    module.exports = Tokenizer;
  }
});

// node_modules/abcjs/src/parse/wrap_lines.js
var require_wrap_lines = __commonJS({
  "node_modules/abcjs/src/parse/wrap_lines.js"(exports, module) {
    function wrapLines(tune, lineBreaks, barNumbers) {
      if (!lineBreaks || tune.lines.length === 0)
        return;
      var lines = tune.deline({ lineBreaks: false });
      var linesBreakElements = findLineBreaks(lines, lineBreaks);
      tune.lines = addLineBreaks(lines, linesBreakElements, barNumbers);
      tune.lineBreaks = linesBreakElements;
    }
    function addLineBreaks(lines, linesBreakElements, barNumbers) {
      var outputLines = [];
      var lastKeySig = [];
      var lastStem = [];
      var currentBarNumber = 1;
      for (var i2 = 0; i2 < linesBreakElements.length; i2++) {
        var action = linesBreakElements[i2];
        if (lines[action.ogLine].staff) {
          var inputStaff = lines[action.ogLine].staff[action.staff];
          if (!outputLines[action.line]) {
            outputLines[action.line] = { staff: [] };
          }
          if (!outputLines[action.line].staff[action.staff]) {
            outputLines[action.line].staff[action.staff] = { voices: [] };
            if (barNumbers !== void 0 && action.staff === 0 && action.line > 0) {
              outputLines[action.line].staff[action.staff].barNumber = currentBarNumber;
            }
            var keys = Object.keys(inputStaff);
            for (var k = 0; k < keys.length; k++) {
              var skip = keys[k] === "voices";
              if (keys[k] === "meter" && action.line !== 0)
                skip = true;
              if (!skip)
                outputLines[action.line].staff[action.staff][keys[k]] = inputStaff[keys[k]];
            }
            if (lastKeySig[action.staff])
              outputLines[action.line].staff[action.staff].key = lastKeySig[action.staff];
          }
          if (!outputLines[action.line].staff[action.staff].voices[action.voice]) {
            outputLines[action.line].staff[action.staff].voices[action.voice] = [];
          }
          outputLines[action.line].staff[action.staff].voices[action.voice] = lines[action.ogLine].staff[action.staff].voices[action.voice].slice(action.start, action.end + 1);
          if (lastStem[action.staff * 10 + action.voice])
            outputLines[action.line].staff[action.staff].voices[action.voice].unshift({ el_type: "stem", direction: lastStem[action.staff * 10 + action.voice].direction });
          var currVoice = outputLines[action.line].staff[action.staff].voices[action.voice];
          for (var kk = currVoice.length - 1; kk >= 0; kk--) {
            if (currVoice[kk].el_type === "key") {
              lastKeySig[action.staff] = {
                root: currVoice[kk].root,
                acc: currVoice[kk].acc,
                mode: currVoice[kk].mode,
                accidentals: currVoice[kk].accidentals.filter(function(acc) {
                  return acc.acc !== "natural";
                })
              };
              break;
            }
          }
          for (kk = currVoice.length - 1; kk >= 0; kk--) {
            if (currVoice[kk].el_type === "stem") {
              lastStem[action.staff * 10 + action.voice] = {
                direction: currVoice[kk].direction
              };
              break;
            }
          }
          if (barNumbers !== void 0 && action.staff === 0 && action.voice === 0) {
            for (kk = 0; kk < currVoice.length; kk++) {
              if (currVoice[kk].el_type === "bar") {
                currentBarNumber++;
                if (kk === currVoice.length - 1)
                  delete currVoice[kk].barNumber;
                else
                  currVoice[kk].barNumber = currentBarNumber;
              }
            }
          }
        } else {
          outputLines[action.line] = lines[action.ogLine];
        }
      }
      for (var ii = 0; ii < outputLines.length; ii++) {
        if (outputLines[ii].staff) {
          outputLines[ii].staff = outputLines[ii].staff.filter(function(el) {
            return el != null;
          });
        }
      }
      return outputLines;
    }
    function findLineBreaks(lines, lineBreakArray) {
      var lineBreakIndexes = [];
      var lbai = 0;
      var lineCounter = 0;
      var outputLine = 0;
      for (var i2 = 0; i2 < lines.length; i2++) {
        var line = lines[i2];
        if (line.staff) {
          var lineStart = lineCounter;
          var lineBreaks = lineBreakArray[lbai];
          lbai++;
          for (var j = 0; j < line.staff.length; j++) {
            var staff = line.staff[j];
            for (var k = 0; k < staff.voices.length; k++) {
              outputLine = lineStart;
              var measureNumber = 0;
              var lbi = 0;
              var voice = staff.voices[k];
              var start = 0;
              for (var e = 0; e < voice.length; e++) {
                var el = voice[e];
                if (el.el_type === "bar") {
                  if (lineBreaks[lbi] === measureNumber) {
                    lineBreakIndexes.push({ ogLine: i2, line: outputLine, staff: j, voice: k, start, end: e });
                    start = e + 1;
                    outputLine++;
                    lineCounter = Math.max(lineCounter, outputLine);
                    lbi++;
                  }
                  measureNumber++;
                }
              }
              lineBreakIndexes.push({ ogLine: i2, line: outputLine, staff: j, voice: k, start, end: voice.length });
              outputLine++;
              lineCounter = Math.max(lineCounter, outputLine);
            }
          }
        } else {
          lineBreakIndexes.push({ ogLine: i2, line: outputLine });
          outputLine++;
          lineCounter = Math.max(lineCounter, outputLine);
        }
      }
      return lineBreakIndexes;
    }
    function freeFormLineBreaks(widths, lineBreakPoint) {
      var lineBreaks = [];
      var totals = [];
      var totalThisLine = 0;
      for (var i2 = 0; i2 < widths.length; i2++) {
        var width = widths[i2];
        var attemptedWidth = totalThisLine + width;
        if (attemptedWidth < lineBreakPoint)
          totalThisLine = attemptedWidth;
        else {
          var oldDistance = lineBreakPoint - totalThisLine;
          var newDistance = attemptedWidth - lineBreakPoint;
          if (oldDistance < newDistance && totalThisLine > 0) {
            lineBreaks.push(i2 - 1);
            totals.push(Math.round(totalThisLine - width));
            totalThisLine = width;
          } else {
            if (i2 < widths.length - 1) {
              lineBreaks.push(i2);
              totals.push(Math.round(totalThisLine));
              totalThisLine = 0;
            }
          }
        }
      }
      totals.push(Math.round(totalThisLine));
      return { lineBreaks, totals };
    }
    function clone(arr) {
      var newArr = [];
      for (var i2 = 0; i2 < arr.length; i2++)
        newArr.push(arr[i2]);
      return newArr;
    }
    function oneTry(measureWidths, idealWidths, accumulator, lineAccumulator, lineWidths, lastVariance, highestVariance, currLine, lineBreaks, startIndex, otherTries) {
      for (var i2 = startIndex; i2 < measureWidths.length; i2++) {
        var measureWidth = measureWidths[i2];
        accumulator += measureWidth;
        lineAccumulator += measureWidth;
        var thisVariance = Math.abs(accumulator - idealWidths[currLine]);
        var varianceIsClose = Math.abs(thisVariance - lastVariance) < idealWidths[0] / 10;
        if (varianceIsClose) {
          if (thisVariance < lastVariance) {
            var newWidths = clone(lineWidths);
            var newBreaks = clone(lineBreaks);
            newBreaks.push(i2 - 1);
            newWidths.push(lineAccumulator - measureWidth);
            otherTries.push({
              accumulator,
              lineAccumulator: measureWidth,
              lineWidths: newWidths,
              lastVariance: Math.abs(accumulator - idealWidths[currLine + 1]),
              highestVariance: Math.max(highestVariance, lastVariance),
              currLine: currLine + 1,
              lineBreaks: newBreaks,
              startIndex: i2 + 1
            });
          } else if (thisVariance > lastVariance && i2 < measureWidths.length - 1) {
            newWidths = clone(lineWidths);
            newBreaks = clone(lineBreaks);
            otherTries.push({
              accumulator,
              lineAccumulator,
              lineWidths: newWidths,
              lastVariance: thisVariance,
              highestVariance: Math.max(highestVariance, thisVariance),
              currLine,
              lineBreaks: newBreaks,
              startIndex: i2 + 1
            });
          }
        }
        if (thisVariance > lastVariance) {
          lineBreaks.push(i2 - 1);
          currLine++;
          highestVariance = Math.max(highestVariance, lastVariance);
          lastVariance = Math.abs(accumulator - idealWidths[currLine]);
          lineWidths.push(lineAccumulator - measureWidth);
          lineAccumulator = measureWidth;
        } else {
          lastVariance = thisVariance;
        }
      }
      lineWidths.push(lineAccumulator);
    }
    function optimizeLineWidths(widths, lineBreakPoint, lineBreaks, explanation) {
      var numLines = Math.ceil(widths.total / lineBreakPoint);
      var idealWidth = Math.floor(widths.total / numLines);
      var idealWidths = [];
      for (var i2 = 0; i2 < numLines; i2++)
        idealWidths.push(idealWidth * (i2 + 1));
      var otherTries = [];
      otherTries.push({
        accumulator: 0,
        lineAccumulator: 0,
        lineWidths: [],
        lastVariance: 999999,
        highestVariance: 0,
        currLine: 0,
        lineBreaks: [],
        // These are the zero-based last measure on each line
        startIndex: 0
      });
      var index = 0;
      while (index < otherTries.length) {
        oneTry(
          widths.measureWidths,
          idealWidths,
          otherTries[index].accumulator,
          otherTries[index].lineAccumulator,
          otherTries[index].lineWidths,
          otherTries[index].lastVariance,
          otherTries[index].highestVariance,
          otherTries[index].currLine,
          otherTries[index].lineBreaks,
          otherTries[index].startIndex,
          otherTries
        );
        index++;
      }
      for (i2 = 0; i2 < otherTries.length; i2++) {
        var otherTry = otherTries[i2];
        otherTry.variances = [];
        otherTry.aveVariance = 0;
        for (var j = 0; j < otherTry.lineWidths.length; j++) {
          var lineWidth = otherTry.lineWidths[j];
          otherTry.variances.push(lineWidth - idealWidths[0]);
          otherTry.aveVariance += Math.abs(lineWidth - idealWidths[0]);
        }
        otherTry.aveVariance = otherTry.aveVariance / otherTry.lineWidths.length;
        explanation.attempts.push({ type: "optimizeLineWidths", lineBreaks: otherTry.lineBreaks, variances: otherTry.variances, aveVariance: otherTry.aveVariance, widths: widths.measureWidths });
      }
      var smallest = 9999999;
      var smallestIndex = -1;
      for (i2 = 0; i2 < otherTries.length; i2++) {
        otherTry = otherTries[i2];
        if (otherTry.aveVariance < smallest) {
          smallest = otherTry.aveVariance;
          smallestIndex = i2;
        }
      }
      return { failed: false, lineBreaks: otherTries[smallestIndex].lineBreaks, variance: otherTries[smallestIndex].highestVariance };
    }
    function fixedMeasureLineBreaks(widths, lineBreakPoint, preferredMeasuresPerLine) {
      var lineBreaks = [];
      var totals = [];
      var thisWidth = 0;
      var failed = false;
      for (var i2 = 0; i2 < widths.length; i2++) {
        thisWidth += widths[i2];
        if (thisWidth > lineBreakPoint) {
          failed = true;
        }
        if (i2 % preferredMeasuresPerLine === preferredMeasuresPerLine - 1) {
          if (i2 !== widths.length - 1)
            lineBreaks.push(i2);
          totals.push(Math.round(thisWidth));
          thisWidth = 0;
        }
      }
      return { failed, totals, lineBreaks };
    }
    function getRevisedTuneParams(lineBreaks, staffWidth, params) {
      var revisedParams = {
        lineBreaks,
        staffwidth: staffWidth
      };
      for (var key in params) {
        if (params.hasOwnProperty(key) && key !== "wrap" && key !== "staffwidth") {
          revisedParams[key] = params[key];
        }
      }
      return { revisedParams };
    }
    function calcLineWraps(tune, widths, params) {
      if (widths.length === 0 || params.staffwidth < widths[0].left) {
        return {
          reParse: false,
          explanation: "Staff width is narrower than the margin",
          revisedParams: params
        };
      }
      var scale = params.scale ? Math.max(params.scale, 0.1) : 1;
      var minSpacing = params.wrap.minSpacing ? Math.max(parseFloat(params.wrap.minSpacing), 1) : 1;
      var minSpacingLimit = params.wrap.minSpacingLimit ? Math.max(parseFloat(params.wrap.minSpacingLimit), 1) : minSpacing - 0.1;
      var maxSpacing = params.wrap.maxSpacing ? Math.max(parseFloat(params.wrap.maxSpacing), 1) : void 0;
      if (params.wrap.lastLineLimit && !maxSpacing)
        maxSpacing = Math.max(parseFloat(params.wrap.lastLineLimit), 1);
      var preferredMeasuresPerLine = params.wrap.preferredMeasuresPerLine ? Math.max(parseInt(params.wrap.preferredMeasuresPerLine, 10), 0) : void 0;
      var accumulatedLineBreaks = [];
      var explanations = [];
      for (var s2 = 0; s2 < widths.length; s2++) {
        var section = widths[s2];
        var usableWidth = params.staffwidth - section.left;
        var lineBreakPoint = usableWidth / minSpacing / scale;
        var minLineSize = usableWidth / maxSpacing / scale;
        var allowableVariance = usableWidth / minSpacingLimit / scale;
        var explanation = {
          widths: section,
          lineBreakPoint,
          minLineSize,
          attempts: [],
          staffWidth: params.staffwidth,
          minWidth: Math.round(allowableVariance)
        };
        var lineBreaks = null;
        if (preferredMeasuresPerLine) {
          var f = fixedMeasureLineBreaks(section.measureWidths, lineBreakPoint, preferredMeasuresPerLine);
          explanation.attempts.push({
            type: "Fixed Measures Per Line",
            preferredMeasuresPerLine,
            lineBreaks: f.lineBreaks,
            failed: f.failed,
            totals: f.totals
          });
          if (!f.failed)
            lineBreaks = f.lineBreaks;
        }
        if (!lineBreaks) {
          var ff = freeFormLineBreaks(section.measureWidths, lineBreakPoint);
          explanation.attempts.push({ type: "Free Form", lineBreaks: ff.lineBreaks, totals: ff.totals });
          lineBreaks = ff.lineBreaks;
          if (lineBreaks.length > 0 && section.measureWidths.length < 25) {
            ff = optimizeLineWidths(section, lineBreakPoint, lineBreaks, explanation);
            explanation.attempts.push({
              type: "Optimize",
              failed: ff.failed,
              reason: ff.reason,
              lineBreaks: ff.lineBreaks,
              totals: ff.totals
            });
            if (!ff.failed)
              lineBreaks = ff.lineBreaks;
          }
        }
        accumulatedLineBreaks.push(lineBreaks);
        explanations.push(explanation);
      }
      var staffWidth = params.staffwidth;
      var ret = getRevisedTuneParams(accumulatedLineBreaks, staffWidth, params);
      ret.explanation = explanations;
      ret.reParse = true;
      return ret;
    }
    module.exports = { wrapLines, calcLineWraps };
  }
});

// node_modules/abcjs/src/write/helpers/spacing.js
var require_spacing = __commonJS({
  "node_modules/abcjs/src/write/helpers/spacing.js"(exports, module) {
    var spacing = {};
    spacing.FONTEM = 360;
    spacing.FONTSIZE = 30;
    spacing.STEP = spacing.FONTSIZE * 93 / 720;
    spacing.SPACE = 10;
    spacing.TOPNOTE = 15;
    spacing.STAVEHEIGHT = 100;
    spacing.INDENT = 50;
    module.exports = spacing;
  }
});

// node_modules/abcjs/src/synth/abc_midi_sequencer.js
var require_abc_midi_sequencer = __commonJS({
  "node_modules/abcjs/src/synth/abc_midi_sequencer.js"(exports, module) {
    var sequence;
    var parseCommon = require_abc_common();
    (function() {
      "use strict";
      var measureLength = 1;
      var PERCUSSION_PROGRAM = 128;
      sequence = function(abctune, options) {
        options = options || {};
        var qpm;
        var program = options.program || 0;
        var transpose = options.midiTranspose || 0;
        if (abctune.visualTranspose)
          transpose -= abctune.visualTranspose;
        var channel = options.channel || 0;
        var channelExplicitlySet = false;
        var drumPattern = options.drum || "";
        var drumBars = options.drumBars || 1;
        var drumIntro = options.drumIntro || 0;
        var drumOn = drumPattern !== "";
        var drumOffAfterIntro = !!options.drumOff;
        var style = [];
        var rhythmHeadThisBar = false;
        var crescendoSize = 50;
        program = parseInt(program, 10);
        transpose = parseInt(transpose, 10);
        channel = parseInt(channel, 10);
        if (channel === 10)
          program = PERCUSSION_PROGRAM;
        drumPattern = drumPattern.split(" ");
        drumBars = parseInt(drumBars, 10);
        drumIntro = parseInt(drumIntro, 10);
        var bagpipes = abctune.formatting.bagpipes;
        if (bagpipes)
          program = 71;
        var startingMidi = [];
        if (abctune.formatting.midi) {
          var globals = abctune.formatting.midi;
          if (globals.program && globals.program.length > 0) {
            program = globals.program[0];
            if (globals.program.length > 1) {
              program = globals.program[1];
              channel = globals.program[0];
            }
            channelExplicitlySet = true;
          }
          if (globals.transpose)
            transpose = globals.transpose[0];
          if (globals.channel) {
            channel = globals.channel[0];
            channelExplicitlySet = true;
          }
          if (globals.drum)
            drumPattern = globals.drum;
          if (globals.drumbars)
            drumBars = globals.drumbars[0];
          if (globals.drumon)
            drumOn = true;
          if (channel === 10)
            program = PERCUSSION_PROGRAM;
          if (globals.beat)
            startingMidi.push({ el_type: "beat", beats: globals.beat });
          if (globals.nobeataccents)
            startingMidi.push({ el_type: "beataccents", value: false });
        }
        if (options.qpm)
          qpm = parseInt(options.qpm, 10);
        else if (abctune.metaText.tempo)
          qpm = interpretTempo(abctune.metaText.tempo, abctune.getBeatLength());
        else if (options.defaultQpm)
          qpm = options.defaultQpm;
        else
          qpm = 180;
        var startVoice = [];
        if (bagpipes)
          startVoice.push({ el_type: "bagpipes" });
        startVoice.push({ el_type: "instrument", program });
        if (channel)
          startVoice.push({ el_type: "channel", channel });
        if (transpose)
          startVoice.push({ el_type: "transpose", transpose });
        startVoice.push({ el_type: "tempo", qpm });
        for (var ss = 0; ss < startingMidi.length; ss++)
          startVoice.push(startingMidi[ss]);
        var voices = [];
        var inCrescendo = [];
        var inDiminuendo = [];
        var durationCounter = [0];
        var tempoChanges = {};
        tempoChanges["0"] = { el_type: "tempo", qpm, timing: 0 };
        var currentVolume;
        var startRepeatPlaceholder = [];
        var skipEndingPlaceholder = [];
        var startingDrumSet = false;
        var lines = abctune.lines;
        for (var i2 = 0; i2 < lines.length; i2++) {
          var line = lines[i2];
          if (line.staff) {
            let setDynamics = function(elem2) {
              var volumes = {
                "pppp": [15, 10, 5, 1],
                "ppp": [30, 20, 10, 1],
                "pp": [45, 35, 20, 1],
                "p": [60, 50, 35, 1],
                "mp": [75, 65, 50, 1],
                "mf": [90, 80, 65, 1],
                "f": [105, 95, 80, 1],
                "ff": [120, 110, 95, 1],
                "fff": [127, 125, 110, 1],
                "ffff": [127, 125, 110, 1]
              };
              var dynamicType;
              if (elem2.decoration) {
                if (elem2.decoration.indexOf("pppp") >= 0)
                  dynamicType = "pppp";
                else if (elem2.decoration.indexOf("ppp") >= 0)
                  dynamicType = "ppp";
                else if (elem2.decoration.indexOf("pp") >= 0)
                  dynamicType = "pp";
                else if (elem2.decoration.indexOf("p") >= 0)
                  dynamicType = "p";
                else if (elem2.decoration.indexOf("mp") >= 0)
                  dynamicType = "mp";
                else if (elem2.decoration.indexOf("mf") >= 0)
                  dynamicType = "mf";
                else if (elem2.decoration.indexOf("f") >= 0)
                  dynamicType = "f";
                else if (elem2.decoration.indexOf("ff") >= 0)
                  dynamicType = "ff";
                else if (elem2.decoration.indexOf("fff") >= 0)
                  dynamicType = "fff";
                else if (elem2.decoration.indexOf("ffff") >= 0)
                  dynamicType = "ffff";
                if (dynamicType) {
                  currentVolume = volumes[dynamicType].slice(0);
                  voices[voiceNumber].push({ el_type: "beat", beats: currentVolume.slice(0) });
                  inCrescendo[k] = false;
                  inDiminuendo[k] = false;
                }
                if (elem2.decoration.indexOf("crescendo(") >= 0) {
                  var n = numNotesToDecoration(voice, v2, "crescendo)");
                  var top = Math.min(127, currentVolume[0] + crescendoSize);
                  var endDec = endingVolume(voice, v2 + n + 1, Object.keys(volumes));
                  if (endDec)
                    top = volumes[endDec][0];
                  if (n > 0)
                    inCrescendo[k] = Math.floor((top - currentVolume[0]) / n);
                  else
                    inCrescendo[k] = false;
                  inDiminuendo[k] = false;
                } else if (elem2.decoration.indexOf("crescendo)") >= 0) {
                  inCrescendo[k] = false;
                } else if (elem2.decoration.indexOf("diminuendo(") >= 0) {
                  var n2 = numNotesToDecoration(voice, v2, "diminuendo)");
                  var bottom = Math.max(15, currentVolume[0] - crescendoSize);
                  var endDec2 = endingVolume(voice, v2 + n2 + 1, Object.keys(volumes));
                  if (endDec2)
                    bottom = volumes[endDec2][0];
                  inCrescendo[k] = false;
                  if (n2 > 0)
                    inDiminuendo[k] = Math.floor((bottom - currentVolume[0]) / n2);
                  else
                    inDiminuendo[k] = false;
                } else if (elem2.decoration.indexOf("diminuendo)") >= 0) {
                  inDiminuendo[k] = false;
                }
              }
            };
            var staves = line.staff;
            var voiceNumber = 0;
            for (var j = 0; j < staves.length; j++) {
              var staff = staves[j];
              if (staff.clef && staff.clef.type === "TAB")
                continue;
              for (var k = 0; k < staff.voices.length; k++) {
                var voice = staff.voices[k];
                if (!voices[voiceNumber]) {
                  voices[voiceNumber] = [].concat(JSON.parse(JSON.stringify(startVoice)));
                  var voiceName = getTrackTitle(line.staff, voiceNumber);
                  if (voiceName)
                    voices[voiceNumber].unshift({ el_type: "name", trackName: voiceName });
                }
                if (transpose && staff.clef.type === "perc")
                  voices[voiceNumber].push({ el_type: "transpose", transpose: 0 });
                if (staff.clef && staff.clef.type === "perc" && !channelExplicitlySet) {
                  for (var cl = 0; cl < voices[voiceNumber].length; cl++) {
                    if (voices[voiceNumber][cl].el_type === "instrument")
                      voices[voiceNumber][cl].program = PERCUSSION_PROGRAM;
                  }
                } else if (staff.key) {
                  addKey(voices[voiceNumber], staff.key);
                }
                if (staff.meter) {
                  addMeter(voices[voiceNumber], staff.meter);
                }
                if (!startingDrumSet && drumOn) {
                  voices[voiceNumber].push({ el_type: "drum", params: { pattern: drumPattern, bars: drumBars, on: drumOn, intro: drumIntro } });
                  startingDrumSet = true;
                }
                if (staff.clef && staff.clef.type !== "perc" && staff.clef.transpose) {
                  staff.clef.el_type = "clef";
                  voices[voiceNumber].push({ el_type: "transpose", transpose: staff.clef.transpose });
                }
                if (staff.clef && staff.clef.type) {
                  if (staff.clef.type.indexOf("-8") >= 0)
                    voices[voiceNumber].push({ el_type: "transpose", transpose: -12 });
                  else if (staff.clef.type.indexOf("+8") >= 0)
                    voices[voiceNumber].push({ el_type: "transpose", transpose: 12 });
                }
                if (abctune.formatting.midi && abctune.formatting.midi.drumoff) {
                  voices[voiceNumber].push({ el_type: "bar" });
                  voices[voiceNumber].push({ el_type: "drum", params: { pattern: "", on: false } });
                }
                var noteEventsInBar = 0;
                var tripletMultiplier = 0;
                var tripletDurationTotal = 0;
                var tripletDurationCount = 0;
                currentVolume = [105, 95, 85, 1];
                for (var v2 = 0; v2 < voice.length; v2++) {
                  var elem = voice[v2];
                  switch (elem.el_type) {
                    case "note":
                      if (inCrescendo[k]) {
                        currentVolume[0] += inCrescendo[k];
                        currentVolume[1] += inCrescendo[k];
                        currentVolume[2] += inCrescendo[k];
                        voices[voiceNumber].push({ el_type: "beat", beats: currentVolume.slice(0) });
                      }
                      if (inDiminuendo[k]) {
                        currentVolume[0] += inDiminuendo[k];
                        currentVolume[1] += inDiminuendo[k];
                        currentVolume[2] += inDiminuendo[k];
                        voices[voiceNumber].push({ el_type: "beat", beats: currentVolume.slice(0) });
                      }
                      setDynamics(elem);
                      if (!elem.rest || elem.rest.type !== "spacer") {
                        var noteElem = { elem, el_type: "note", timing: durationCounter[voiceNumber] };
                        if (elem.style)
                          noteElem.style = elem.style;
                        else if (style[voiceNumber])
                          noteElem.style = style[voiceNumber];
                        noteElem.duration = elem.duration === 0 ? 0.25 : elem.duration;
                        if (elem.startTriplet) {
                          tripletMultiplier = elem.tripletMultiplier;
                          tripletDurationTotal = elem.startTriplet * tripletMultiplier * elem.duration;
                          if (elem.startTriplet !== elem.tripletR) {
                            if (v2 + elem.tripletR <= voice.length) {
                              var durationTotal = 0;
                              for (var w = v2; w < v2 + elem.tripletR; w++) {
                                durationTotal += voice[w].duration;
                              }
                              tripletDurationTotal = tripletMultiplier * durationTotal;
                            }
                          }
                          noteElem.duration = noteElem.duration * tripletMultiplier;
                          noteElem.duration = Math.round(noteElem.duration * 1e6) / 1e6;
                          tripletDurationCount = noteElem.duration;
                        } else if (tripletMultiplier) {
                          if (elem.endTriplet) {
                            tripletMultiplier = 0;
                            noteElem.duration = Math.round((tripletDurationTotal - tripletDurationCount) * 1e6) / 1e6;
                          } else {
                            noteElem.duration = noteElem.duration * tripletMultiplier;
                            noteElem.duration = Math.round(noteElem.duration * 1e6) / 1e6;
                            tripletDurationCount += noteElem.duration;
                          }
                        }
                        if (elem.rest) noteElem.rest = elem.rest;
                        if (elem.decoration) noteElem.decoration = elem.decoration.slice(0);
                        if (elem.pitches) noteElem.pitches = parseCommon.cloneArray(elem.pitches);
                        if (elem.gracenotes) noteElem.gracenotes = parseCommon.cloneArray(elem.gracenotes);
                        if (elem.chord) noteElem.chord = parseCommon.cloneArray(elem.chord);
                        voices[voiceNumber].push(noteElem);
                        if (elem.style === "rhythm") {
                          rhythmHeadThisBar = true;
                          chordVoiceOffThisBar(voices);
                        }
                        noteEventsInBar++;
                        durationCounter[voiceNumber] += noteElem.duration;
                      }
                      break;
                    case "key":
                    case "keySignature":
                      addKey(voices[voiceNumber], elem);
                      break;
                    case "meter":
                      addMeter(voices[voiceNumber], elem);
                      break;
                    case "clef":
                      if (elem.transpose)
                        voices[voiceNumber].push({ el_type: "transpose", transpose: elem.transpose });
                      if (elem.type) {
                        if (elem.type.indexOf("-8") >= 0)
                          voices[voiceNumber].push({ el_type: "transpose", transpose: -12 });
                        else if (elem.type.indexOf("+8") >= 0)
                          voices[voiceNumber].push({ el_type: "transpose", transpose: 12 });
                      }
                      break;
                    case "tempo":
                      qpm = interpretTempo(elem, abctune.getBeatLength());
                      voices[voiceNumber].push({ el_type: "tempo", qpm, timing: durationCounter[voiceNumber] });
                      tempoChanges["" + durationCounter[voiceNumber]] = { el_type: "tempo", qpm, timing: durationCounter[voiceNumber] };
                      break;
                    case "bar":
                      if (noteEventsInBar > 0)
                        voices[voiceNumber].push({ el_type: "bar" });
                      setDynamics(elem);
                      noteEventsInBar = 0;
                      var endRepeat = elem.type === "bar_right_repeat" || elem.type === "bar_dbl_repeat";
                      var startEnding = elem.startEnding === "1";
                      var startRepeat = elem.type === "bar_left_repeat" || elem.type === "bar_dbl_repeat" || elem.type === "bar_right_repeat";
                      if (endRepeat) {
                        var s2 = startRepeatPlaceholder[voiceNumber];
                        if (!s2) s2 = 0;
                        var e = skipEndingPlaceholder[voiceNumber];
                        if (!e) e = voices[voiceNumber].length;
                        for (var z = s2; z < e; z++) {
                          var item = Object.assign({}, voices[voiceNumber][z]);
                          if (item.pitches)
                            item.pitches = parseCommon.cloneArray(item.pitches);
                          voices[voiceNumber].push(item);
                        }
                        skipEndingPlaceholder[voiceNumber] = void 0;
                        startRepeatPlaceholder[voiceNumber] = void 0;
                      }
                      if (startEnding)
                        skipEndingPlaceholder[voiceNumber] = voices[voiceNumber].length;
                      if (startRepeat)
                        startRepeatPlaceholder[voiceNumber] = voices[voiceNumber].length;
                      rhythmHeadThisBar = false;
                      break;
                    case "style":
                      style[voiceNumber] = elem.head;
                      break;
                    case "timeSignature":
                      voices[voiceNumber].push(interpretMeter(elem));
                      break;
                    case "part":
                      break;
                    case "stem":
                    case "scale":
                    case "break":
                    case "font":
                      break;
                    case "midi":
                      var drumChange = false;
                      switch (elem.cmd) {
                        case "drumon":
                          drumOn = true;
                          drumChange = true;
                          break;
                        case "drumoff":
                          drumOn = false;
                          drumChange = true;
                          break;
                        case "drum":
                          drumPattern = elem.params;
                          drumChange = true;
                          break;
                        case "drumbars":
                          drumBars = elem.params[0];
                          drumChange = true;
                          break;
                        case "drummap":
                          break;
                        case "channel":
                          if (elem.params[0] === 10)
                            voices[voiceNumber].push({ el_type: "instrument", program: PERCUSSION_PROGRAM });
                          break;
                        case "program":
                          addIfDifferent(voices[voiceNumber], { el_type: "instrument", program: elem.params[0] });
                          channelExplicitlySet = true;
                          break;
                        case "transpose":
                          voices[voiceNumber].push({ el_type: "transpose", transpose: elem.params[0] });
                          break;
                        case "gchordoff":
                          voices[voiceNumber].push({ el_type: "gchordOn", tacet: true });
                          break;
                        case "gchordon":
                          voices[voiceNumber].push({ el_type: "gchordOn", tacet: false });
                          break;
                        case "beat":
                          voices[voiceNumber].push({ el_type: "beat", beats: elem.params });
                          break;
                        case "nobeataccents":
                          voices[voiceNumber].push({ el_type: "beataccents", value: false });
                          break;
                        case "beataccents":
                          voices[voiceNumber].push({ el_type: "beataccents", value: true });
                          break;
                        case "vol":
                        case "volinc":
                          voices[voiceNumber].push({ el_type: elem.cmd, volume: elem.params[0] });
                          break;
                        case "swing":
                        case "gchord":
                        case "bassvol":
                        case "chordvol":
                          voices[voiceNumber].push({ el_type: elem.cmd, param: elem.params[0] });
                          break;
                        case "bassprog":
                        // MAE 22 May 2024
                        case "chordprog":
                          voices[voiceNumber].push({
                            el_type: elem.cmd,
                            value: elem.params[0],
                            octaveShift: elem.params[1]
                          });
                          break;
                        // MAE 23 Jun 2024
                        case "gchordbars":
                          voices[voiceNumber].push({
                            el_type: elem.cmd,
                            param: elem.params[0]
                          });
                          break;
                        default:
                          console.log("MIDI seq: midi cmd not handled: ", elem.cmd, elem);
                      }
                      if (drumChange) {
                        voices[0].push({ el_type: "drum", params: { pattern: drumPattern, bars: drumBars, intro: drumIntro, on: drumOn } });
                        startingDrumSet = true;
                      }
                      break;
                    default:
                      console.log("MIDI: element type " + elem.el_type + " not handled.");
                  }
                }
                voiceNumber++;
                if (!durationCounter[voiceNumber])
                  durationCounter[voiceNumber] = 0;
              }
            }
          }
        }
        insertTempoChanges(voices, tempoChanges);
        if (drumIntro) {
          var pickups = abctune.getPickupLength();
          for (var vv = 0; vv < voices.length; vv++) {
            var insertPoint = 0;
            while (voices[vv][insertPoint].el_type !== "note" && voices[vv].length > insertPoint)
              insertPoint++;
            if (voices[vv].length > insertPoint) {
              for (var w = 0; w < drumIntro; w++) {
                if (pickups === 0 || w < drumIntro - 1) {
                  voices[vv].splice(
                    insertPoint,
                    0,
                    { el_type: "note", rest: { type: "rest" }, duration: measureLength },
                    { el_type: "bar" }
                  );
                  insertPoint += 2;
                } else {
                  voices[vv].splice(insertPoint++, 0, { el_type: "note", rest: { type: "rest" }, duration: measureLength - pickups });
                }
              }
              if (drumOffAfterIntro) {
                drumOn = false;
                voices[vv].splice(insertPoint++, 0, { el_type: "drum", params: { pattern: drumPattern, bars: drumBars, intro: drumIntro, on: drumOn } });
                drumOffAfterIntro = false;
              }
            }
          }
        }
        if (voices.length > 0 && voices[0].length > 0) {
          voices[0][0].pickupLength = abctune.getPickupLength();
        }
        return voices;
      };
      function numNotesToDecoration(voice, start, decoration) {
        var counter = 0;
        for (var i2 = start + 1; i2 < voice.length; i2++) {
          if (voice[i2].el_type === "note")
            counter++;
          if (voice[i2].decoration && voice[i2].decoration.indexOf(decoration) >= 0)
            return counter;
        }
        return counter;
      }
      function endingVolume(voice, start, volumeDecorations) {
        var end = Math.min(voice.length, start + 3);
        for (var i2 = start; i2 < end; i2++) {
          if (voice[i2].el_type === "note") {
            if (voice[i2].decoration) {
              for (var j = 0; j < voice[i2].decoration.length; j++) {
                if (volumeDecorations.indexOf(voice[i2].decoration[j]) >= 0)
                  return voice[i2].decoration[j];
              }
            }
          }
        }
        return null;
      }
      function insertTempoChanges(voices, tempoChanges) {
        if (!tempoChanges || tempoChanges.length === 0)
          return;
        var changePositions = Object.keys(tempoChanges);
        for (var i2 = 0; i2 < voices.length; i2++) {
          var voice = voices[i2];
          var lastTempo = tempoChanges["0"] ? tempoChanges["0"].qpm : 0;
          for (var j = 0; j < voice.length; j++) {
            var el = voice[j];
            if (el.el_type === "tempo")
              lastTempo = el.qpm;
            if (changePositions.indexOf("" + el.timing) >= 0 && lastTempo !== tempoChanges["" + el.timing].qpm) {
              lastTempo = tempoChanges["" + el.timing].qpm;
              if (el.el_type === "tempo") {
                el.qpm = tempoChanges["" + el.timing].qpm;
                j++;
              } else {
                voices[i2].splice(j, 0, { el_type: "tempo", qpm: tempoChanges["" + el.timing].qpm, timing: el.timing });
                j += 2;
              }
            }
          }
        }
      }
      function chordVoiceOffThisBar(voices) {
        for (var i2 = 0; i2 < voices.length; i2++) {
          var voice = voices[i2];
          var j = voice.length - 1;
          while (j >= 0 && voice[j].el_type !== "bar") {
            voice[j].noChordVoice = true;
            j--;
          }
        }
      }
      function getTrackTitle(staff, voiceNumber) {
        if (!staff || staff.length <= voiceNumber || !staff[voiceNumber].title)
          return void 0;
        return staff[voiceNumber].title.join(" ");
      }
      function interpretTempo(element, beatLength) {
        var duration = 1 / 4;
        if (element.duration) {
          duration = element.duration[0];
        }
        var bpm = 60;
        if (element.bpm) {
          bpm = element.bpm;
        }
        return duration * bpm / beatLength;
      }
      function interpretMeter(element) {
        var meter;
        switch (element.type) {
          case "common_time":
            meter = { el_type: "meter", num: 4, den: 4 };
            break;
          case "cut_time":
            meter = { el_type: "meter", num: 2, den: 2 };
            break;
          case "specified":
            meter = { el_type: "meter", num: element.value[0].num, den: element.value[0].den };
            break;
          default:
            meter = { el_type: "meter" };
        }
        measureLength = meter.num / meter.den;
        return meter;
      }
      function removeNaturals(accidentals) {
        var acc = [];
        for (var i2 = 0; i2 < accidentals.length; i2++) {
          if (accidentals[i2].acc !== "natural")
            acc.push(accidentals[i2]);
        }
        return acc;
      }
      function addKey(arr, key) {
        var newKey;
        if (key.root === "HP")
          newKey = { el_type: "key", accidentals: [{ acc: "natural", note: "g" }, { acc: "sharp", note: "f" }, { acc: "sharp", note: "c" }] };
        else
          newKey = { el_type: "key", accidentals: removeNaturals(key.accidentals) };
        addIfDifferent(arr, newKey);
      }
      function addMeter(arr, meter) {
        var newMeter = interpretMeter(meter);
        addIfDifferent(arr, newMeter);
      }
      function addIfDifferent(arr, item) {
        for (var i2 = arr.length - 1; i2 >= 0; i2--) {
          if (arr[i2].el_type === item.el_type) {
            if (JSON.stringify(arr[i2]) !== JSON.stringify(item))
              arr.push(item);
            return;
          }
        }
        arr.push(item);
      }
    })();
    module.exports = sequence;
  }
});

// node_modules/abcjs/src/synth/chord-track.js
var require_chord_track = __commonJS({
  "node_modules/abcjs/src/synth/chord-track.js"(exports, module) {
    var ChordTrack = function ChordTrack2(numVoices, chordsOff, midiOptions, meter) {
      this.chordTrack = [];
      this.chordTrackFinished = false;
      this.chordChannel = numVoices;
      this.currentChords = [];
      this.lastChord;
      this.chordLastBar;
      this.chordsOff = !!chordsOff;
      this.gChordTacet = this.chordsOff;
      this.hasRhythmHead = false;
      this.transpose = 0;
      this.lastBarTime = 0;
      this.meter = meter;
      this.tempoChangeFactor = 1;
      this.bassInstrument = midiOptions.bassprog && midiOptions.bassprog.length >= 1 ? midiOptions.bassprog[0] : 0;
      this.chordInstrument = midiOptions.chordprog && midiOptions.chordprog.length >= 1 ? midiOptions.chordprog[0] : 0;
      this.bassOctaveShift = midiOptions.bassprog && midiOptions.bassprog.length === 2 ? midiOptions.bassprog[1] : 0;
      this.chordOctaveShift = midiOptions.chordprog && midiOptions.chordprog.length === 2 ? midiOptions.chordprog[1] : 0;
      this.boomVolume = midiOptions.bassvol && midiOptions.bassvol.length === 1 ? midiOptions.bassvol[0] : 64;
      this.chickVolume = midiOptions.chordvol && midiOptions.chordvol.length === 1 ? midiOptions.chordvol[0] : 48;
      if (midiOptions.gchord && midiOptions.gchord.length > 0) {
        this.overridePattern = parseGChord(midiOptions.gchord[0]);
      } else {
        this.overridePattern = void 0;
      }
    };
    ChordTrack.prototype.setMeter = function(meter) {
      this.meter = meter;
    };
    ChordTrack.prototype.setTempoChangeFactor = function(tempoChangeFactor) {
      this.tempoChangeFactor = tempoChangeFactor;
    };
    ChordTrack.prototype.setLastBarTime = function(lastBarTime) {
      this.lastBarTime = lastBarTime;
    };
    ChordTrack.prototype.setTranspose = function(transpose) {
      this.transpose = transpose;
    };
    ChordTrack.prototype.setRhythmHead = function(isRhythmHead, elem) {
      this.hasRhythmHead = isRhythmHead;
      var ePitches = [];
      if (isRhythmHead) {
        if (this.lastChord && this.lastChord.chick) {
          for (var i2 = 0; i2 < this.lastChord.chick.length; i2++) {
            var note2 = Object.assign({}, elem.pitches[0]);
            note2.actualPitch = this.lastChord.chick[i2];
            ePitches.push(note2);
          }
        }
      }
      return ePitches;
    };
    ChordTrack.prototype.barEnd = function(element) {
      if (this.chordTrack.length > 0 && !this.chordTrackFinished) {
        this.resolveChords(this.lastBarTime, timeToRealTime(element.time));
        this.currentChords = [];
      }
      this.chordLastBar = this.lastChord;
    };
    ChordTrack.prototype.gChordOn = function(element) {
      if (!this.chordsOff)
        this.gChordTacet = element.tacet;
    };
    ChordTrack.prototype.paramChange = function(element) {
      switch (element.el_type) {
        case "gchord":
          if (element.param && element.param.length > 0) {
            this.overridePattern = parseGChord(element.param);
          } else
            this.overridePattern = void 0;
          break;
        case "bassprog":
          this.bassInstrument = element.value;
          if (element.octaveShift != void 0 && element.octaveShift != null) {
            this.bassOctaveShift = element.octaveShift;
          } else {
            this.bassOctaveShift = 0;
          }
          break;
        case "chordprog":
          this.chordInstrument = element.value;
          if (element.octaveShift != void 0 && element.octaveShift != null) {
            this.chordOctaveShift = element.octaveShift;
          } else {
            this.chordOctaveShift = 0;
          }
          break;
        case "bassvol":
          this.boomVolume = element.param;
          break;
        case "chordvol":
          this.chickVolume = element.param;
          break;
        default:
          console.log("unhandled midi param", element);
      }
    };
    ChordTrack.prototype.finish = function() {
      if (!this.chordTrackEmpty())
        this.chordTrackFinished = true;
    };
    ChordTrack.prototype.addTrack = function(tracks) {
      if (!this.chordTrackEmpty())
        tracks.push(this.chordTrack);
    };
    ChordTrack.prototype.findChord = function(elem) {
      if (this.gChordTacet)
        return "break";
      if (this.chordTrackFinished || !elem.chord || elem.chord.length === 0)
        return null;
      for (var i2 = 0; i2 < elem.chord.length; i2++) {
        var ch = elem.chord[i2];
        if (ch.position === "default")
          return ch.name;
        if (this.breakSynonyms.indexOf(ch.name.toLowerCase()) >= 0)
          return "break";
      }
      return null;
    };
    ChordTrack.prototype.interpretChord = function(name) {
      if (name.length === 0)
        return void 0;
      if (name === "break")
        return { chick: [] };
      var root = name.substring(0, 1);
      if (root === "(") {
        name = name.substring(1, name.length - 2);
        if (name.length === 0)
          return void 0;
        root = name.substring(0, 1);
      }
      var bass = this.basses[root];
      if (!bass)
        return void 0;
      var chordTranspose = this.transpose;
      while (chordTranspose < -8)
        chordTranspose += 12;
      while (chordTranspose > 8)
        chordTranspose -= 12;
      bass += chordTranspose;
      if (bass < 33) {
        bass += 12;
      } else if (bass > 44) {
        bass -= 12;
      }
      var unshiftedBass = bass;
      bass += this.bassOctaveShift * 12;
      var bass2 = bass - 5;
      var chick;
      if (name.length === 1)
        chick = this.chordNotes(bass, "");
      var remaining = name.substring(1);
      var acc = remaining.substring(0, 1);
      if (acc === "b" || acc === "♭") {
        unshiftedBass--;
        bass--;
        bass2--;
        remaining = remaining.substring(1);
      } else if (acc === "#" || acc === "♯") {
        unshiftedBass++;
        bass++;
        bass2++;
        remaining = remaining.substring(1);
      }
      var arr = remaining.split("/");
      chick = this.chordNotes(unshiftedBass, arr[0]);
      if (chick.length >= 3) {
        var fifth = chick[2] - chick[0];
        bass2 = bass2 + fifth - 7;
      }
      if (arr.length === 2) {
        var explicitBass = this.basses[arr[1].substring(0, 1)];
        if (explicitBass) {
          var bassAcc = arr[1].substring(1);
          var bassShift = { "#": 1, "♯": 1, "b": -1, "♭": -1 }[bassAcc] || 0;
          bass = this.basses[arr[1].substring(0, 1)] + bassShift + chordTranspose;
          bass += this.bassOctaveShift * 12;
          bass2 = bass;
        }
      }
      return { boom: bass, boom2: bass2, chick };
    };
    ChordTrack.prototype.chordNotes = function(bass, modifier) {
      var intervals = this.chordIntervals[modifier];
      if (!intervals) {
        if (modifier.slice(0, 2).toLowerCase() === "ma" || modifier[0] === "M")
          intervals = this.chordIntervals.M;
        else if (modifier[0] === "m" || modifier[0] === "-")
          intervals = this.chordIntervals.m;
        else
          intervals = this.chordIntervals.M;
      }
      bass += 12;
      bass += this.chordOctaveShift * 12;
      var notes = [];
      for (var i2 = 0; i2 < intervals.length; i2++) {
        notes.push(bass + intervals[i2]);
      }
      return notes;
    };
    ChordTrack.prototype.writeNote = function(note, beatLength, volume, beat, noteLength, instrument) {
      if (note !== void 0)
        this.chordTrack.push({ cmd: "note", pitch: note, volume, start: this.lastBarTime + beat * durationRounded(beatLength, this.tempoChangeFactor), duration: durationRounded(noteLength, this.tempoChangeFactor), gap: 0, instrument });
    };
    ChordTrack.prototype.chordTrackEmpty = function() {
      var isEmpty = true;
      for (var i2 = 0; i2 < this.chordTrack.length && isEmpty; i2++) {
        if (this.chordTrack[i2].cmd === "note")
          isEmpty = false;
      }
      return isEmpty;
    };
    ChordTrack.prototype.resolveChords = function(startTime, endTime) {
      if (this.hasRhythmHead)
        return;
      var num = this.meter.num;
      var den = this.meter.den;
      var beatLength = 1 / den;
      var noteLength = beatLength / 2;
      var thisMeasureLength = parseInt(num, 10) / parseInt(den, 10);
      var portionOfAMeasure = thisMeasureLength - (endTime - startTime) / this.tempoChangeFactor;
      if (Math.abs(portionOfAMeasure) < 1e-5)
        portionOfAMeasure = 0;
      if (this.currentChords.length === 0 || this.currentChords[0].beat !== 0) {
        this.currentChords.unshift({ beat: 0, chord: this.chordLastBar });
      }
      var currentChordsExpanded = expandCurrentChords(this.currentChords, 8 * num / den, beatLength);
      var thisPattern = this.overridePattern ? this.overridePattern : this.rhythmPatterns[num + "/" + den];
      if (portionOfAMeasure) {
        thisPattern = [];
        var beatsPresent = (endTime - startTime) / this.tempoChangeFactor * 8;
        for (var p = 0; p < beatsPresent / 2; p += 2) {
          thisPattern.push("chick");
          thisPattern.push("");
        }
      }
      if (!thisPattern) {
        thisPattern = [];
        for (var p = 0; p < 8 * num / den / 2; p++) {
          thisPattern.push("chick");
          thisPattern.push("");
        }
      }
      var firstBoom = true;
      var minLength = Math.min(thisPattern.length, currentChordsExpanded.length);
      for (var p = 0; p < minLength; p++) {
        if (p > 0 && currentChordsExpanded[p - 1] && currentChordsExpanded[p] && currentChordsExpanded[p - 1].boom !== currentChordsExpanded[p].boom)
          firstBoom = true;
        var type = thisPattern[p];
        var isBoom = type.indexOf("boom") >= 0;
        var newBass = !isBoom && p !== 0 && thisPattern[0].indexOf("boom") >= 0 && (!currentChordsExpanded[p - 1] || currentChordsExpanded[p - 1].boom !== currentChordsExpanded[p].boom);
        var pitches = resolvePitch(currentChordsExpanded[p], type, firstBoom, newBass);
        if (isBoom)
          firstBoom = false;
        for (var oo = 0; oo < pitches.length; oo++) {
          this.writeNote(
            pitches[oo],
            0.125,
            isBoom || newBass ? this.boomVolume : this.chickVolume,
            p,
            noteLength,
            isBoom || newBass ? this.bassInstrument : this.chordInstrument
          );
          if (newBass)
            newBass = false;
          else
            isBoom = false;
        }
      }
      return;
    };
    ChordTrack.prototype.processChord = function(elem) {
      if (this.chordTrackFinished)
        return;
      var chord = this.findChord(elem);
      if (chord) {
        var c = this.interpretChord(chord);
        if (c) {
          if (this.chordTrack.length === 0) {
            this.chordTrack.push({ cmd: "program", channel: this.chordChannel, instrument: this.chordInstrument });
          }
          this.lastChord = c;
          var barBeat = calcBeat(this.lastBarTime, timeToRealTime(elem.time));
          this.currentChords.push({ chord: this.lastChord, beat: barBeat, start: timeToRealTime(elem.time) });
        }
      }
    };
    function resolvePitch(currentChord, type, firstBoom, newBass) {
      var ret = [];
      if (!currentChord)
        return ret;
      if (type.indexOf("boom") >= 0)
        ret.push(firstBoom ? currentChord.boom : currentChord.boom2);
      else if (newBass)
        ret.push(currentChord.boom);
      var numChordNotes = currentChord.chick.length;
      if (type.indexOf("chick") >= 0) {
        for (var i2 = 0; i2 < numChordNotes; i2++)
          ret.push(currentChord.chick[i2]);
      }
      switch (type) {
        case "DO":
          ret.push(currentChord.chick[0]);
          break;
        case "MI":
          ret.push(currentChord.chick[1]);
          break;
        case "SOL":
          ret.push(extractNote(currentChord, 2));
          break;
        case "TI":
          ret.push(extractNote(currentChord, 3));
          break;
        case "TOP":
          ret.push(extractNote(currentChord, 4));
          break;
        case "do":
          ret.push(currentChord.chick[0] + 12);
          break;
        case "mi":
          ret.push(currentChord.chick[1] + 12);
          break;
        case "sol":
          ret.push(extractNote(currentChord, 2) + 12);
          break;
        case "ti":
          ret.push(extractNote(currentChord, 3) + 12);
          break;
        case "top":
          ret.push(extractNote(currentChord, 4) + 12);
          break;
      }
      return ret;
    }
    function extractNote(chord, index) {
      var octave = Math.floor(index / chord.chick.length);
      var note = chord.chick[index % chord.chick.length];
      return note + octave * 12;
    }
    function parseGChord(gchord) {
      var pattern = [];
      for (var i2 = 0; i2 < gchord.length; i2++) {
        var ch = gchord[i2];
        switch (ch) {
          case "z":
            pattern.push("");
            break;
          case "2":
            pattern.push("");
            break;
          // TODO-PER: This should extend the last note, but that's a small effect
          case "c":
            pattern.push("chick");
            break;
          case "b":
            pattern.push("boom&chick");
            break;
          case "f":
            pattern.push("boom");
            break;
          case "G":
            pattern.push("DO");
            break;
          case "H":
            pattern.push("MI");
            break;
          case "I":
            pattern.push("SOL");
            break;
          case "J":
            pattern.push("TI");
            break;
          case "K":
            pattern.push("TOP");
            break;
          case "g":
            pattern.push("do");
            break;
          case "h":
            pattern.push("mi");
            break;
          case "i":
            pattern.push("sol");
            break;
          case "j":
            pattern.push("ti");
            break;
          case "k":
            pattern.push("top");
            break;
        }
      }
      return pattern;
    }
    function expandCurrentChords(currentChords, num8thNotes, beatLength) {
      beatLength = beatLength * 8;
      var chords = [];
      if (currentChords.length === 0)
        return chords;
      var currentChord = currentChords[0].chord;
      for (var i2 = 1; i2 < currentChords.length; i2++) {
        var current = currentChords[i2];
        while (chords.length < current.beat) {
          chords.push(currentChord);
        }
        currentChord = current.chord;
      }
      while (chords.length < num8thNotes)
        chords.push(currentChord);
      return chords;
    }
    function calcBeat(measureStart, currTime) {
      var distanceFromStart = currTime - measureStart;
      return distanceFromStart * 8;
    }
    ChordTrack.prototype.breakSynonyms = ["break", "(break)", "no chord", "n.c.", "tacet"];
    ChordTrack.prototype.basses = {
      "A": 33,
      "B": 35,
      "C": 36,
      "D": 38,
      "E": 40,
      "F": 41,
      "G": 43
    };
    ChordTrack.prototype.chordIntervals = {
      // diminished (all flat 5 chords)
      "dim": [0, 3, 6],
      "°": [0, 3, 6],
      "˚": [0, 3, 6],
      "dim7": [0, 3, 6, 9],
      "°7": [0, 3, 6, 9],
      "˚7": [0, 3, 6, 9],
      "ø7": [0, 3, 6, 10],
      "m7(b5)": [0, 3, 6, 10],
      "m7b5": [0, 3, 6, 10],
      "m7♭5": [0, 3, 6, 10],
      "-7(b5)": [0, 3, 6, 10],
      "-7b5": [0, 3, 6, 10],
      "7b5": [0, 4, 6, 10],
      "7(b5)": [0, 4, 6, 10],
      "7♭5": [0, 4, 6, 10],
      "7(b9,b5)": [0, 4, 6, 10, 13],
      "7b9,b5": [0, 4, 6, 10, 13],
      "7(#9,b5)": [0, 4, 6, 10, 15],
      "7#9b5": [0, 4, 6, 10, 15],
      "maj7(b5)": [0, 4, 6, 11],
      "maj7b5": [0, 4, 6, 11],
      "13(b5)": [0, 4, 6, 10, 14, 21],
      "13b5": [0, 4, 6, 10, 14, 21],
      // minor (all normal 5, minor 3 chords)
      "m": [0, 3, 7],
      "-": [0, 3, 7],
      "m6": [0, 3, 7, 9],
      "-6": [0, 3, 7, 9],
      "m7": [0, 3, 7, 10],
      "-7": [0, 3, 7, 10],
      "-(b6)": [0, 3, 7, 8],
      "-b6": [0, 3, 7, 8],
      "-6/9": [0, 3, 7, 9, 14],
      "-7(b9)": [0, 3, 7, 10, 13],
      "-7b9": [0, 3, 7, 10, 13],
      "-maj7": [0, 3, 7, 11],
      "-9+7": [0, 3, 7, 11, 13],
      "-11": [0, 3, 7, 11, 14, 17],
      "m11": [0, 3, 7, 11, 14, 17],
      "-maj9": [0, 3, 7, 11, 14],
      "-∆9": [0, 3, 7, 11, 14],
      "mM9": [0, 3, 7, 11, 14],
      // major (all normal 5, major 3 chords)
      "M": [0, 4, 7],
      "6": [0, 4, 7, 9],
      "6/9": [0, 4, 7, 9, 14],
      "6add9": [0, 4, 7, 9, 14],
      "69": [0, 4, 7, 9, 14],
      "7": [0, 4, 7, 10],
      "9": [0, 4, 7, 10, 14],
      "11": [0, 7, 10, 14, 17],
      "13": [0, 4, 7, 10, 14, 21],
      "7b9": [0, 4, 7, 10, 13],
      "7♭9": [0, 4, 7, 10, 13],
      "7(b9)": [0, 4, 7, 10, 13],
      "7(#9)": [0, 4, 7, 10, 15],
      "7#9": [0, 4, 7, 10, 15],
      "(13)": [0, 4, 7, 10, 14, 21],
      "7(9,13)": [0, 4, 7, 10, 14, 21],
      "7(#9,b13)": [0, 4, 7, 10, 15, 20],
      "7(#11)": [0, 4, 7, 10, 14, 18],
      "7#11": [0, 4, 7, 10, 14, 18],
      "7(b13)": [0, 4, 7, 10, 20],
      "7b13": [0, 4, 7, 10, 20],
      "9(#11)": [0, 4, 7, 10, 14, 18],
      "9#11": [0, 4, 7, 10, 14, 18],
      "13(#11)": [0, 4, 7, 10, 18, 21],
      "13#11": [0, 4, 7, 10, 18, 21],
      "maj7": [0, 4, 7, 11],
      "∆7": [0, 4, 7, 11],
      "Δ7": [0, 4, 7, 11],
      "maj9": [0, 4, 7, 11, 14],
      "maj7(9)": [0, 4, 7, 11, 14],
      "maj7(11)": [0, 4, 7, 11, 17],
      "maj7(#11)": [0, 4, 7, 11, 18],
      "maj7(13)": [0, 4, 7, 14, 21],
      "maj7(9,13)": [0, 4, 7, 11, 14, 21],
      "7sus4": [0, 5, 7, 10],
      "m7sus4": [0, 3, 7, 10, 17],
      "sus4": [0, 5, 7],
      "sus2": [0, 2, 7],
      "7sus2": [0, 2, 7, 10],
      "9sus4": [0, 5, 7, 10, 14],
      "13sus4": [0, 5, 7, 10, 14, 21],
      // augmented (all sharp 5 chords)
      "aug7": [0, 4, 8, 10],
      "+7": [0, 4, 8, 10],
      "+": [0, 4, 8],
      "7#5": [0, 4, 8, 10],
      "7♯5": [0, 4, 8, 10],
      "7+5": [0, 4, 8, 10],
      "9#5": [0, 4, 8, 10, 14],
      "9♯5": [0, 4, 8, 10, 14],
      "9+5": [0, 4, 8, 10, 14],
      "-7(#5)": [0, 3, 8, 10],
      "-7#5": [0, 3, 8, 10],
      "7(#5)": [0, 4, 8, 10],
      "7(b9,#5)": [0, 4, 8, 10, 13],
      "7b9#5": [0, 4, 8, 10, 13],
      "maj7(#5)": [0, 4, 8, 11],
      "maj7#5": [0, 4, 8, 11],
      "maj7(#5,#11)": [0, 4, 8, 11, 18],
      "maj7#5#11": [0, 4, 8, 11, 18],
      "9(#5)": [0, 4, 8, 10, 14],
      "13(#5)": [0, 4, 8, 10, 14, 21],
      "13#5": [0, 4, 8, 10, 14, 21],
      // MAE Power chords added 10 April 2024
      "5": [0, 7],
      "5(8)": [0, 7, 12],
      "5add8": [0, 7, 12]
    };
    ChordTrack.prototype.rhythmPatterns = {
      "2/2": ["boom", "", "", "", "chick", "", "", ""],
      "3/2": ["boom", "", "", "", "chick", "", "", "", "chick", "", "", ""],
      "4/2": ["boom", "", "", "", "chick", "", "", "", "boom", "", "", "", "chick", "", "", ""],
      "2/4": ["boom", "", "chick", ""],
      "3/4": ["boom", "", "chick", "", "chick", ""],
      "4/4": ["boom", "", "chick", "", "boom", "", "chick", ""],
      "5/4": ["boom", "", "chick", "", "chick", "", "boom", "", "chick", ""],
      "6/4": ["boom", "", "chick", "", "boom", "", "chick", "", "boom", "", "chick", ""],
      "3/8": ["boom", "", "chick"],
      "5/8": ["boom", "chick", "chick", "boom", "chick"],
      "6/8": ["boom", "", "chick", "boom", "", "chick"],
      "7/8": ["boom", "chick", "chick", "boom", "chick", "boom", "chick"],
      "9/8": ["boom", "", "chick", "boom", "", "chick", "boom", "", "chick"],
      "10/8": ["boom", "chick", "chick", "boom", "chick", "chick", "boom", "chick", "boom", "chick"],
      "11/8": ["boom", "chick", "chick", "boom", "chick", "chick", "boom", "chick", "boom", "chick", "chick"],
      "12/8": ["boom", "", "chick", "boom", "", "chick", "boom", "", "chick", "boom", "", "chick"]
    };
    function timeToRealTime(time) {
      return time / 1e6;
    }
    function durationRounded(duration, tempoChangeFactor) {
      return Math.round(duration * tempoChangeFactor * 1e6) / 1e6;
    }
    module.exports = ChordTrack;
  }
});

// node_modules/abcjs/src/synth/pitches-to-perc.js
var require_pitches_to_perc = __commonJS({
  "node_modules/abcjs/src/synth/pitches-to-perc.js"(exports, module) {
    var pitchMap = {
      f0: "_C",
      n0: "=C",
      s0: "^C",
      x0: "C",
      f1: "_D",
      n1: "=D",
      s1: "^D",
      x1: "D",
      f2: "_E",
      n2: "=E",
      s2: "^E",
      x2: "E",
      f3: "_F",
      n3: "=F",
      s3: "^F",
      x3: "F",
      f4: "_G",
      n4: "=G",
      s4: "^G",
      x4: "G",
      f5: "_A",
      n5: "=A",
      s5: "^A",
      x5: "A",
      f6: "_B",
      n6: "=B",
      s6: "^B",
      x6: "B",
      f7: "_c",
      n7: "=c",
      s7: "^c",
      x7: "c",
      f8: "_d",
      n8: "=d",
      s8: "^d",
      x8: "d",
      f9: "_e",
      n9: "=e",
      s9: "^e",
      x9: "e",
      f10: "_f",
      n10: "=f",
      s10: "^f",
      x10: "f",
      f11: "_g",
      n11: "=g",
      s11: "^g",
      x11: "g",
      f12: "_a",
      n12: "=a",
      s12: "^a",
      x12: "a",
      f13: "_b",
      n13: "=b",
      s13: "^b",
      x13: "b",
      f14: "_c'",
      n14: "=c'",
      s14: "^c'",
      x14: "c'",
      f15: "_d'",
      n15: "=d'",
      s15: "^d'",
      x15: "d'",
      f16: "_e'",
      n16: "=e'",
      s16: "^e'",
      x16: "e'"
    };
    function pitchesToPerc(pitchObj) {
      var pitch = (pitchObj.accidental ? pitchObj.accidental[0] : "x") + pitchObj.verticalPos;
      return pitchMap[pitch];
    }
    module.exports = pitchesToPerc;
  }
});

// node_modules/abcjs/src/synth/abc_midi_flattener.js
var require_abc_midi_flattener = __commonJS({
  "node_modules/abcjs/src/synth/abc_midi_flattener.js"(exports, module) {
    var flatten;
    var ChordTrack = require_chord_track();
    var pitchesToPerc = require_pitches_to_perc();
    (function() {
      "use strict";
      var barAccidentals;
      var accidentals;
      var transpose;
      var bagpipes;
      var tracks;
      var startingTempo;
      var startingMeter;
      var tempoChangeFactor = 1;
      var instrument;
      var currentInstrument;
      var currentTrack;
      var lastNoteDurationPosition;
      var currentTrackName;
      var lastEventTime;
      var chordTrack;
      var meter = { num: 4, den: 4 };
      var drumInstrument = 128;
      var lastBarTime;
      var doBeatAccents = true;
      var stressBeat1 = 105;
      var stressBeatDown = 95;
      var stressBeatUp = 85;
      var beatFraction = 0.25;
      var nextVolume;
      var nextVolumeDelta;
      var slurCount = 0;
      var drumTrack;
      var drumTrackFinished;
      var drumDefinition = {};
      var drumBars;
      var pickupLength = 0;
      var percmap;
      var normalBreakBetweenNotes = 0;
      var slurredBreakBetweenNotes = -1e-3;
      var staccatoBreakBetweenNotes = 0.4;
      flatten = function(voices, options, percmap_, midiOptions) {
        if (!options) options = {};
        if (!midiOptions) midiOptions = {};
        barAccidentals = [];
        accidentals = [0, 0, 0, 0, 0, 0, 0];
        bagpipes = false;
        tracks = [];
        startingTempo = options.qpm;
        startingMeter = void 0;
        tempoChangeFactor = 1;
        instrument = void 0;
        currentInstrument = void 0;
        currentTrack = void 0;
        currentTrackName = void 0;
        lastEventTime = 0;
        percmap = percmap_;
        meter = { num: 4, den: 4 };
        doBeatAccents = true;
        stressBeat1 = 105;
        stressBeatDown = 95;
        stressBeatUp = 85;
        beatFraction = 0.25;
        nextVolume = void 0;
        nextVolumeDelta = void 0;
        slurCount = 0;
        drumTrack = [];
        drumTrackFinished = false;
        drumDefinition = {};
        drumBars = 1;
        if (voices.length > 0 && voices[0].length > 0)
          pickupLength = voices[0][0].pickupLength;
        if (options.bassprog !== void 0 && !midiOptions.bassprog)
          midiOptions.bassprog = [options.bassprog];
        if (options.bassvol !== void 0 && !midiOptions.bassvol)
          midiOptions.bassvol = [options.bassvol];
        if (options.chordprog !== void 0 && !midiOptions.chordprog)
          midiOptions.chordprog = [options.chordprog];
        if (options.chordvol !== void 0 && !midiOptions.chordvol)
          midiOptions.chordvol = [options.chordvol];
        if (options.gchord !== void 0 && !midiOptions.gchord)
          midiOptions.gchord = [options.gchord];
        chordTrack = new ChordTrack(voices.length, options.chordsOff, midiOptions, meter);
        preProcess(voices, options);
        for (var i2 = 0; i2 < voices.length; i2++) {
          transpose = 0;
          chordTrack.setTranspose(transpose);
          lastNoteDurationPosition = -1;
          var voice = voices[i2];
          currentTrack = [{ cmd: "program", channel: i2, instrument }];
          currentTrackName = void 0;
          lastBarTime = 0;
          chordTrack.setLastBarTime(0);
          var voiceOff = false;
          if (options.voicesOff === true)
            voiceOff = true;
          else if (options.voicesOff && options.voicesOff.length && options.voicesOff.indexOf(i2) >= 0)
            voiceOff = true;
          for (var j = 0; j < voice.length; j++) {
            var element = voice[j];
            switch (element.el_type) {
              case "name":
                currentTrackName = { cmd: "text", type: "name", text: element.trackName };
                break;
              case "note":
                writeNote(element, voiceOff);
                break;
              case "key":
                accidentals = setKeySignature(element);
                break;
              case "meter":
                if (!startingMeter)
                  startingMeter = element;
                meter = element;
                chordTrack.setMeter(meter);
                beatFraction = getBeatFraction(meter);
                alignDrumToMeter();
                break;
              case "tempo":
                if (!startingTempo)
                  startingTempo = element.qpm;
                else
                  tempoChangeFactor = element.qpm ? startingTempo / element.qpm : 1;
                chordTrack.setTempoChangeFactor(tempoChangeFactor);
                break;
              case "transpose":
                transpose = element.transpose;
                chordTrack.setTranspose(transpose);
                break;
              case "bar":
                chordTrack.barEnd(element);
                barAccidentals = [];
                if (i2 === 0)
                  writeDrum(voices.length + 1);
                chordTrack.setRhythmHead(false);
                lastBarTime = timeToRealTime(element.time);
                chordTrack.setLastBarTime(lastBarTime);
                break;
              case "bagpipes":
                bagpipes = true;
                break;
              case "instrument":
                if (instrument === void 0)
                  instrument = element.program;
                currentInstrument = element.program;
                if (currentTrack.length > 0 && currentTrack[currentTrack.length - 1].cmd === "program")
                  currentTrack[currentTrack.length - 1].instrument = element.program;
                else {
                  var ii;
                  for (ii = currentTrack.length - 1; ii >= 0 && currentTrack[ii].cmd !== "program"; ii--)
                    ;
                  if (ii < 0 || currentTrack[ii].instrument !== element.program)
                    currentTrack.push({ cmd: "program", channel: 0, instrument: element.program });
                }
                break;
              case "channel":
                setChannel(element.channel);
                break;
              case "drum":
                drumDefinition = normalizeDrumDefinition(element.params);
                alignDrumToMeter();
                break;
              case "gchordOn":
                chordTrack.gChordOn(element);
                break;
              case "beat":
                stressBeat1 = element.beats[0];
                stressBeatDown = element.beats[1];
                stressBeatUp = element.beats[2];
                break;
              case "vol":
                nextVolume = element.volume;
                break;
              case "volinc":
                nextVolumeDelta = element.volume;
                break;
              case "beataccents":
                doBeatAccents = element.value;
                break;
              case "gchord":
              case "bassprog":
              case "chordprog":
              case "bassvol":
              case "chordvol":
              case "gchordbars":
                chordTrack.paramChange(element);
                break;
              default:
                console.log("MIDI creation. Unknown el_type: " + element.el_type + "\n");
                break;
            }
          }
          if (currentTrack[0].instrument === void 0)
            currentTrack[0].instrument = instrument ? instrument : 0;
          if (currentTrackName)
            currentTrack.unshift(currentTrackName);
          tracks.push(currentTrack);
          chordTrack.finish();
          if (drumTrack.length > 0)
            drumTrackFinished = true;
        }
        if (options.detuneOctave)
          findOctaves(tracks, parseInt(options.detuneOctave, 10));
        chordTrack.addTrack(tracks);
        if (drumTrack.length > 0)
          tracks.push(drumTrack);
        return { tempo: startingTempo, instrument, tracks, totalDuration: lastEventTime };
      };
      function setChannel(channel) {
        for (var i2 = currentTrack.length - 1; i2 >= 0; i2--) {
          if (currentTrack[i2].cmd === "program") {
            currentTrack[i2].channel = channel;
            return;
          }
        }
      }
      function timeToRealTime(time) {
        return time / 1e6;
      }
      function durationRounded(duration) {
        return Math.round(duration * tempoChangeFactor * 1e6) / 1e6;
      }
      function preProcess(voices, options) {
        for (var i2 = 0; i2 < voices.length; i2++) {
          var voice = voices[i2];
          var ties = {};
          var startingTempo2 = options.qpm;
          var timeCounter = 0;
          var tempoMultiplier = 1;
          for (var j = 0; j < voice.length; j++) {
            var element = voice[j];
            if (element.el_type === "tempo") {
              if (!startingTempo2)
                startingTempo2 = element.qpm;
              else
                tempoMultiplier = element.qpm ? startingTempo2 / element.qpm : 1;
              continue;
            }
            element.time = timeCounter;
            var thisDuration = element.duration ? element.duration : 0;
            timeCounter += Math.round(thisDuration * tempoMultiplier * 1e6);
            if (element.pitches) {
              for (var k = 0; k < element.pitches.length; k++) {
                var pitch = element.pitches[k];
                if (pitch) {
                  pitch.duration = element.duration;
                  if (pitch.startTie) {
                    if (ties[pitch.pitch] === void 0)
                      ties[pitch.pitch] = { el: j, pitch: k };
                    else {
                      voice[ties[pitch.pitch].el].pitches[ties[pitch.pitch].pitch].duration += pitch.duration;
                      element.pitches[k] = null;
                    }
                  } else if (pitch.endTie) {
                    var tie = ties[pitch.pitch];
                    if (tie) {
                      var dur = pitch.duration;
                      delete voice[tie.el].pitches[tie.pitch].startTie;
                      voice[tie.el].pitches[tie.pitch].duration += dur;
                      element.pitches[k] = null;
                      delete ties[pitch.pitch];
                    } else {
                      delete pitch.endTie;
                    }
                  }
                }
              }
              delete element.duration;
            }
          }
          for (var key in ties) {
            if (ties.hasOwnProperty(key)) {
              var item = ties[key];
              delete voice[item.el].pitches[item.pitch].startTie;
            }
          }
        }
      }
      function getBeatFraction(meter2) {
        switch (parseInt(meter2.den, 10)) {
          case 2:
            return 0.5;
          case 4:
            return 0.25;
          case 8:
            if (meter2.num % 3 === 0)
              return 0.375;
            else
              return 0.125;
          case 16:
            return 0.125;
        }
        return 0.25;
      }
      function calcBeat(measureStart, beatLength, currTime) {
        var distanceFromStart = currTime - measureStart;
        return distanceFromStart / beatLength;
      }
      function processVolume(beat, voiceOff) {
        if (voiceOff)
          return 0;
        var volume;
        if (nextVolume != void 0) {
          volume = nextVolume;
          nextVolume = void 0;
        } else if (!doBeatAccents) {
          volume = stressBeatDown;
        } else if (pickupLength > beat) {
          volume = stressBeatUp;
        } else {
          var barBeat = calcBeat(lastBarTime, getBeatFraction(meter), beat);
          if (barBeat === 0)
            volume = stressBeat1;
          else if (parseInt(barBeat, 10) === barBeat)
            volume = stressBeatDown;
          else
            volume = stressBeatUp;
        }
        if (nextVolumeDelta) {
          volume += nextVolumeDelta;
          nextVolumeDelta = void 0;
        }
        if (volume < 0)
          volume = 0;
        if (volume > 127)
          volume = 127;
        return voiceOff ? 0 : volume;
      }
      function findNoteModifications(elem, velocity) {
        var ret = {};
        if (elem.decoration) {
          for (var d = 0; d < elem.decoration.length; d++) {
            if (elem.decoration[d] === "staccato")
              ret.thisBreakBetweenNotes = "staccato";
            else if (elem.decoration[d] === "tenuto")
              ret.thisBreakBetweenNotes = "tenuto";
            else if (elem.decoration[d] === "accent")
              ret.velocity = Math.min(127, velocity * 1.5);
            else if (elem.decoration[d] === "trill")
              ret.noteModification = "trill";
            else if (elem.decoration[d] === "lowermordent")
              ret.noteModification = "lowermordent";
            else if (elem.decoration[d] === "uppermordent")
              ret.noteModification = "mordent";
            else if (elem.decoration[d] === "mordent")
              ret.noteModification = "mordent";
            else if (elem.decoration[d] === "turn")
              ret.noteModification = "turn";
            else if (elem.decoration[d] === "roll")
              ret.noteModification = "roll";
          }
        }
        return ret;
      }
      function doModifiedNotes(noteModification, p) {
        var noteTime;
        var numNotes;
        var start = p.start;
        var pp;
        var runningDuration = p.duration;
        var shortestNote = durationRounded(1 / 32);
        switch (noteModification) {
          case "trill":
            var note = 2;
            while (runningDuration > 0) {
              currentTrack.push({ cmd: "note", pitch: p.pitch + note, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
              note = note === 2 ? 0 : 2;
              runningDuration -= shortestNote;
              start += shortestNote;
            }
            break;
          case "mordent":
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            runningDuration -= shortestNote;
            start += shortestNote;
            currentTrack.push({ cmd: "note", pitch: p.pitch + 2, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            runningDuration -= shortestNote;
            start += shortestNote;
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start, duration: runningDuration, gap: 0, instrument: currentInstrument });
            break;
          case "lowermordent":
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            runningDuration -= shortestNote;
            start += shortestNote;
            currentTrack.push({ cmd: "note", pitch: p.pitch - 2, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            runningDuration -= shortestNote;
            start += shortestNote;
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start, duration: runningDuration, gap: 0, instrument: currentInstrument });
            break;
          case "turn":
            shortestNote = p.duration / 4;
            currentTrack.push({ cmd: "note", pitch: p.pitch + 2, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start: start + shortestNote, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            currentTrack.push({ cmd: "note", pitch: p.pitch - 1, volume: p.volume, start: start + shortestNote * 2, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start: start + shortestNote * 3, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
            break;
          case "roll":
            while (runningDuration > 0) {
              currentTrack.push({ cmd: "note", pitch: p.pitch, volume: p.volume, start, duration: shortestNote, gap: 0, instrument: currentInstrument, style: "decoration" });
              runningDuration -= shortestNote * 2;
              start += shortestNote * 2;
            }
            break;
        }
      }
      function writeNote(elem, voiceOff) {
        var velocity = processVolume(timeToRealTime(elem.time), voiceOff);
        chordTrack.processChord(elem);
        var graces;
        if (elem.gracenotes && elem.pitches && elem.pitches.length > 0 && elem.pitches[0]) {
          graces = processGraceNotes(elem.gracenotes, elem.pitches[0].duration);
          if (elem.elem)
            elem.elem.midiGraceNotePitches = writeGraceNotes(graces, timeToRealTime(elem.time), velocity * 2 / 3, currentInstrument);
        }
        if (elem.elem) {
          var rt = timeToRealTime(elem.time);
          var ms = rt / beatFraction / startingTempo * 60 * 1e3;
          if (elem.elem.currentTrackMilliseconds === void 0) {
            elem.elem.currentTrackMilliseconds = ms;
            elem.elem.currentTrackWholeNotes = rt;
          } else {
            if (elem.elem.currentTrackMilliseconds.length === void 0) {
              if (elem.elem.currentTrackMilliseconds !== ms) {
                elem.elem.currentTrackMilliseconds = [elem.elem.currentTrackMilliseconds, ms];
                elem.elem.currentTrackWholeNotes = [elem.elem.currentTrackWholeNotes, rt];
              }
            } else {
              var found = false;
              for (var j = 0; j < elem.elem.currentTrackMilliseconds.length; j++) {
                if (elem.elem.currentTrackMilliseconds[j] === ms)
                  found = true;
              }
              if (!found) {
                elem.elem.currentTrackMilliseconds.push(ms);
                elem.elem.currentTrackWholeNotes.push(rt);
              }
            }
          }
        }
        if (elem.pitches) {
          var thisBreakBetweenNotes = "";
          var ret = findNoteModifications(elem, velocity);
          if (ret.thisBreakBetweenNotes)
            thisBreakBetweenNotes = ret.thisBreakBetweenNotes;
          if (ret.velocity)
            velocity = ret.velocity;
          var ePitches = elem.pitches;
          if (elem.style === "rhythm") {
            ePitches = chordTrack.setRhythmHead(true, elem);
          }
          if (elem.elem)
            elem.elem.midiPitches = [];
          for (var i2 = 0; i2 < ePitches.length; i2++) {
            var note = ePitches[i2];
            if (!note)
              continue;
            if (note.startSlur)
              slurCount += note.startSlur.length;
            if (note.endSlur)
              slurCount -= note.endSlur.length;
            var actualPitch = note.actualPitch ? note.actualPitch : adjustPitch(note);
            if (currentInstrument === drumInstrument && percmap) {
              var name = pitchesToPerc(note);
              if (name && percmap[name])
                actualPitch = percmap[name].sound;
            }
            var p = { cmd: "note", pitch: actualPitch, volume: velocity, start: timeToRealTime(elem.time), duration: durationRounded(note.duration), instrument: currentInstrument, startChar: elem.elem.startChar, endChar: elem.elem.endChar };
            p = adjustForMicroTone(p);
            if (elem.gracenotes) {
              p.duration = p.duration / 2;
              p.start = p.start + p.duration;
            }
            if (elem.elem)
              elem.elem.midiPitches.push(p);
            if (ret.noteModification) {
              doModifiedNotes(ret.noteModification, p);
            } else {
              if (slurCount > 0)
                p.endType = "tenuto";
              else if (thisBreakBetweenNotes)
                p.endType = thisBreakBetweenNotes;
              switch (p.endType) {
                case "tenuto":
                  p.gap = slurredBreakBetweenNotes;
                  break;
                case "staccato":
                  var d = p.duration * staccatoBreakBetweenNotes;
                  p.gap = startingTempo / 60 * d;
                  break;
                default:
                  p.gap = normalBreakBetweenNotes;
                  break;
              }
              currentTrack.push(p);
            }
          }
          lastNoteDurationPosition = currentTrack.length - 1;
        }
        var realDur = getRealDuration(elem);
        lastEventTime = Math.max(lastEventTime, timeToRealTime(elem.time) + durationRounded(realDur));
      }
      function getRealDuration(elem) {
        if (elem.pitches && elem.pitches.length > 0 && elem.pitches[0])
          return elem.pitches[0].duration;
        if (elem.elem)
          return elem.elem.duration;
        return elem.duration;
      }
      var scale = [0, 2, 4, 5, 7, 9, 11];
      function adjustPitch(note) {
        if (note.midipitch !== void 0)
          return note.midipitch;
        var pitch = note.pitch;
        if (note.accidental) {
          switch (note.accidental) {
            // change that pitch (not other octaves) for the rest of the bar
            case "sharp":
              barAccidentals[pitch] = 1;
              break;
            case "flat":
              barAccidentals[pitch] = -1;
              break;
            case "natural":
              barAccidentals[pitch] = 0;
              break;
            case "dblsharp":
              barAccidentals[pitch] = 2;
              break;
            case "dblflat":
              barAccidentals[pitch] = -2;
              break;
            case "quartersharp":
              barAccidentals[pitch] = 0.25;
              break;
            case "quarterflat":
              barAccidentals[pitch] = -0.25;
              break;
          }
        }
        var actualPitch = extractOctave(pitch) * 12 + scale[extractNote(pitch)] + 60;
        if (barAccidentals[pitch] !== void 0) {
          actualPitch += barAccidentals[pitch];
        } else {
          actualPitch += accidentals[extractNote(pitch)];
        }
        actualPitch += transpose;
        return actualPitch;
      }
      function setKeySignature(elem) {
        var accidentals2 = [0, 0, 0, 0, 0, 0, 0];
        if (!elem.accidentals) return accidentals2;
        for (var i2 = 0; i2 < elem.accidentals.length; i2++) {
          var acc = elem.accidentals[i2];
          var d;
          switch (acc.acc) {
            case "flat":
              d = -1;
              break;
            case "quarterflat":
              d = -0.25;
              break;
            case "sharp":
              d = 1;
              break;
            case "quartersharp":
              d = 0.25;
              break;
            default:
              d = 0;
              break;
          }
          var lowercase = acc.note.toLowerCase();
          var note = extractNote(lowercase.charCodeAt(0) - "c".charCodeAt(0));
          accidentals2[note] += d;
        }
        return accidentals2;
      }
      function processGraceNotes(graces, companionDuration) {
        var graceDuration = 0;
        var ret = [];
        var grace;
        for (var g = 0; g < graces.length; g++) {
          grace = graces[g];
          graceDuration += grace.duration;
        }
        var multiplier = companionDuration / 2 / graceDuration;
        for (g = 0; g < graces.length; g++) {
          grace = graces[g];
          var actualPitch = adjustPitch(grace);
          if (currentInstrument === drumInstrument && percmap) {
            var name = pitchesToPerc(grace);
            if (name && percmap[name])
              actualPitch = percmap[name].sound;
          }
          var pitch = { pitch: actualPitch, duration: grace.duration * multiplier };
          pitch = adjustForMicroTone(pitch);
          ret.push(pitch);
        }
        return ret;
      }
      function writeGraceNotes(graces, start, velocity, currentInstrument2) {
        var midiGrace = [];
        velocity = Math.round(velocity);
        for (var g = 0; g < graces.length; g++) {
          var gp = graces[g];
          currentTrack.push({ cmd: "note", pitch: gp.pitch, volume: velocity, start, duration: gp.duration, gap: 0, instrument: currentInstrument2, style: "grace" });
          midiGrace.push({
            pitch: gp.pitch,
            durationInMeasures: gp.duration,
            volume: velocity,
            instrument: currentInstrument2
          });
          start += gp.duration;
        }
        return midiGrace;
      }
      var quarterToneFactor = 0.02930223664349;
      function adjustForMicroTone(description) {
        var pitch = "" + description.pitch;
        if (pitch.indexOf(".75") >= 0) {
          description.pitch = Math.round(description.pitch);
          description.cents = -50;
        } else if (pitch.indexOf(".25") >= 0) {
          description.pitch = Math.round(description.pitch);
          description.cents = 50;
        }
        return description;
      }
      function extractOctave(pitch) {
        return Math.floor(pitch / 7);
      }
      function extractNote(pitch) {
        pitch = pitch % 7;
        if (pitch < 0) pitch += 7;
        return pitch;
      }
      function normalizeDrumDefinition(params) {
        if (params.pattern.length === 0 || params.on === false)
          return { on: false };
        var str = params.pattern[0];
        var events = [];
        var event = "";
        var totalPlay = 0;
        for (var i2 = 0; i2 < str.length; i2++) {
          if (str[i2] === "d")
            totalPlay++;
          if (str[i2] === "d" || str[i2] === "z") {
            if (event.length !== 0) {
              events.push(event);
              event = str[i2];
            } else
              event = event + str[i2];
          } else {
            if (event.length === 0) {
              return { on: false };
            }
            event = event + str[i2];
          }
        }
        if (event.length !== 0)
          events.push(event);
        if (params.pattern.length !== totalPlay * 2 + 1)
          return { on: false };
        var ret = { on: true, bars: params.bars, pattern: [] };
        var beatLength = getBeatFraction(meter);
        var playCount = 0;
        for (var j = 0; j < events.length; j++) {
          event = events[j];
          var len = 1;
          var div = false;
          var num = 0;
          for (var k = 1; k < event.length; k++) {
            switch (event[k]) {
              case "/":
                if (num !== 0)
                  len *= num;
                num = 0;
                div = true;
                break;
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                num = num * 10 + event[k];
                break;
              default:
                return { on: false };
            }
          }
          if (div) {
            if (num === 0) num = 2;
            len /= num;
          } else if (num)
            len *= num;
          if (event[0] === "d") {
            ret.pattern.push({ len: len * beatLength, pitch: params.pattern[1 + playCount], velocity: params.pattern[1 + playCount + totalPlay] });
            playCount++;
          } else
            ret.pattern.push({ len: len * beatLength, pitch: null });
        }
        drumBars = params.bars ? params.bars : 1;
        return ret;
      }
      function alignDrumToMeter() {
        if (!drumDefinition || !drumDefinition.pattern) {
          return;
        }
        var ret = drumDefinition;
        var totalTime = 0;
        var measuresPerBeat = meter.num / meter.den;
        for (var ii = 0; ii < ret.pattern.length; ii++)
          totalTime += ret.pattern[ii].len;
        var factor = totalTime / drumBars / measuresPerBeat;
        for (ii = 0; ii < ret.pattern.length; ii++)
          ret.pattern[ii].len = ret.pattern[ii].len / factor;
        drumDefinition = ret;
      }
      function writeDrum(channel) {
        if (drumTrack.length === 0 && !drumDefinition.on)
          return;
        var measureLen = meter.num / meter.den;
        if (drumTrack.length === 0) {
          if (lastEventTime < measureLen)
            return;
          drumTrack.push({ cmd: "program", channel, instrument: drumInstrument });
        }
        if (!drumDefinition.on) {
          return;
        }
        var start = lastBarTime;
        for (var i2 = 0; i2 < drumDefinition.pattern.length; i2++) {
          var len = durationRounded(drumDefinition.pattern[i2].len);
          if (drumDefinition.pattern[i2].pitch) {
            drumTrack.push({
              cmd: "note",
              pitch: drumDefinition.pattern[i2].pitch,
              volume: drumDefinition.pattern[i2].velocity,
              start,
              duration: len,
              gap: 0,
              instrument: drumInstrument
            });
          }
          start += len;
        }
      }
      function findOctaves(tracks2, detuneCents) {
        var timing = {};
        for (var i2 = 0; i2 < tracks2.length; i2++) {
          for (var j = 0; j < tracks2[i2].length; j++) {
            var note = tracks2[i2][j];
            if (note.cmd === "note") {
              if (timing[note.start] === void 0)
                timing[note.start] = [];
              timing[note.start].push({ track: i2, event: j, pitch: note.pitch });
            }
          }
        }
        var keys = Object.keys(timing);
        for (i2 = 0; i2 < keys.length; i2++) {
          var arr = timing[keys[i2]];
          if (arr.length > 1) {
            arr = arr.sort(function(a, b) {
              return a.pitch - b.pitch;
            });
            var topEvent = arr[arr.length - 1];
            var topNote = topEvent.pitch % 12;
            var found = false;
            for (j = 0; !found && j < arr.length - 1; j++) {
              if (arr[j].pitch % 12 === topNote)
                found = true;
            }
            if (found) {
              var event = tracks2[topEvent.track][topEvent.event];
              if (!event.cents)
                event.cents = 0;
              event.cents += detuneCents;
            }
          }
        }
      }
    })();
    module.exports = flatten;
  }
});

// node_modules/abcjs/src/data/deline-tune.js
var require_deline_tune = __commonJS({
  "node_modules/abcjs/src/data/deline-tune.js"(exports, module) {
    function delineTune(inputLines, options) {
      if (!options) options = {};
      var lineBreaks = !!options.lineBreaks;
      var outputLines = [];
      var inMusicLine = false;
      var currentMeter = [];
      var currentKey = [];
      var currentClef = [];
      var currentVocalFont = [];
      var currentGChordFont = [];
      var currentTripletFont = [];
      var currentAnnotationFont = [];
      for (var i2 = 0; i2 < inputLines.length; i2++) {
        var inputLine = inputLines[i2];
        if (inputLine.staff) {
          if (inMusicLine && !inputLine.vskip) {
            var outputLine = outputLines[outputLines.length - 1];
            for (var s2 = 0; s2 < outputLine.staff.length; s2++) {
              var inputStaff = inputLine.staff[s2];
              var outputStaff = outputLine.staff[s2];
              if (inputStaff) {
                if (!objEqual(inputStaff.meter, currentMeter[s2])) {
                  addMeterToVoices(inputStaff.meter, inputStaff.voices);
                  currentMeter[s2] = inputStaff.meter;
                  delete inputStaff.meter;
                }
                if (!objEqual(inputStaff.key, currentKey[s2])) {
                  addKeyToVoices(inputStaff.key, inputStaff.voices);
                  currentKey[s2] = inputStaff.key;
                  delete inputStaff.key;
                }
                if (inputStaff.title)
                  outputStaff.abbrevTitle = inputStaff.title;
                if (!objEqual(inputStaff.clef, currentClef[s2])) {
                  addClefToVoices(inputStaff.clef, inputStaff.voices);
                  currentClef[s2] = inputStaff.clef;
                  delete inputStaff.clef;
                }
                if (!objEqual(inputStaff.vocalfont, currentVocalFont[s2])) {
                  addFontToVoices(inputStaff.vocalfont, inputStaff.voices, "vocalfont");
                  currentVocalFont[s2] = inputStaff.vocalfont;
                  delete inputStaff.vocalfont;
                }
                if (!objEqual(inputStaff.gchordfont, currentGChordFont[s2])) {
                  addFontToVoices(inputStaff.gchordfont, inputStaff.voices, "gchordfont");
                  currentGChordFont[s2] = inputStaff.gchordfont;
                  delete inputStaff.gchordfont;
                }
                if (!objEqual(inputStaff.tripletfont, currentTripletFont[s2])) {
                  addFontToVoices(inputStaff.tripletfont, inputStaff.voices, "tripletfont");
                  currentTripletFont[s2] = inputStaff.tripletfont;
                  delete inputStaff.tripletfont;
                }
                if (!objEqual(inputStaff.annotationfont, currentAnnotationFont[s2])) {
                  addFontToVoices(inputStaff.annotationfont, inputStaff.voices, "annotationfont");
                  currentAnnotationFont[s2] = inputStaff.annotationfont;
                  delete inputStaff.annotationfont;
                }
              }
              if (inputStaff) {
                for (var v2 = 0; v2 < outputStaff.voices.length; v2++) {
                  var outputVoice = outputStaff.voices[v2];
                  var inputVoice = inputStaff.voices[v2];
                  if (lineBreaks)
                    outputVoice.push({ el_type: "break" });
                  if (inputVoice)
                    outputStaff.voices[v2] = outputVoice.concat(inputVoice);
                }
              }
            }
          } else {
            for (var ii = 0; ii < inputLine.staff.length; ii++) {
              currentKey[ii] = inputLine.staff[ii].key;
              currentMeter[ii] = inputLine.staff[ii].meter;
              currentClef[ii] = inputLine.staff[ii].clef;
            }
            outputLines.push(cloneLine(inputLine));
          }
          inMusicLine = true;
        } else {
          inMusicLine = false;
          outputLines.push(inputLine);
        }
      }
      return outputLines;
    }
    function replacer(key, value) {
      if (key === "abselem") {
        return "abselem";
      }
      return value;
    }
    function addMeterToVoices(meter, voices) {
      meter.el_type = "meter";
      meter.startChar = -1;
      meter.endChar = -1;
      for (var i2 = 0; i2 < voices.length; i2++) {
        voices[i2].unshift(meter);
      }
    }
    function addKeyToVoices(key, voices) {
      key.el_type = "key";
      key.startChar = -1;
      key.endChar = -1;
      for (var i2 = 0; i2 < voices.length; i2++) {
        voices[i2].unshift(key);
      }
    }
    function addClefToVoices(clef, voices) {
      clef.el_type = "clef";
      clef.startChar = -1;
      clef.endChar = -1;
      for (var i2 = 0; i2 < voices.length; i2++) {
        voices[i2].unshift(clef);
      }
    }
    function addFontToVoices(font, voices, type) {
      font.el_type = "font";
      font.type = type;
      font.startChar = -1;
      font.endChar = -1;
      for (var i2 = 0; i2 < voices.length; i2++) {
        voices[i2].unshift(font);
      }
    }
    function objEqual(input, output) {
      if (!input)
        return true;
      var inputValue = JSON.stringify(input, replacer);
      var outputValue = JSON.stringify(output, replacer);
      return inputValue === outputValue;
    }
    function cloneLine(line) {
      var output = {};
      var keys = Object.keys(line);
      for (var i2 = 0; i2 < keys.length; i2++) {
        if (keys[i2] !== "staff")
          output[keys[i2]] = line[keys[i2]];
        else {
          output.staff = [];
          for (var j = 0; j < line.staff.length; j++) {
            var staff = {};
            var keys2 = Object.keys(line.staff[j]);
            for (var k = 0; k < keys2.length; k++) {
              if (keys2[k] !== "voices")
                staff[keys2[k]] = line.staff[j][keys2[k]];
              else {
                staff.voices = [];
                for (var v2 = 0; v2 < line.staff[j].voices.length; v2++) {
                  staff.voices.push([].concat(line.staff[j].voices[v2]));
                }
              }
            }
            output.staff.push(staff);
          }
        }
      }
      return output;
    }
    module.exports = delineTune;
  }
});

// node_modules/abcjs/src/data/abc_tune.js
var require_abc_tune = __commonJS({
  "node_modules/abcjs/src/data/abc_tune.js"(exports, module) {
    var parseCommon = require_abc_common();
    var spacing = require_spacing();
    var sequence = require_abc_midi_sequencer();
    var flatten = require_abc_midi_flattener();
    var delineTune = require_deline_tune();
    var Tune = function() {
      this.reset = function() {
        this.version = "1.1.0";
        this.media = "screen";
        this.metaText = {};
        this.metaTextInfo = {};
        this.formatting = {};
        this.lines = [];
        this.staffNum = 0;
        this.voiceNum = 0;
        this.lineNum = 0;
        this.runningFonts = {};
        delete this.visualTranspose;
      };
      this.reset();
      function copy(dest, src, prop, attrs) {
        for (var i2 = 0; i2 < attrs.length; i2++)
          dest[prop][attrs[i2]] = src[prop][attrs[i2]];
      }
      this.copyTopInfo = function(src) {
        var attrs = ["tempo", "title", "header", "rhythm", "origin", "composer", "author", "partOrder"];
        copy(this, src, "metaText", attrs);
        copy(this, src, "metaTextInfo", attrs);
      };
      this.copyBottomInfo = function(src) {
        var attrs = [
          "unalignedWords",
          "book",
          "source",
          "discography",
          "notes",
          "transcription",
          "history",
          "abc-copyright",
          "abc-creator",
          "abc-edited-by",
          "footer"
        ];
        copy(this, src, "metaText", attrs);
        copy(this, src, "metaTextInfo", attrs);
      };
      this.getBeatLength = function() {
        var meter = this.getMeterFraction();
        var multiplier = 1;
        if (meter.num === 6 || meter.num === 9 || meter.num === 12)
          multiplier = 3;
        else if (meter.num === 3 && meter.den === 8)
          multiplier = 3;
        return multiplier / meter.den;
      };
      function computePickupLength(lines, barLength) {
        var pickupLength = 0;
        for (var i2 = 0; i2 < lines.length; i2++) {
          if (lines[i2].staff) {
            for (var j = 0; j < lines[i2].staff.length; j++) {
              for (var v2 = 0; v2 < lines[i2].staff[j].voices.length; v2++) {
                var voice = lines[i2].staff[j].voices[v2];
                var tripletMultiplier = 1;
                for (var el = 0; el < voice.length; el++) {
                  var isSpacer = voice[el].rest && voice[el].rest.type === "spacer";
                  if (voice[el].startTriplet)
                    tripletMultiplier = voice[el].tripletMultiplier;
                  if (voice[el].duration && !isSpacer && voice[el].el_type !== "tempo")
                    pickupLength += voice[el].duration * tripletMultiplier;
                  if (voice[el].endTriplet)
                    tripletMultiplier = 1;
                  if (pickupLength >= barLength)
                    pickupLength -= barLength;
                  if (voice[el].el_type === "bar")
                    return pickupLength;
                }
              }
            }
          }
        }
        return pickupLength;
      }
      this.getPickupLength = function() {
        var barLength = this.getBarLength();
        var pickupLength = computePickupLength(this.lines, barLength);
        return pickupLength < 1e-8 || barLength - pickupLength < 1e-8 ? 0 : pickupLength;
      };
      this.getBarLength = function() {
        var meter = this.getMeterFraction();
        return meter.num / meter.den;
      };
      this.getTotalTime = function() {
        return this.totalTime;
      };
      this.getTotalBeats = function() {
        return this.totalBeats;
      };
      this.millisecondsPerMeasure = function(bpmOverride) {
        var bpm;
        if (bpmOverride) {
          bpm = bpmOverride;
        } else {
          var tempo = this.metaText ? this.metaText.tempo : null;
          bpm = this.getBpm(tempo);
        }
        if (bpm <= 0)
          bpm = 1;
        var beatsPerMeasure = this.getBeatsPerMeasure();
        var minutesPerMeasure = beatsPerMeasure / bpm;
        return minutesPerMeasure * 6e4;
      };
      this.getBeatsPerMeasure = function() {
        var beatLen = this.getBeatLength();
        var barLen = this.getBarLength();
        return barLen / beatLen;
      };
      this.getMeter = function() {
        for (var i2 = 0; i2 < this.lines.length; i2++) {
          var line = this.lines[i2];
          if (line.staff) {
            for (var j = 0; j < line.staff.length; j++) {
              var meter = line.staff[j].meter;
              if (meter) {
                return meter;
              }
            }
          }
        }
        return { type: "common_time" };
      };
      this.getMeterFraction = function() {
        var meter = this.getMeter();
        var num = 4;
        var den = 4;
        if (meter) {
          if (meter.type === "specified") {
            num = parseInt(meter.value[0].num, 10);
            den = parseInt(meter.value[0].den, 10);
          } else if (meter.type === "cut_time") {
            num = 2;
            den = 2;
          } else if (meter.type === "common_time") {
            num = 4;
            den = 4;
          }
        }
        this.meter = { num, den };
        return this.meter;
      };
      this.getKeySignature = function() {
        for (var i2 = 0; i2 < this.lines.length; i2++) {
          var line = this.lines[i2];
          if (line.staff) {
            for (var j = 0; j < line.staff.length; j++) {
              if (line.staff[j].key)
                return line.staff[j].key;
            }
          }
        }
        return {};
      };
      this.getElementFromChar = function(char) {
        for (var i2 = 0; i2 < this.lines.length; i2++) {
          var line = this.lines[i2];
          if (line.staff) {
            for (var j = 0; j < line.staff.length; j++) {
              var staff = line.staff[j];
              for (var k = 0; k < staff.voices.length; k++) {
                var voice = staff.voices[k];
                for (var ii = 0; ii < voice.length; ii++) {
                  var elem = voice[ii];
                  if (elem.startChar && elem.endChar && elem.startChar <= char && elem.endChar > char)
                    return elem;
                }
              }
            }
          }
        }
        return null;
      };
      function addVerticalInfo(timingEvents) {
        var lastBarTop;
        var lastBarBottom;
        var lastEventTop;
        var lastEventBottom;
        for (var e = timingEvents.length - 1; e >= 0; e--) {
          var ev = timingEvents[e];
          if (ev.type === "bar") {
            ev.top = lastEventTop;
            ev.nextTop = lastBarTop;
            lastBarTop = lastEventTop;
            ev.bottom = lastEventBottom;
            ev.nextBottom = lastBarBottom;
            lastBarBottom = lastEventBottom;
          } else if (ev.type === "event") {
            lastEventTop = ev.top;
            lastEventBottom = ev.top + ev.height;
          }
        }
      }
      function makeSortedArray(hash) {
        var arr = [];
        for (var k in hash) {
          if (hash.hasOwnProperty(k))
            arr.push(hash[k]);
        }
        arr = arr.sort(function(a, b) {
          var diff = a.milliseconds - b.milliseconds;
          if (diff !== 0) {
            return diff;
          } else {
            return a.type === "bar" ? -1 : 1;
          }
        });
        return arr;
      }
      this.addElementToEvents = function(eventHash, element, voiceTimeMilliseconds, top, height, line, measureNumber, timeDivider, isTiedState, nextIsBar) {
        if (element.hint)
          return { isTiedState: void 0, duration: 0 };
        var realDuration = element.durationClass ? element.durationClass : element.duration;
        if (element.abcelem.rest && element.abcelem.rest.type === "spacer")
          realDuration = 0;
        if (realDuration > 0) {
          var es = [];
          for (var i2 = 0; i2 < element.elemset.length; i2++) {
            if (element.elemset[i2] !== null)
              es.push(element.elemset[i2]);
          }
          var isTiedToNext = element.startTie;
          if (isTiedState !== void 0) {
            eventHash["event" + isTiedState].elements.push(es);
            if (nextIsBar) {
              if (!eventHash["event" + voiceTimeMilliseconds]) {
                eventHash["event" + voiceTimeMilliseconds] = {
                  type: "event",
                  milliseconds: voiceTimeMilliseconds,
                  line,
                  measureNumber,
                  top,
                  height,
                  left: null,
                  width: 0,
                  elements: [],
                  startChar: null,
                  endChar: null,
                  startCharArray: [],
                  endCharArray: []
                };
              }
              eventHash["event" + voiceTimeMilliseconds].measureStart = true;
              nextIsBar = false;
            }
            if (!isTiedToNext)
              isTiedState = void 0;
          } else {
            if (!eventHash["event" + voiceTimeMilliseconds]) {
              eventHash["event" + voiceTimeMilliseconds] = {
                type: "event",
                milliseconds: voiceTimeMilliseconds,
                line,
                measureNumber,
                top,
                height,
                left: element.x,
                width: element.w,
                elements: [es],
                startChar: element.abcelem.startChar,
                endChar: element.abcelem.endChar,
                startCharArray: [element.abcelem.startChar],
                endCharArray: [element.abcelem.endChar],
                midiPitches: element.abcelem.midiPitches ? parseCommon.cloneArray(element.abcelem.midiPitches) : []
              };
              if (element.abcelem.midiGraceNotePitches)
                eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches = parseCommon.cloneArray(element.abcelem.midiGraceNotePitches);
            } else {
              if (eventHash["event" + voiceTimeMilliseconds].left)
                eventHash["event" + voiceTimeMilliseconds].left = Math.min(eventHash["event" + voiceTimeMilliseconds].left, element.x);
              else
                eventHash["event" + voiceTimeMilliseconds].left = element.x;
              eventHash["event" + voiceTimeMilliseconds].elements.push(es);
              eventHash["event" + voiceTimeMilliseconds].startCharArray.push(element.abcelem.startChar);
              eventHash["event" + voiceTimeMilliseconds].endCharArray.push(element.abcelem.endChar);
              if (eventHash["event" + voiceTimeMilliseconds].startChar === null)
                eventHash["event" + voiceTimeMilliseconds].startChar = element.abcelem.startChar;
              if (eventHash["event" + voiceTimeMilliseconds].endChar === null)
                eventHash["event" + voiceTimeMilliseconds].endChar = element.abcelem.endChar;
              if (element.abcelem.midiPitches && element.abcelem.midiPitches.length) {
                if (!eventHash["event" + voiceTimeMilliseconds].midiPitches)
                  eventHash["event" + voiceTimeMilliseconds].midiPitches = [];
                for (var i2 = 0; i2 < element.abcelem.midiPitches.length; i2++)
                  eventHash["event" + voiceTimeMilliseconds].midiPitches.push(element.abcelem.midiPitches[i2]);
              }
              if (element.abcelem.midiGraceNotePitches && element.abcelem.midiGraceNotePitches.length) {
                if (!eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches)
                  eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches = [];
                for (var j = 0; j < element.abcelem.midiGraceNotePitches.length; j++)
                  eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches.push(element.abcelem.midiGraceNotePitches[j]);
              }
            }
            if (nextIsBar) {
              eventHash["event" + voiceTimeMilliseconds].measureStart = true;
              nextIsBar = false;
            }
          }
        }
        return { isTiedState, duration: realDuration / timeDivider, nextIsBar: nextIsBar || element.type === "bar" };
      };
      this.makeVoicesArray = function() {
        var voicesArr = [];
        var measureNumber = [];
        var tempos = {};
        for (var line = 0; line < this.engraver.staffgroups.length; line++) {
          var group = this.engraver.staffgroups[line];
          if (group && group.staffs && group.staffs.length > 0) {
            var firstStaff = group.staffs[0];
            var middleC = firstStaff.absoluteY;
            var top = middleC - firstStaff.top * spacing.STEP;
            var lastStaff = group.staffs[group.staffs.length - 1];
            middleC = lastStaff.absoluteY;
            var bottom = middleC - lastStaff.bottom * spacing.STEP;
            var height = bottom - top;
            var voices = group.voices;
            for (var v2 = 0; v2 < voices.length; v2++) {
              if (voices[v2].staff && voices[v2].staff.isTabStaff)
                continue;
              var noteFound = false;
              if (!voicesArr[v2])
                voicesArr[v2] = [];
              if (measureNumber[v2] === void 0)
                measureNumber[v2] = 0;
              var elements = voices[v2].children;
              for (var elem = 0; elem < elements.length; elem++) {
                if (elements[elem].type === "tempo")
                  tempos[measureNumber[v2]] = this.getBpm(elements[elem].abcelem);
                voicesArr[v2].push({ top, height, line: group.line, measureNumber: measureNumber[v2], elem: elements[elem] });
                if (elements[elem].type === "bar" && noteFound)
                  measureNumber[v2]++;
                if (elements[elem].type === "note" || elements[elem].type === "rest")
                  noteFound = true;
              }
            }
          }
        }
        this.tempoLocations = tempos;
        return voicesArr;
      };
      this.setupEvents = function(startingDelay, timeDivider, startingBpm, warp) {
        if (!warp) warp = 1;
        var timingEvents = [];
        var eventHash = {};
        var time = startingDelay;
        var isTiedState;
        var nextIsBar = true;
        var voices = this.makeVoicesArray();
        var maxVoiceTimeMilliseconds = 0;
        for (var v2 = 0; v2 < voices.length; v2++) {
          var voiceTime = time;
          var voiceTimeMilliseconds = Math.round(voiceTime * 1e3);
          var startingRepeatElem = 0;
          var endingRepeatElem = -1;
          var elements = voices[v2];
          var bpm = startingBpm;
          timeDivider = this.getBeatLength() * bpm / 60;
          var tempoDone = -1;
          for (var elem = 0; elem < elements.length; elem++) {
            var thisMeasure = elements[elem].measureNumber;
            if (tempoDone !== thisMeasure && this.tempoLocations[thisMeasure]) {
              bpm = this.tempoLocations[thisMeasure];
              timeDivider = warp * this.getBeatLength() * bpm / 60;
              tempoDone = thisMeasure;
            }
            var element = elements[elem].elem;
            var ret = this.addElementToEvents(eventHash, element, voiceTimeMilliseconds, elements[elem].top, elements[elem].height, elements[elem].line, elements[elem].measureNumber, timeDivider, isTiedState, nextIsBar);
            isTiedState = ret.isTiedState;
            nextIsBar = ret.nextIsBar;
            voiceTime += ret.duration;
            var lastHash;
            if (element.duration > 0 && eventHash["event" + voiceTimeMilliseconds])
              lastHash = "event" + voiceTimeMilliseconds;
            voiceTimeMilliseconds = Math.round(voiceTime * 1e3);
            if (element.type === "bar") {
              var barType = element.abcelem.type;
              var endRepeat = barType === "bar_right_repeat" || barType === "bar_dbl_repeat";
              var startEnding = element.abcelem.startEnding === "1";
              var startRepeat = barType === "bar_left_repeat" || barType === "bar_dbl_repeat" || barType === "bar_right_repeat";
              if (endRepeat) {
                if (elem > 0) {
                  eventHash[lastHash].endX = element.x;
                }
                if (endingRepeatElem === -1)
                  endingRepeatElem = elem;
                var lastVoiceTimeMilliseconds = 0;
                tempoDone = -1;
                for (var el2 = startingRepeatElem; el2 < endingRepeatElem; el2++) {
                  thisMeasure = elements[el2].measureNumber;
                  if (tempoDone !== thisMeasure && this.tempoLocations[thisMeasure]) {
                    bpm = this.tempoLocations[thisMeasure];
                    timeDivider = warp * this.getBeatLength() * bpm / 60;
                    tempoDone = thisMeasure;
                  }
                  var element2 = elements[el2].elem;
                  ret = this.addElementToEvents(eventHash, element2, voiceTimeMilliseconds, elements[el2].top, elements[el2].height, elements[el2].line, elements[el2].measureNumber, timeDivider, isTiedState, nextIsBar);
                  isTiedState = ret.isTiedState;
                  nextIsBar = ret.nextIsBar;
                  voiceTime += ret.duration;
                  lastVoiceTimeMilliseconds = voiceTimeMilliseconds;
                  voiceTimeMilliseconds = Math.round(voiceTime * 1e3);
                }
                if (eventHash["event" + lastVoiceTimeMilliseconds])
                  eventHash["event" + lastVoiceTimeMilliseconds].endX = elements[endingRepeatElem].elem.x;
                nextIsBar = true;
                endingRepeatElem = -1;
              }
              if (startEnding)
                endingRepeatElem = elem;
              if (startRepeat)
                startingRepeatElem = elem;
            }
          }
          maxVoiceTimeMilliseconds = Math.max(maxVoiceTimeMilliseconds, voiceTimeMilliseconds);
        }
        timingEvents = makeSortedArray(eventHash);
        addVerticalInfo(timingEvents);
        addEndPoints(this.lines, timingEvents);
        timingEvents.push({ type: "end", milliseconds: maxVoiceTimeMilliseconds });
        this.addUsefulCallbackInfo(timingEvents, bpm * warp);
        return timingEvents;
      };
      this.addUsefulCallbackInfo = function(timingEvents, bpm) {
        var millisecondsPerMeasure = this.millisecondsPerMeasure(bpm);
        for (var i2 = 0; i2 < timingEvents.length; i2++) {
          var ev = timingEvents[i2];
          ev.millisecondsPerMeasure = millisecondsPerMeasure;
        }
      };
      function skipTies(elements, index) {
        while (index < elements.length && elements[index].left === null)
          index++;
        return elements[index];
      }
      function addEndPoints(lines, elements) {
        if (elements.length < 1)
          return;
        for (var i2 = 0; i2 < elements.length - 1; i2++) {
          var el = elements[i2];
          var next = skipTies(elements, i2 + 1);
          if (el.left !== null) {
            var endX = next && el.top === next.top ? next.left : lines[el.line].staffGroup.w;
            if (el.endX !== void 0) {
              if (endX > el.left)
                el.endX = Math.min(el.endX, endX);
            } else
              el.endX = endX;
          }
        }
        var lastEl = elements[elements.length - 1];
        lastEl.endX = lines[lastEl.line].staffGroup.w;
      }
      this.getBpm = function(tempo) {
        var bpm;
        if (!tempo)
          tempo = this.metaText ? this.metaText.tempo : null;
        if (tempo) {
          bpm = tempo.bpm;
          var beatLength = this.getBeatLength();
          var statedBeatLength = tempo.duration && tempo.duration.length > 0 ? tempo.duration[0] : beatLength;
          bpm = bpm * statedBeatLength / beatLength;
        }
        if (!bpm) {
          bpm = 180;
          var meter = this.getMeterFraction();
          if (meter && meter.num !== 3 && meter.num % 3 === 0) {
            bpm = 120;
          }
        }
        return bpm;
      };
      this.setTiming = function(bpm, measuresOfDelay) {
        measuresOfDelay = measuresOfDelay || 0;
        if (!this.engraver || !this.engraver.staffgroups) {
          console.log("setTiming cannot be called before the tune is drawn.");
          this.noteTimings = [];
          return this.noteTimings;
        }
        var tempo = this.metaText ? this.metaText.tempo : null;
        var naturalBpm = this.getBpm(tempo);
        var warp = 1;
        if (bpm) {
          if (tempo)
            warp = bpm / naturalBpm;
        } else
          bpm = naturalBpm;
        var beatLength = this.getBeatLength();
        var beatsPerSecond = bpm / 60;
        var measureLength = this.getBarLength();
        var startingDelay = measureLength / beatLength * measuresOfDelay / beatsPerSecond;
        if (startingDelay)
          startingDelay -= this.getPickupLength() / beatLength / beatsPerSecond;
        var timeDivider = beatLength * beatsPerSecond;
        this.noteTimings = this.setupEvents(startingDelay, timeDivider, bpm, warp);
        if (this.noteTimings.length > 0) {
          this.totalTime = this.noteTimings[this.noteTimings.length - 1].milliseconds / 1e3;
          this.totalBeats = this.totalTime * beatsPerSecond;
        } else {
          this.totalTime = void 0;
          this.totalBeats = void 0;
        }
        return this.noteTimings;
      };
      this.setUpAudio = function(options) {
        if (!options) options = {};
        var seq = sequence(this, options);
        return flatten(seq, options, this.formatting.percmap, this.formatting.midi);
      };
      this.deline = function(options) {
        return delineTune(this.lines, options);
      };
      this.findSelectableElement = function(target) {
        if (this.engraver && this.engraver.selectables)
          return this.engraver.findSelectableElement(target);
        return null;
      };
      this.getSelectableArray = function() {
        if (this.engraver && this.engraver.selectables)
          return this.engraver.selectables;
        return [];
      };
    };
    module.exports = Tune;
  }
});

// node_modules/abcjs/src/parse/tune-builder.js
var require_tune_builder = __commonJS({
  "node_modules/abcjs/src/parse/tune-builder.js"(exports, module) {
    var parseKeyVoice = require_abc_parse_key_voice();
    var TuneBuilder = function(tune) {
      var self = this;
      var voiceDefs = {};
      var currentVoiceName = "";
      tune.reset();
      this.setVisualTranspose = function(visualTranspose) {
        if (visualTranspose)
          tune.visualTranspose = visualTranspose;
      };
      this.cleanUp = function(barsperstaff, staffnonote, currSlur) {
        closeLine(tune);
        delete tune.runningFonts;
        simplifyMetaText(tune);
        if (tune.metaText.tempo && tune.metaText.tempo.bpm && !tune.metaText.tempo.duration)
          tune.metaText.tempo.duration = [tune.getBeatLength()];
        var anyDeleted = false;
        var i2, s2, v2;
        for (i2 = 0; i2 < tune.lines.length; i2++) {
          if (tune.lines[i2].staff !== void 0) {
            var hasAny = false;
            for (s2 = 0; s2 < tune.lines[i2].staff.length; s2++) {
              if (tune.lines[i2].staff[s2] === void 0) {
                anyDeleted = true;
                tune.lines[i2].staff[s2] = null;
              } else {
                for (v2 = 0; v2 < tune.lines[i2].staff[s2].voices.length; v2++) {
                  if (tune.lines[i2].staff[s2].voices[v2] === void 0)
                    tune.lines[i2].staff[s2].voices[v2] = [];
                  else if (containsNotes(tune.lines[i2].staff[s2].voices[v2])) hasAny = true;
                }
              }
            }
            if (!hasAny) {
              tune.lines[i2] = null;
              anyDeleted = true;
            }
          }
        }
        if (anyDeleted) {
          tune.lines = tune.lines.filter(function(line) {
            return !!line;
          });
          tune.lines.forEach(function(line) {
            if (line.staff)
              line.staff = line.staff.filter(function(line2) {
                return !!line2;
              });
          });
        }
        if (barsperstaff) {
          while (wrapMusicLines(tune.lines, barsperstaff)) {
          }
        }
        if (staffnonote) {
          anyDeleted = false;
          for (i2 = 0; i2 < tune.lines.length; i2++) {
            if (tune.lines[i2].staff !== void 0) {
              for (s2 = 0; s2 < tune.lines[i2].staff.length; s2++) {
                var keepThis = false;
                for (v2 = 0; v2 < tune.lines[i2].staff[s2].voices.length; v2++) {
                  if (containsNotesStrict(tune.lines[i2].staff[s2].voices[v2])) {
                    keepThis = true;
                  }
                }
                if (!keepThis) {
                  anyDeleted = true;
                  tune.lines[i2].staff[s2] = null;
                }
              }
            }
          }
          if (anyDeleted) {
            tune.lines.forEach(function(line) {
              if (line.staff)
                line.staff = line.staff.filter(function(staff2) {
                  return !!staff2;
                });
            });
          }
        }
        fixTitles(tune.lines);
        for (i2 = 0; i2 < tune.lines.length; i2++) {
          if (tune.lines[i2].staff) {
            for (s2 = 0; s2 < tune.lines[i2].staff.length; s2++)
              delete tune.lines[i2].staff[s2].workingClef;
          }
        }
        while (resolveOverlays(tune)) {
        }
        for (var i2 = 0; i2 < tune.lines.length; i2++) {
          var staff = tune.lines[i2].staff;
          if (staff) {
            for (tune.staffNum = 0; tune.staffNum < staff.length; tune.staffNum++) {
              if (staff[tune.staffNum].clef)
                parseKeyVoice.fixClef(staff[tune.staffNum].clef);
              for (tune.voiceNum = 0; tune.voiceNum < staff[tune.staffNum].voices.length; tune.voiceNum++) {
                var voice = staff[tune.staffNum].voices[tune.voiceNum];
                cleanUpSlursInLine(voice, tune.staffNum, tune.voiceNum, currSlur);
                for (var j = 0; j < voice.length; j++) {
                  if (voice[j].el_type === "clef")
                    parseKeyVoice.fixClef(voice[j]);
                }
                if (voice.length > 0 && voice[voice.length - 1].barNumber) {
                  var nextLine = getNextMusicLine(tune.lines, i2);
                  if (nextLine)
                    nextLine.staff[0].barNumber = voice[voice.length - 1].barNumber;
                  delete voice[voice.length - 1].barNumber;
                }
              }
            }
          }
        }
        delete tune.staffNum;
        delete tune.voiceNum;
        delete tune.lineNum;
        delete tune.potentialStartBeam;
        delete tune.potentialEndBeam;
        delete tune.vskipPending;
        return currSlur;
      };
      this.addTieToLastNote = function(dottedTie) {
        var el = getLastNote(tune);
        if (el && el.pitches && el.pitches.length > 0) {
          el.pitches[0].startTie = {};
          if (dottedTie)
            el.pitches[0].startTie.style = "dotted";
          return true;
        }
        return false;
      };
      this.appendElement = function(type, startChar, endChar, hashParams) {
        hashParams.el_type = type;
        if (startChar !== null)
          hashParams.startChar = startChar;
        if (endChar !== null)
          hashParams.endChar = endChar;
        if (type === "note") {
          var dur = getDuration(hashParams);
          if (dur >= 0.25) {
            endBeamLast(tune);
          } else if (hashParams.force_end_beam_last && tune.potentialStartBeam !== void 0) {
            endBeamLast(tune);
          } else if (hashParams.end_beam && tune.potentialStartBeam !== void 0) {
            if (hashParams.rest === void 0)
              endBeamHere(hashParams, tune);
            else
              endBeamLast(tune);
          } else if (hashParams.rest === void 0) {
            if (tune.potentialStartBeam === void 0) {
              if (!hashParams.end_beam) {
                tune.potentialStartBeam = hashParams;
                delete tune.potentialEndBeam;
              }
            } else {
              tune.potentialEndBeam = hashParams;
            }
          }
        } else {
          endBeamLast(tune);
        }
        delete hashParams.end_beam;
        delete hashParams.force_end_beam_last;
        if (hashParams.rest && hashParams.rest.type === "invisible") {
          delete hashParams.decoration;
        }
        if (tune.lines.length <= tune.lineNum || tune.lines[tune.lineNum].staff.length <= tune.staffNum) {
          return false;
        }
        pushNote(self, tune, hashParams, voiceDefs, currentVoiceName);
        return true;
      };
      this.appendStartingElement = function(type, startChar, endChar, hashParams2) {
        closeLine(tune);
        var impliedNaturals;
        if (type === "key") {
          impliedNaturals = hashParams2.impliedNaturals;
          delete hashParams2.impliedNaturals;
          delete hashParams2.explicitAccidentals;
        }
        var hashParams = Object.assign({}, hashParams2);
        if (!tune.lines[tune.lineNum]) return;
        var staff = tune.lines[tune.lineNum].staff;
        if (!staff) return;
        if (staff.length <= tune.staffNum) {
          staff[tune.staffNum] = {};
          staff[tune.staffNum].clef = Object.assign({}, staff[0].clef);
          staff[tune.staffNum].key = Object.assign({}, staff[0].key);
          if (staff[0].meter)
            staff[tune.staffNum].meter = Object.assign({}, staff[0].meter);
          staff[tune.staffNum].workingClef = Object.assign({}, staff[0].workingClef);
          staff[tune.staffNum].voices = [[]];
        }
        if (type === "clef") {
          staff[tune.staffNum].workingClef = hashParams;
        }
        var voice = staff[tune.staffNum].voices[tune.voiceNum];
        for (var i2 = 0; i2 < voice.length; i2++) {
          if (voice[i2].el_type === "note" || voice[i2].el_type === "bar") {
            hashParams.el_type = type;
            hashParams.startChar = startChar;
            hashParams.endChar = endChar;
            if (impliedNaturals)
              hashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);
            voice.push(hashParams);
            return;
          }
          if (voice[i2].el_type === type) {
            hashParams.el_type = type;
            hashParams.startChar = startChar;
            hashParams.endChar = endChar;
            if (impliedNaturals)
              hashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);
            voice[i2] = hashParams;
            return;
          }
        }
        staff[tune.staffNum][type] = hashParams2;
      };
      this.addSubtitle = function(str, info) {
        pushLine(tune, { subtitle: { text: str, startChar: info.startChar, endChar: info.endChar } });
      };
      this.addSpacing = function(num) {
        tune.vskipPending = num;
      };
      this.addNewPage = function(num) {
        pushLine(tune, { newpage: num });
      };
      this.addSeparator = function(spaceAbove, spaceBelow, lineLength, info) {
        pushLine(tune, { separator: { spaceAbove: Math.round(spaceAbove), spaceBelow: Math.round(spaceBelow), lineLength: Math.round(lineLength), startChar: info.startChar, endChar: info.endChar } });
      };
      this.addText = function(str, info) {
        pushLine(tune, { text: { text: str, startChar: info.startChar, endChar: info.endChar } });
      };
      this.addCentered = function(str) {
        pushLine(tune, { text: [{ text: str, center: true }] });
      };
      this.changeVoiceScale = function(scale) {
        self.appendElement("scale", null, null, { size: scale });
      };
      this.changeVoiceColor = function(color) {
        self.appendElement("color", null, null, { color });
      };
      this.startNewLine = function(params) {
        closeLine(tune);
        if (params.currentVoiceName) {
          currentVoiceName = params.currentVoiceName;
          voiceDefs[params.currentVoiceName] = params;
        }
        if (tune.lines[tune.lineNum] === void 0) createLine(self, tune, params);
        else if (tune.lines[tune.lineNum].staff === void 0) {
          tune.lineNum++;
          this.startNewLine(params);
        } else if (tune.lines[tune.lineNum].staff[tune.staffNum] === void 0) createStaff(self, tune, params);
        else if (tune.lines[tune.lineNum].staff[tune.staffNum].voices[tune.voiceNum] === void 0) createVoice(self, tune, params);
        else if (!containsNotes(tune.lines[tune.lineNum].staff[tune.staffNum].voices[tune.voiceNum])) {
          if (params.part)
            self.appendElement("part", params.part.startChar, params.part.endChar, { title: params.part.title });
        } else {
          tune.lineNum++;
          this.startNewLine(params);
        }
      };
      this.setRunningFont = function(type, font) {
        tune.runningFonts[type] = font;
      };
      this.setBarNumberImmediate = function(barNumber) {
        var currentVoice = this.getCurrentVoice();
        if (currentVoice && currentVoice.length > 0) {
          var lastElement = currentVoice[currentVoice.length - 1];
          if (lastElement.el_type === "bar") {
            if (lastElement.barNumber !== void 0)
              lastElement.barNumber = barNumber;
          } else
            return barNumber - 1;
        }
        return barNumber;
      };
      this.hasBeginMusic = function() {
        for (var i2 = 0; i2 < tune.lines.length; i2++) {
          if (tune.lines[i2].staff)
            return true;
        }
        return false;
      };
      this.isFirstLine = function(index) {
        for (var i2 = index - 1; i2 >= 0; i2--) {
          if (tune.lines[i2].staff !== void 0) return false;
        }
        return true;
      };
      this.getCurrentVoice = function() {
        var currLine = getPrevMusicLine(tune.lines, tune.lineNum);
        if (!currLine)
          return null;
        var currStaff = currLine.staff[tune.staffNum];
        if (!currStaff)
          return null;
        if (currStaff.voices[tune.voiceNum] !== void 0)
          return currStaff.voices[tune.voiceNum];
        else return null;
      };
      this.setCurrentVoice = function(staffNum, voiceNum, name) {
        tune.staffNum = staffNum;
        tune.voiceNum = voiceNum;
        currentVoiceName = name;
        for (var i2 = 0; i2 < tune.lines.length; i2++) {
          if (tune.lines[i2].staff) {
            if (tune.lines[i2].staff[staffNum] === void 0 || tune.lines[i2].staff[staffNum].voices[voiceNum] === void 0 || !containsNotes(tune.lines[i2].staff[staffNum].voices[voiceNum])) {
              tune.lineNum = i2;
              if (!tune.lines[i2].staff[staffNum] || !!tune.lines[i2].staff[staffNum].voices[voiceNum]) return true;
              return false;
            }
          }
        }
        tune.lineNum = i2;
        return false;
      };
      this.addMetaText = function(key, value, info) {
        if (tune.metaText[key] === void 0) {
          tune.metaText[key] = value;
          tune.metaTextInfo[key] = info;
        } else {
          if (typeof tune.metaText[key] === "string" && typeof value === "string")
            tune.metaText[key] += "\n" + value;
          else {
            if (tune.metaText[key] === "string")
              tune.metaText[key] = [{ text: tune.metaText[key] }];
            if (typeof value === "string")
              value = [{ text: value }];
            tune.metaText[key] = tune.metaText[key].concat(value);
          }
          tune.metaTextInfo[key].endChar = info.endChar;
        }
      };
      this.addMetaTextArray = function(key, value, info) {
        if (tune.metaText[key] === void 0) {
          tune.metaText[key] = [value];
          tune.metaTextInfo[key] = info;
        } else {
          tune.metaText[key].push(value);
          tune.metaTextInfo[key].endChar = info.endChar;
        }
      };
      this.addMetaTextObj = function(key, value, info) {
        tune.metaText[key] = value;
        tune.metaTextInfo[key] = info;
      };
    };
    function isArrayOfStrings(arr) {
      if (!arr) return false;
      if (typeof arr === "string") return false;
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (typeof arr[i2] !== "string")
          return false;
      }
      return true;
    }
    function simplifyMetaText(tune) {
      if (isArrayOfStrings(tune.metaText.notes))
        tune.metaText.notes = tune.metaText.notes.join("\n");
      if (isArrayOfStrings(tune.metaText.history))
        tune.metaText.history = tune.metaText.history.join("\n");
    }
    function resolveOverlays(tune) {
      var madeChanges = false;
      var durationsPerLines = [];
      for (var i2 = 0; i2 < tune.lines.length; i2++) {
        var line = tune.lines[i2];
        if (line.staff) {
          for (var j = 0; j < line.staff.length; j++) {
            var staff = line.staff[j];
            var overlayVoice = [];
            for (var k = 0; k < staff.voices.length; k++) {
              var voice = staff.voices[k];
              overlayVoice.push({ hasOverlay: false, voice: [], snip: [] });
              durationsPerLines[i2] = 0;
              var durationThisBar = 0;
              var inOverlay = false;
              var overlayDuration = 0;
              var snipStart = -1;
              for (var kk = 0; kk < voice.length; kk++) {
                var event = voice[kk];
                if (event.el_type === "overlay" && !inOverlay) {
                  madeChanges = true;
                  inOverlay = true;
                  snipStart = kk;
                  overlayVoice[k].hasOverlay = true;
                  if (overlayDuration === 0)
                    overlayDuration = durationsPerLines[i2];
                  for (var ii = 0; ii < i2; ii++) {
                    if (durationsPerLines[ii] && tune.lines[ii].staff && staff.voices.length >= tune.lines[ii].staff[0].voices.length) {
                      tune.lines[ii].staff[0].voices.push([{
                        el_type: "note",
                        duration: durationsPerLines[ii],
                        rest: { type: "invisible" },
                        startChar: event.startChar,
                        endChar: event.endChar
                      }]);
                    }
                  }
                } else if (event.el_type === "bar") {
                  if (inOverlay) {
                    inOverlay = false;
                    overlayVoice[k].snip.push({ start: snipStart, len: kk - snipStart });
                    overlayVoice[k].voice.push(event);
                  } else {
                    if (durationThisBar > 0)
                      overlayVoice[k].voice.push({ el_type: "note", duration: durationThisBar, rest: { type: "invisible" }, startChar: event.startChar, endChar: event.endChar });
                    overlayVoice[k].voice.push(event);
                  }
                  durationThisBar = 0;
                } else if (event.el_type === "note") {
                  if (inOverlay) {
                    overlayVoice[k].voice.push(event);
                  } else {
                    durationThisBar += event.duration;
                    durationsPerLines[i2] += event.duration;
                  }
                } else if (event.el_type === "scale" || event.el_type === "stem" || event.el_type === "overlay" || event.el_type === "style" || event.el_type === "transpose" || event.el_type === "color") {
                  overlayVoice[k].voice.push(event);
                }
              }
              if (overlayVoice[k].hasOverlay && overlayVoice[k].snip.length === 0) {
                overlayVoice[k].snip.push({ start: snipStart, len: voice.length - snipStart });
              }
            }
            for (k = 0; k < overlayVoice.length; k++) {
              var ov = overlayVoice[k];
              if (ov.hasOverlay) {
                ov.voice.splice(0, 0, { el_type: "stem", direction: "down" });
                staff.voices.push(ov.voice);
                for (var kkk = ov.snip.length - 1; kkk >= 0; kkk--) {
                  var snip = ov.snip[kkk];
                  staff.voices[k].splice(snip.start, snip.len);
                  staff.voices[k].splice(snip.start + 1, 0, { el_type: "stem", direction: "auto" });
                  var indexOfLastBar = findLastBar(staff.voices[k], snip.start);
                  staff.voices[k].splice(indexOfLastBar, 0, { el_type: "stem", direction: "up" });
                }
                for (kkk = 0; kkk < staff.voices[staff.voices.length - 1].length; kkk++) {
                  staff.voices[staff.voices.length - 1][kkk] = Object.assign({}, staff.voices[staff.voices.length - 1][kkk]);
                  var el = staff.voices[staff.voices.length - 1][kkk];
                  if (el.el_type === "bar" && el.startEnding) {
                    delete el.startEnding;
                  }
                  if (el.el_type === "bar" && el.endEnding)
                    delete el.endEnding;
                }
              }
            }
          }
        }
      }
      return madeChanges;
    }
    function findLastBar(voice, start) {
      for (var i2 = start - 1; i2 > 0 && voice[i2].el_type !== "bar"; i2--) {
      }
      return i2;
    }
    function fixTitles(lines) {
      var firstMusicLine = true;
      for (var i2 = 0; i2 < lines.length; i2++) {
        var line = lines[i2];
        if (line.staff) {
          for (var j = 0; j < line.staff.length; j++) {
            var staff = line.staff[j];
            if (staff.title) {
              var hasATitle = false;
              for (var k = 0; k < staff.title.length; k++) {
                if (staff.title[k]) {
                  staff.title[k] = firstMusicLine ? staff.title[k].name : staff.title[k].subname;
                  if (staff.title[k])
                    hasATitle = true;
                  else
                    staff.title[k] = "";
                } else
                  staff.title[k] = "";
              }
              if (!hasATitle)
                delete staff.title;
            }
          }
          firstMusicLine = false;
        }
      }
    }
    function cleanUpSlursInLine(line, staffNum, voiceNum, currSlur) {
      if (!currSlur[staffNum])
        currSlur[staffNum] = [];
      if (!currSlur[staffNum][voiceNum])
        currSlur[staffNum][voiceNum] = [];
      var x;
      var addEndSlur = function(obj, num, chordPos) {
        if (currSlur[staffNum][voiceNum][chordPos] === void 0) {
          for (x = 0; x < currSlur[staffNum][voiceNum].length; x++) {
            if (currSlur[staffNum][voiceNum][x] !== void 0) {
              chordPos = x;
              break;
            }
          }
          if (currSlur[staffNum][voiceNum][chordPos] === void 0) {
            var offNum = chordPos * 100 + 1;
            obj.endSlur.forEach(function(x2) {
              if (offNum === x2) --offNum;
            });
            currSlur[staffNum][voiceNum][chordPos] = [offNum];
          }
        }
        var slurNum2;
        for (var i3 = 0; i3 < num; i3++) {
          slurNum2 = currSlur[staffNum][voiceNum][chordPos].pop();
          obj.endSlur.push(slurNum2);
        }
        if (currSlur[staffNum][voiceNum][chordPos].length === 0)
          delete currSlur[staffNum][voiceNum][chordPos];
        return slurNum2;
      };
      var addStartSlur = function(obj, num, chordPos, usedNums2) {
        obj.startSlur = [];
        if (currSlur[staffNum][voiceNum][chordPos] === void 0) {
          currSlur[staffNum][voiceNum][chordPos] = [];
        }
        var nextNum = chordPos * 100 + 1;
        for (var i3 = 0; i3 < num; i3++) {
          if (usedNums2) {
            usedNums2.forEach(function(x2) {
              if (nextNum === x2) ++nextNum;
            });
            usedNums2.forEach(function(x2) {
              if (nextNum === x2) ++nextNum;
            });
            usedNums2.forEach(function(x2) {
              if (nextNum === x2) ++nextNum;
            });
          }
          currSlur[staffNum][voiceNum][chordPos].forEach(function(x2) {
            if (nextNum === x2) ++nextNum;
          });
          currSlur[staffNum][voiceNum][chordPos].forEach(function(x2) {
            if (nextNum === x2) ++nextNum;
          });
          currSlur[staffNum][voiceNum][chordPos].push(nextNum);
          obj.startSlur.push({ label: nextNum });
          if (obj.dottedSlur) {
            obj.startSlur[obj.startSlur.length - 1].style = "dotted";
            delete obj.dottedSlur;
          }
          nextNum++;
        }
      };
      for (var i2 = 0; i2 < line.length; i2++) {
        var el = line[i2];
        if (el.el_type === "note") {
          if (el.gracenotes) {
            for (var g = 0; g < el.gracenotes.length; g++) {
              if (el.gracenotes[g].endSlur) {
                var gg = el.gracenotes[g].endSlur;
                el.gracenotes[g].endSlur = [];
                for (var ggg = 0; ggg < gg; ggg++)
                  addEndSlur(el.gracenotes[g], 1, 20);
              }
              if (el.gracenotes[g].startSlur) {
                x = el.gracenotes[g].startSlur;
                addStartSlur(el.gracenotes[g], x, 20);
              }
            }
          }
          if (el.endSlur) {
            x = el.endSlur;
            el.endSlur = [];
            addEndSlur(el, x, 0);
          }
          if (el.startSlur) {
            x = el.startSlur;
            addStartSlur(el, x, 0);
          }
          if (el.pitches) {
            var usedNums = [];
            for (var p = 0; p < el.pitches.length; p++) {
              if (el.pitches[p].endSlur) {
                var k = el.pitches[p].endSlur;
                el.pitches[p].endSlur = [];
                for (var j = 0; j < k; j++) {
                  var slurNum = addEndSlur(el.pitches[p], 1, p + 1);
                  usedNums.push(slurNum);
                }
              }
            }
            for (p = 0; p < el.pitches.length; p++) {
              if (el.pitches[p].startSlur) {
                x = el.pitches[p].startSlur;
                addStartSlur(el.pitches[p], x, p + 1, usedNums);
              }
            }
            if (el.gracenotes && el.pitches[0].endSlur && el.pitches[0].endSlur[0] === 100 && el.pitches[0].startSlur) {
              if (el.gracenotes[0].endSlur)
                el.gracenotes[0].endSlur.push(el.pitches[0].startSlur[0].label);
              else
                el.gracenotes[0].endSlur = [el.pitches[0].startSlur[0].label];
              if (el.pitches[0].endSlur.length === 1)
                delete el.pitches[0].endSlur;
              else if (el.pitches[0].endSlur[0] === 100)
                el.pitches[0].endSlur.shift();
              else if (el.pitches[0].endSlur[el.pitches[0].endSlur.length - 1] === 100)
                el.pitches[0].endSlur.pop();
              if (currSlur[staffNum][voiceNum][1].length === 1)
                delete currSlur[staffNum][voiceNum][1];
              else
                currSlur[staffNum][voiceNum][1].pop();
            }
          }
        }
      }
    }
    function wrapMusicLines(lines, barsperstaff) {
      for (i = 0; i < lines.length; i++) {
        if (lines[i].staff !== void 0) {
          for (s = 0; s < lines[i].staff.length; s++) {
            var permanentItems = [];
            for (v = 0; v < lines[i].staff[s].voices.length; v++) {
              var voice = lines[i].staff[s].voices[v];
              var barNumThisLine = 0;
              for (var n = 0; n < voice.length; n++) {
                if (voice[n].el_type === "bar") {
                  barNumThisLine++;
                  if (barNumThisLine >= barsperstaff) {
                    if (n < voice.length - 1) {
                      var nextLine = getNextMusicLine(lines, i);
                      if (!nextLine) {
                        var cp = JSON.parse(JSON.stringify(lines[i]));
                        lines.push(Object.assign({}, cp));
                        nextLine = lines[lines.length - 1];
                        for (var ss = 0; ss < nextLine.staff.length; ss++) {
                          for (var vv = 0; vv < nextLine.staff[ss].voices.length; vv++)
                            nextLine.staff[ss].voices[vv] = [];
                        }
                      }
                      var startElement = n + 1;
                      var section = lines[i].staff[s].voices[v].slice(startElement);
                      lines[i].staff[s].voices[v] = lines[i].staff[s].voices[v].slice(0, startElement);
                      nextLine.staff[s].voices[v] = permanentItems.concat(section.concat(nextLine.staff[s].voices[v]));
                      return true;
                    }
                  }
                } else if (!voice[n].duration) {
                  permanentItems.push(voice[n]);
                }
              }
            }
          }
        }
      }
      return false;
    }
    function getPrevMusicLine(lines, currentLine) {
      while (currentLine >= 0) {
        if (lines[currentLine].staff)
          return lines[currentLine];
        currentLine--;
      }
      return null;
    }
    function getNextMusicLine(lines, currentLine) {
      currentLine++;
      while (lines.length > currentLine) {
        if (lines[currentLine].staff)
          return lines[currentLine];
        currentLine++;
      }
      return null;
    }
    function getLastNote(tune) {
      if (!tune.lines[tune.lineNum]) return null;
      if (!tune.lines[tune.lineNum].staff) return null;
      if (!tune.lines[tune.lineNum].staff[tune.staffNum]) return null;
      var voice = tune.lines[tune.lineNum].staff[tune.staffNum].voices[tune.voiceNum];
      if (!voice) return null;
      for (var i2 = voice.length - 1; i2 >= 0; i2--) {
        var el = voice[i2];
        if (el.el_type === "note") {
          return el;
        }
      }
      return null;
    }
    function getDuration(el) {
      if (el.duration) return el.duration;
      return 0;
    }
    function closeLine(tune) {
      if (tune.potentialStartBeam && tune.potentialEndBeam) {
        tune.potentialStartBeam.startBeam = true;
        tune.potentialEndBeam.endBeam = true;
      }
      delete tune.potentialStartBeam;
      delete tune.potentialEndBeam;
    }
    function containsNotes(voice) {
      for (var i2 = 0; i2 < voice.length; i2++) {
        if (voice[i2].el_type === "note" || voice[i2].el_type === "bar")
          return true;
      }
      return false;
    }
    function containsNotesStrict(voice) {
      for (var i2 = 0; i2 < voice.length; i2++) {
        if (voice[i2].el_type === "note" && (voice[i2].rest === void 0 || voice[i2].chord !== void 0))
          return true;
      }
      return false;
    }
    function pushLine(tune, hash) {
      if (tune.vskipPending) {
        hash.vskip = tune.vskipPending;
        delete tune.vskipPending;
      }
      tune.lines.push(hash);
    }
    function pushNote(self, tune, hp, voiceDefs, currentVoiceName) {
      var currStaff = tune.lines[tune.lineNum].staff[tune.staffNum];
      if (hp.pitches !== void 0) {
        var mid = currStaff.workingClef.verticalPos;
        hp.pitches.forEach(function(p) {
          p.verticalPos = p.pitch - mid;
        });
      }
      if (hp.gracenotes !== void 0) {
        var mid2 = currStaff.workingClef.verticalPos;
        hp.gracenotes.forEach(function(p) {
          p.verticalPos = p.pitch - mid2;
        });
      }
      if (currStaff.voices.length <= tune.voiceNum) {
        if (!voiceDefs[currentVoiceName])
          voiceDefs[currentVoiceName] = {};
        createVoice(self, tune, voiceDefs[currentVoiceName]);
      }
      currStaff.voices[tune.voiceNum].push(hp);
    }
    function endBeamHere(hashParams, tune) {
      tune.potentialStartBeam.startBeam = true;
      hashParams.endBeam = true;
      delete tune.potentialStartBeam;
      delete tune.potentialEndBeam;
    }
    function endBeamLast(tune) {
      if (tune.potentialStartBeam !== void 0 && tune.potentialEndBeam !== void 0) {
        tune.potentialStartBeam.startBeam = true;
        tune.potentialEndBeam.endBeam = true;
      }
      delete tune.potentialStartBeam;
      delete tune.potentialEndBeam;
    }
    function setLineFont(tune, type, font) {
      if (tune.runningFonts[type]) {
        var isDifferent = false;
        var keys = Object.keys(font);
        for (var i2 = 0; i2 < keys.length; i2++) {
          if (tune.runningFonts[type][keys[i2]] !== font[keys[i2]])
            isDifferent = true;
        }
        if (isDifferent) {
          tune.lines[tune.lineNum].staff[tune.staffNum][type] = font;
        }
      }
      tune.runningFonts[type] = font;
    }
    function createVoice(self, tune, params) {
      var thisStaff = tune.lines[tune.lineNum].staff[tune.staffNum];
      thisStaff.voices[tune.voiceNum] = [];
      if (!thisStaff.title)
        thisStaff.title = [];
      thisStaff.title[tune.voiceNum] = { name: params.name, subname: params.subname };
      if (params.style)
        self.appendElement("style", null, null, { head: params.style });
      if (params.stem)
        self.appendElement("stem", null, null, { direction: params.stem });
      else if (tune.voiceNum > 0) {
        if (thisStaff.voices[0] !== void 0) {
          var found = false;
          for (var i2 = 0; i2 < thisStaff.voices[0].length; i2++) {
            if (thisStaff.voices[0].el_type === "stem")
              found = true;
          }
          if (!found) {
            var stem = { el_type: "stem", direction: "up" };
            thisStaff.voices[0].splice(0, 0, stem);
          }
        }
        self.appendElement("stem", null, null, { direction: "down" });
      }
      if (params.scale)
        self.appendElement("scale", null, null, { size: params.scale });
      if (params.color)
        self.appendElement("color", null, null, { color: params.color });
    }
    function createStaff(self, tune, params) {
      if (params.key && params.key.impliedNaturals) {
        params.key.accidentals = params.key.accidentals.concat(params.key.impliedNaturals);
        delete params.key.impliedNaturals;
      }
      tune.lines[tune.lineNum].staff[tune.staffNum] = { voices: [], clef: params.clef, key: params.key, workingClef: params.clef };
      var staff = tune.lines[tune.lineNum].staff[tune.staffNum];
      if (params.stafflines !== void 0) {
        staff.clef.stafflines = params.stafflines;
        staff.workingClef.stafflines = params.stafflines;
      }
      if (params.staffscale) {
        staff.staffscale = params.staffscale;
      }
      if (params.annotationfont) setLineFont(tune, "annotationfont", params.annotationfont);
      if (params.gchordfont) setLineFont(tune, "gchordfont", params.gchordfont);
      if (params.tripletfont) setLineFont(tune, "tripletfont", params.tripletfont);
      if (params.vocalfont) setLineFont(tune, "vocalfont", params.vocalfont);
      if (params.bracket) staff.bracket = params.bracket;
      if (params.brace) staff.brace = params.brace;
      if (params.connectBarLines) staff.connectBarLines = params.connectBarLines;
      if (params.barNumber) staff.barNumber = params.barNumber;
      createVoice(self, tune, params);
      if (params.part)
        self.appendElement("part", params.part.startChar, params.part.endChar, { title: params.part.title });
      if (params.meter !== void 0) staff.meter = params.meter;
      if (tune.vskipPending) {
        tune.lines[tune.lineNum].vskip = tune.vskipPending;
        delete tune.vskipPending;
      }
    }
    function createLine(self, tune, params) {
      tune.lines[tune.lineNum] = { staff: [] };
      createStaff(self, tune, params);
    }
    module.exports = TuneBuilder;
  }
});

// node_modules/abcjs/src/parse/abc_parse.js
var require_abc_parse = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseDirective = require_abc_parse_directive();
    var ParseHeader = require_abc_parse_header();
    var ParseMusic = require_abc_parse_music();
    var Tokenizer = require_abc_tokenizer();
    var wrap = require_wrap_lines();
    var Tune = require_abc_tune();
    var TuneBuilder = require_tune_builder();
    var Parse = function() {
      "use strict";
      var tune = new Tune();
      var tuneBuilder = new TuneBuilder(tune);
      var tokenizer;
      var wordsContinuation = "";
      var symbolContinuation = "";
      this.getTune = function() {
        var t = {
          formatting: tune.formatting,
          lines: tune.lines,
          media: tune.media,
          metaText: tune.metaText,
          metaTextInfo: tune.metaTextInfo,
          version: tune.version,
          addElementToEvents: tune.addElementToEvents,
          addUsefulCallbackInfo: tune.addUsefulCallbackInfo,
          getTotalTime: tune.getTotalTime,
          getTotalBeats: tune.getTotalBeats,
          getBarLength: tune.getBarLength,
          getBeatLength: tune.getBeatLength,
          getBeatsPerMeasure: tune.getBeatsPerMeasure,
          getBpm: tune.getBpm,
          getMeter: tune.getMeter,
          getMeterFraction: tune.getMeterFraction,
          getPickupLength: tune.getPickupLength,
          getKeySignature: tune.getKeySignature,
          getElementFromChar: tune.getElementFromChar,
          makeVoicesArray: tune.makeVoicesArray,
          millisecondsPerMeasure: tune.millisecondsPerMeasure,
          setupEvents: tune.setupEvents,
          setTiming: tune.setTiming,
          setUpAudio: tune.setUpAudio,
          deline: tune.deline,
          findSelectableElement: tune.findSelectableElement,
          getSelectableArray: tune.getSelectableArray
        };
        if (tune.lineBreaks)
          t.lineBreaks = tune.lineBreaks;
        if (tune.visualTranspose)
          t.visualTranspose = tune.visualTranspose;
        return t;
      };
      function addPositioning(el, type, value) {
        if (!el.positioning) el.positioning = {};
        el.positioning[type] = value;
      }
      function addFont(el, type, value) {
        if (!el.fonts) el.fonts = {};
        el.fonts[type] = value;
      }
      var multilineVars = {
        reset: function() {
          for (var property in this) {
            if (this.hasOwnProperty(property) && typeof this[property] !== "function") {
              delete this[property];
            }
          }
          this.iChar = 0;
          this.key = { accidentals: [], root: "none", acc: "", mode: "" };
          this.meter = null;
          this.origMeter = null;
          this.hasMainTitle = false;
          this.default_length = 0.125;
          this.clef = { type: "treble", verticalPos: 0 };
          this.octave = 0;
          this.next_note_duration = 0;
          this.start_new_line = true;
          this.is_in_header = true;
          this.partForNextLine = {};
          this.tempoForNextLine = [];
          this.havent_set_length = true;
          this.voices = {};
          this.staves = [];
          this.macros = {};
          this.currBarNumber = 1;
          this.barCounter = {};
          this.ignoredDecorations = [];
          this.score_is_present = false;
          this.inEnding = false;
          this.inTie = [];
          this.inTieChord = {};
          this.vocalPosition = "auto";
          this.dynamicPosition = "auto";
          this.chordPosition = "auto";
          this.ornamentPosition = "auto";
          this.volumePosition = "auto";
          this.openSlurs = [];
          this.freegchord = false;
          this.endingHoldOver = {};
        },
        differentFont: function(type, defaultFonts) {
          if (this[type].decoration !== defaultFonts[type].decoration) return true;
          if (this[type].face !== defaultFonts[type].face) return true;
          if (this[type].size !== defaultFonts[type].size) return true;
          if (this[type].style !== defaultFonts[type].style) return true;
          if (this[type].weight !== defaultFonts[type].weight) return true;
          return false;
        },
        addFormattingOptions: function(el, defaultFonts, elType) {
          if (elType === "note") {
            if (this.vocalPosition !== "auto") addPositioning(el, "vocalPosition", this.vocalPosition);
            if (this.dynamicPosition !== "auto") addPositioning(el, "dynamicPosition", this.dynamicPosition);
            if (this.chordPosition !== "auto") addPositioning(el, "chordPosition", this.chordPosition);
            if (this.ornamentPosition !== "auto") addPositioning(el, "ornamentPosition", this.ornamentPosition);
            if (this.volumePosition !== "auto") addPositioning(el, "volumePosition", this.volumePosition);
            if (this.differentFont("annotationfont", defaultFonts)) addFont(el, "annotationfont", this.annotationfont);
            if (this.differentFont("gchordfont", defaultFonts)) addFont(el, "gchordfont", this.gchordfont);
            if (this.differentFont("vocalfont", defaultFonts)) addFont(el, "vocalfont", this.vocalfont);
            if (this.differentFont("tripletfont", defaultFonts)) addFont(el, "tripletfont", this.tripletfont);
          } else if (elType === "bar") {
            if (this.dynamicPosition !== "auto") addPositioning(el, "dynamicPosition", this.dynamicPosition);
            if (this.chordPosition !== "auto") addPositioning(el, "chordPosition", this.chordPosition);
            if (this.ornamentPosition !== "auto") addPositioning(el, "ornamentPosition", this.ornamentPosition);
            if (this.volumePosition !== "auto") addPositioning(el, "volumePosition", this.volumePosition);
            if (this.differentFont("measurefont", defaultFonts)) addFont(el, "measurefont", this.measurefont);
            if (this.differentFont("repeatfont", defaultFonts)) addFont(el, "repeatfont", this.repeatfont);
          }
        },
        duplicateStartEndingHoldOvers: function() {
          this.endingHoldOver = {
            inTie: [],
            inTieChord: {}
          };
          for (var i2 = 0; i2 < this.inTie.length; i2++) {
            this.endingHoldOver.inTie.push([]);
            if (this.inTie[i2]) {
              for (var j = 0; j < this.inTie[i2].length; j++) {
                this.endingHoldOver.inTie[i2].push(this.inTie[i2][j]);
              }
            }
          }
          for (var key in this.inTieChord) {
            if (this.inTieChord.hasOwnProperty(key))
              this.endingHoldOver.inTieChord[key] = this.inTieChord[key];
          }
        },
        restoreStartEndingHoldOvers: function() {
          if (!this.endingHoldOver.inTie)
            return;
          this.inTie = [];
          this.inTieChord = {};
          for (var i2 = 0; i2 < this.endingHoldOver.inTie.length; i2++) {
            this.inTie.push([]);
            for (var j = 0; j < this.endingHoldOver.inTie[i2].length; j++) {
              this.inTie[i2].push(this.endingHoldOver.inTie[i2][j]);
            }
          }
          for (var key in this.endingHoldOver.inTieChord) {
            if (this.endingHoldOver.inTieChord.hasOwnProperty(key))
              this.inTieChord[key] = this.endingHoldOver.inTieChord[key];
          }
        }
      };
      var addWarning = function(str) {
        if (!multilineVars.warnings)
          multilineVars.warnings = [];
        multilineVars.warnings.push(str);
      };
      var addWarningObject = function(warningObject) {
        if (!multilineVars.warningObjects)
          multilineVars.warningObjects = [];
        multilineVars.warningObjects.push(warningObject);
      };
      var encode = function(str) {
        var ret = str.replace(/\x12/g, " ");
        ret = ret.replace(/&/g, "&amp;");
        ret = ret.replace(/</g, "&lt;");
        return ret.replace(/>/g, "&gt;");
      };
      var warn = function(str, line, col_num) {
        if (!line) line = " ";
        var bad_char = line[col_num];
        if (bad_char === " " || !bad_char)
          bad_char = "SPACE";
        var clean_line = encode(line.substring(col_num - 64, col_num)) + '<span style="text-decoration:underline;font-size:1.3em;font-weight:bold;">' + bad_char + "</span>" + encode(line.substring(col_num + 1).substring(0, 64));
        addWarning("Music Line:" + tokenizer.lineIndex + ":" + (col_num + 1) + ": " + str + ":  " + clean_line);
        addWarningObject({ message: str, line, startChar: multilineVars.iChar + col_num, column: col_num });
      };
      var header;
      var music;
      this.getWarnings = function() {
        return multilineVars.warnings;
      };
      this.getWarningObjects = function() {
        return multilineVars.warningObjects;
      };
      var addWords = function(line, words) {
        if (words.indexOf("") >= 0) {
          wordsContinuation += words;
          return;
        }
        words = wordsContinuation + words;
        wordsContinuation = "";
        if (!line) {
          warn("Can't add words before the first line of music", line, 0);
          return;
        }
        words = parseCommon.strip(words);
        if (words[words.length - 1] !== "-")
          words = words + " ";
        var word_list = [];
        var last_divider = 0;
        var replace = false;
        var addWord = function(i3) {
          var word = parseCommon.strip(words.substring(last_divider, i3));
          word = word.replace(/\\([-_*|~])/g, "$1");
          last_divider = i3 + 1;
          if (word.length > 0) {
            if (replace)
              word = word.replace(/~/g, " ");
            var div = words[i3];
            if (div !== "_" && div !== "-")
              div = " ";
            word_list.push({ syllable: tokenizer.translateString(word), divider: div });
            replace = false;
            return true;
          }
          return false;
        };
        var escNext = false;
        for (var i2 = 0; i2 < words.length; i2++) {
          switch (words[i2]) {
            case " ":
            case "":
              addWord(i2);
              break;
            case "-":
              if (!escNext && !addWord(i2) && word_list.length > 0) {
                parseCommon.last(word_list).divider = "-";
                word_list.push({ skip: true, to: "next" });
              }
              break;
            case "_":
              if (!escNext) {
                addWord(i2);
                word_list.push({ skip: true, to: "slur" });
              }
              break;
            case "*":
              if (!escNext) {
                addWord(i2);
                word_list.push({ skip: true, to: "next" });
              }
              break;
            case "|":
              if (!escNext) {
                addWord(i2);
                word_list.push({ skip: true, to: "bar" });
              }
              break;
            case "~":
              if (!escNext) {
                replace = true;
              }
              break;
          }
          escNext = words[i2] === "\\";
        }
        var inSlur = false;
        line.forEach(function(el) {
          if (word_list.length !== 0) {
            if (word_list[0].skip) {
              switch (word_list[0].to) {
                case "next":
                  if (el.el_type === "note" && el.pitches !== null && !inSlur) word_list.shift();
                  break;
                case "slur":
                  if (el.el_type === "note" && el.pitches !== null) word_list.shift();
                  break;
                case "bar":
                  if (el.el_type === "bar") word_list.shift();
                  break;
              }
              if (el.el_type !== "bar") {
                if (el.lyric === void 0)
                  el.lyric = [{ syllable: "", divider: " " }];
                else
                  el.lyric.push({ syllable: "", divider: " " });
              }
            } else {
              if (el.el_type === "note" && el.rest === void 0 && !inSlur) {
                var lyric = word_list.shift();
                if (lyric.syllable)
                  lyric.syllable = lyric.syllable.replace(/ +/g, " ");
                if (el.lyric === void 0)
                  el.lyric = [lyric];
                else
                  el.lyric.push(lyric);
              }
            }
          }
        });
      };
      var addSymbols = function(line, words) {
        if (words.indexOf("") >= 0) {
          symbolContinuation += words;
          return;
        }
        words = symbolContinuation + words;
        symbolContinuation = "";
        if (!line) {
          warn("Can't add symbols before the first line of music", line, 0);
          return;
        }
        words = parseCommon.strip(words);
        if (words[words.length - 1] !== "-")
          words = words + " ";
        var word_list = [];
        var last_divider = 0;
        var replace = false;
        var addWord = function(i3) {
          var word = parseCommon.strip(words.substring(last_divider, i3));
          last_divider = i3 + 1;
          if (word.length > 0) {
            if (replace)
              word = word.replace(/~/g, " ");
            var div = words[i3];
            if (div !== "_" && div !== "-")
              div = " ";
            word_list.push({ syllable: tokenizer.translateString(word), divider: div });
            replace = false;
            return true;
          }
          return false;
        };
        for (var i2 = 0; i2 < words.length; i2++) {
          switch (words[i2]) {
            case " ":
            case "":
              addWord(i2);
              break;
            case "-":
              if (!addWord(i2) && word_list.length > 0) {
                parseCommon.last(word_list).divider = "-";
                word_list.push({ skip: true, to: "next" });
              }
              break;
            case "_":
              addWord(i2);
              word_list.push({ skip: true, to: "slur" });
              break;
            case "*":
              addWord(i2);
              word_list.push({ skip: true, to: "next" });
              break;
            case "|":
              addWord(i2);
              word_list.push({ skip: true, to: "bar" });
              break;
            case "~":
              replace = true;
              break;
          }
        }
        var inSlur = false;
        line.forEach(function(el) {
          if (word_list.length !== 0) {
            if (word_list[0].skip) {
              switch (word_list[0].to) {
                case "next":
                  if (el.el_type === "note" && el.pitches !== null && !inSlur) word_list.shift();
                  break;
                case "slur":
                  if (el.el_type === "note" && el.pitches !== null) word_list.shift();
                  break;
                case "bar":
                  if (el.el_type === "bar") word_list.shift();
                  break;
              }
            } else {
              if (el.el_type === "note" && el.rest === void 0 && !inSlur) {
                var lyric = word_list.shift();
                if (el.lyric === void 0)
                  el.lyric = [lyric];
                else
                  el.lyric.push(lyric);
              }
            }
          }
        });
      };
      var parseLine = function(line) {
        if (parseCommon.startsWith(line, "%%")) {
          var err = parseDirective.addDirective(line.substring(2));
          if (err) warn(err, line, 2);
          return;
        }
        var i2 = line.indexOf("%");
        if (i2 >= 0)
          line = line.substring(0, i2);
        line = line.replace(/\s+$/, "");
        if (line.length === 0)
          return;
        if (wordsContinuation) {
          addWords(tuneBuilder.getCurrentVoice(), line.substring(2));
          return;
        }
        if (symbolContinuation) {
          addSymbols(tuneBuilder.getCurrentVoice(), line.substring(2));
          return;
        }
        if (line.length < 2 || line[1] !== ":" || music.lineContinuation) {
          music.parseMusic(line);
          return;
        }
        var ret = header.parseHeader(line);
        if (ret.regular)
          music.parseMusic(line);
        if (ret.newline)
          music.startNewLine();
        if (ret.words)
          addWords(tuneBuilder.getCurrentVoice(), line.substring(2));
        if (ret.symbols)
          addSymbols(tuneBuilder.getCurrentVoice(), line.substring(2));
      };
      function appendLastMeasure(voice, nextVoice) {
        voice.push({
          el_type: "hint"
        });
        for (var i2 = 0; i2 < nextVoice.length; i2++) {
          var element = nextVoice[i2];
          var hint = Object.assign({}, element);
          voice.push(hint);
          if (element.el_type === "bar")
            return;
        }
      }
      function addHintMeasure(staff, nextStaff) {
        for (var i2 = 0; i2 < staff.length; i2++) {
          var stave = staff[i2];
          var nextStave = nextStaff[i2];
          if (nextStave) {
            for (var j = 0; j < nextStave.voices.length; j++) {
              var nextVoice = nextStave.voices[j];
              var voice = stave.voices[j];
              if (voice) {
                appendLastMeasure(voice, nextVoice);
              }
            }
          }
        }
      }
      function addHintMeasures() {
        for (var i2 = 0; i2 < tune.lines.length; i2++) {
          var line = tune.lines[i2].staff;
          if (line) {
            var j = i2 + 1;
            while (j < tune.lines.length && tune.lines[j].staff === void 0)
              j++;
            if (j < tune.lines.length) {
              var nextLine = tune.lines[j].staff;
              addHintMeasure(line, nextLine);
            }
          }
        }
      }
      this.parse = function(strTune, switches, startPos) {
        if (!switches) switches = {};
        if (!startPos) startPos = 0;
        tune.reset();
        strTune = strTune.replace(/\r\n?/g, "\n") + "\n";
        var arr = strTune.split("\n\\");
        if (arr.length > 1) {
          for (var i2 = 1; i2 < arr.length; i2++) {
            while (arr[i2].length > 0 && arr[i2][0] !== "\n") {
              arr[i2] = arr[i2].substr(1);
              arr[i2 - 1] += " ";
            }
          }
          strTune = arr.join("  ");
        }
        strTune = strTune.replace(/\\([ \t]*)(%.*)*\n/g, function(all, backslash, comment) {
          var padding = comment ? Array(comment.length + 1).join(" ") : "";
          return backslash + "" + padding + "\n";
        });
        var lines = strTune.split("\n");
        if (parseCommon.last(lines).length === 0)
          lines.pop();
        tokenizer = new Tokenizer(lines, multilineVars);
        header = new ParseHeader(tokenizer, warn, multilineVars, tune, tuneBuilder);
        music = new ParseMusic(tokenizer, warn, multilineVars, tune, tuneBuilder, header);
        if (switches.print)
          tune.media = "print";
        multilineVars.reset();
        multilineVars.iChar = startPos;
        if (switches.visualTranspose) {
          multilineVars.globalTranspose = parseInt(switches.visualTranspose);
          if (multilineVars.globalTranspose === 0)
            multilineVars.globalTranspose = void 0;
          else
            tuneBuilder.setVisualTranspose(switches.visualTranspose);
        } else
          multilineVars.globalTranspose = void 0;
        if (switches.lineBreaks) {
          multilineVars.lineBreaks = switches.lineBreaks;
        }
        header.reset(tokenizer, warn, multilineVars, tune);
        try {
          if (switches.format) {
            parseDirective.globalFormatting(switches.format);
          }
          var line = tokenizer.nextLine();
          while (line) {
            if (switches.header_only && multilineVars.is_in_header === false)
              throw "normal_abort";
            if (switches.stop_on_warning && multilineVars.warnings)
              throw "normal_abort";
            var wasInHeader = multilineVars.is_in_header;
            parseLine(line);
            if (wasInHeader && !multilineVars.is_in_header) {
              tuneBuilder.setRunningFont("annotationfont", multilineVars.annotationfont);
              tuneBuilder.setRunningFont("gchordfont", multilineVars.gchordfont);
              tuneBuilder.setRunningFont("tripletfont", multilineVars.tripletfont);
              tuneBuilder.setRunningFont("vocalfont", multilineVars.vocalfont);
            }
            line = tokenizer.nextLine();
          }
          if (wordsContinuation) {
            addWords(tuneBuilder.getCurrentVoice(), "");
          }
          if (symbolContinuation) {
            addSymbols(tuneBuilder.getCurrentVoice(), "");
          }
          multilineVars.openSlurs = tuneBuilder.cleanUp(multilineVars.barsperstaff, multilineVars.staffnonote, multilineVars.openSlurs);
        } catch (err) {
          if (err !== "normal_abort")
            throw err;
        }
        var ph = 11 * 72;
        var pl = 8.5 * 72;
        switch (multilineVars.papersize) {
          //case "letter": ph = 11*72; pl = 8.5*72; break;
          case "legal":
            ph = 14 * 72;
            pl = 8.5 * 72;
            break;
          case "A4":
            ph = 11.7 * 72;
            pl = 8.3 * 72;
            break;
        }
        if (multilineVars.landscape) {
          var x = ph;
          ph = pl;
          pl = x;
        }
        if (!tune.formatting.pagewidth)
          tune.formatting.pagewidth = pl;
        if (!tune.formatting.pageheight)
          tune.formatting.pageheight = ph;
        if (switches.hint_measures) {
          addHintMeasures();
        }
        wrap.wrapLines(tune, multilineVars.lineBreaks, multilineVars.barNumbers);
      };
    };
    module.exports = Parse;
  }
});

// node_modules/abcjs/src/parse/abc_parse_book.js
var require_abc_parse_book = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_book.js"(exports, module) {
    var parseCommon = require_abc_common();
    var bookParser = function(book) {
      "use strict";
      var directives = "";
      var initialWhiteSpace = book.match(/(\s*)/);
      book = parseCommon.strip(book);
      var tuneStrings = book.split("\nX:");
      for (var i2 = 1; i2 < tuneStrings.length; i2++)
        tuneStrings[i2] = "X:" + tuneStrings[i2];
      var pos = initialWhiteSpace ? initialWhiteSpace[0].length : 0;
      var tunes = [];
      tuneStrings.forEach(function(tune) {
        tunes.push({ abc: tune, startPos: pos });
        pos += tune.length + 1;
      });
      if (tunes.length > 1 && !parseCommon.startsWith(tunes[0].abc, "X:")) {
        var dir = tunes.shift();
        var arrDir = dir.abc.split("\n");
        arrDir.forEach(function(line) {
          if (parseCommon.startsWith(line, "%%"))
            directives += line + "\n";
        });
      }
      var header = directives;
      tunes.forEach(function(tune) {
        var end = tune.abc.indexOf("\n\n");
        if (end > 0)
          tune.abc = tune.abc.substring(0, end);
        tune.pure = tune.abc;
        tune.abc = directives + tune.abc;
        tune.title = "";
        var title = tune.pure.split("T:");
        if (title.length > 1) {
          title = title[1].split("\n");
          tune.title = parseCommon.strip(title[0]);
        }
        var id = tune.pure.substring(2, tune.pure.indexOf("\n"));
        tune.id = parseCommon.strip(id);
      });
      return {
        header,
        tunes
      };
    };
    module.exports = bookParser;
  }
});

// node_modules/abcjs/src/tablatures/instruments/string-tablature.js
var require_string_tablature = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/string-tablature.js"(exports, module) {
    function StringTablature(numLines, lineSpace) {
      this.numLines = numLines;
      this.lineSpace = lineSpace;
      this.verticalSize = this.numLines * this.lineSpace;
      var pitch = 3;
      this.bar = {
        pitch,
        pitch2: lineSpace * numLines,
        height: 5
      };
    }
    StringTablature.prototype.bypass = function(line) {
      var voices = line.staffGroup.voices;
      if (voices.length > 0) {
        if (voices[0].isPercussion) return true;
      }
      return false;
    };
    StringTablature.prototype.setRelative = function(child, relative, first) {
      switch (child.type) {
        case "bar":
          relative.pitch = this.bar.pitch;
          relative.pitch2 = this.bar.pitch2;
          relative.height = this.height;
          break;
        case "symbol":
          var top = this.bar.pitch2 / 2;
          if (child.name == "dots.dot") {
            if (first) {
              relative.pitch = top;
              return false;
            } else {
              relative.pitch = top + this.lineSpace;
              return true;
            }
          }
          break;
      }
      return first;
    };
    module.exports = StringTablature;
  }
});

// node_modules/abcjs/src/write/creation/elements/voice-element.js
var require_voice_element = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/voice-element.js"(exports, module) {
    var VoiceElement = function VoiceElement2(voicenumber, voicetotal) {
      this.children = [];
      this.beams = [];
      this.otherchildren = [];
      this.w = 0;
      this.duplicate = false;
      this.voicenumber = voicenumber;
      this.voicetotal = voicetotal;
      this.bottom = 7;
      this.top = 7;
      this.specialY = {
        tempoHeightAbove: 0,
        partHeightAbove: 0,
        volumeHeightAbove: 0,
        dynamicHeightAbove: 0,
        endingHeightAbove: 0,
        chordHeightAbove: 0,
        lyricHeightAbove: 0,
        lyricHeightBelow: 0,
        chordHeightBelow: 0,
        volumeHeightBelow: 0,
        dynamicHeightBelow: 0
      };
    };
    VoiceElement.prototype.addChild = function(absElem) {
      if (absElem.type === "bar") {
        var firstItem = true;
        for (var i2 = 0; firstItem && i2 < this.children.length; i2++) {
          if (this.children[i2].type.indexOf("staff-extra") < 0 && this.children[i2].type !== "tempo")
            firstItem = false;
        }
        if (!firstItem) {
          this.beams.push("bar");
          this.otherchildren.push("bar");
        }
      }
      this.children[this.children.length] = absElem;
      this.setRange(absElem);
    };
    VoiceElement.prototype.setLimit = function(member, child) {
      var specialY = child.specialY;
      if (!specialY) specialY = child;
      if (!specialY[member]) return;
      if (!this.specialY[member])
        this.specialY[member] = specialY[member];
      else
        this.specialY[member] = Math.max(this.specialY[member], specialY[member]);
    };
    VoiceElement.prototype.adjustRange = function(child) {
      if (child.bottom !== void 0)
        this.bottom = Math.min(this.bottom, child.bottom);
      if (child.top !== void 0)
        this.top = Math.max(this.top, child.top);
    };
    VoiceElement.prototype.setRange = function(child) {
      this.adjustRange(child);
      this.setLimit("tempoHeightAbove", child);
      this.setLimit("partHeightAbove", child);
      this.setLimit("volumeHeightAbove", child);
      this.setLimit("dynamicHeightAbove", child);
      this.setLimit("endingHeightAbove", child);
      this.setLimit("chordHeightAbove", child);
      this.setLimit("lyricHeightAbove", child);
      this.setLimit("lyricHeightBelow", child);
      this.setLimit("chordHeightBelow", child);
      this.setLimit("volumeHeightBelow", child);
      this.setLimit("dynamicHeightBelow", child);
    };
    VoiceElement.prototype.addOther = function(child) {
      this.otherchildren.push(child);
      this.setRange(child);
    };
    VoiceElement.prototype.addBeam = function(child) {
      this.beams.push(child);
    };
    VoiceElement.prototype.setWidth = function(width) {
      this.w = width;
    };
    module.exports = VoiceElement;
  }
});

// node_modules/abcjs/src/write/helpers/set-class.js
var require_set_class = __commonJS({
  "node_modules/abcjs/src/write/helpers/set-class.js"(exports, module) {
    var setClass = function(elemset, addClass, removeClass, color) {
      if (!elemset)
        return;
      for (var i2 = 0; i2 < elemset.length; i2++) {
        var el = elemset[i2];
        var attr = el.getAttribute("highlight");
        if (!attr) attr = "fill";
        el.setAttribute(attr, color);
        var kls = el.getAttribute("class");
        if (!kls) kls = "";
        kls = kls.replace(removeClass, "");
        kls = kls.replace(addClass, "");
        if (addClass.length > 0) {
          if (kls.length > 0 && kls[kls.length - 1] !== " ") kls += " ";
          kls += addClass;
        }
        el.setAttribute("class", kls);
      }
    };
    module.exports = setClass;
  }
});

// node_modules/abcjs/src/write/interactive/highlight.js
var require_highlight = __commonJS({
  "node_modules/abcjs/src/write/interactive/highlight.js"(exports, module) {
    var setClass = require_set_class();
    var highlight = function(klass, color) {
      if (klass === void 0)
        klass = "abcjs-note_selected";
      if (color === void 0)
        color = "#ff0000";
      setClass(this.elemset, klass, "", color);
    };
    module.exports = highlight;
  }
});

// node_modules/abcjs/src/write/interactive/unhighlight.js
var require_unhighlight = __commonJS({
  "node_modules/abcjs/src/write/interactive/unhighlight.js"(exports, module) {
    var setClass = require_set_class();
    var unhighlight = function(klass, color) {
      if (klass === void 0)
        klass = "abcjs-note_selected";
      if (color === void 0)
        color = "#000000";
      setClass(this.elemset, "", klass, color);
    };
    module.exports = unhighlight;
  }
});

// node_modules/abcjs/src/write/creation/elements/absolute-element.js
var require_absolute_element = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/absolute-element.js"(exports, module) {
    var highlight = require_highlight();
    var unhighlight = require_unhighlight();
    var AbsoluteElement = function AbsoluteElement2(abcelem, duration, minspacing, type, tuneNumber, options) {
      if (!options)
        options = {};
      this.tuneNumber = tuneNumber;
      this.abcelem = abcelem;
      this.duration = duration;
      this.durationClass = options.durationClassOveride ? options.durationClassOveride : this.duration;
      this.minspacing = minspacing || 0;
      this.x = 0;
      this.children = [];
      this.heads = [];
      this.extra = [];
      this.extraw = 0;
      this.w = 0;
      this.right = [];
      this.invisible = false;
      this.bottom = void 0;
      this.top = void 0;
      this.type = type;
      this.fixed = { w: 0, t: void 0, b: void 0 };
      this.specialY = {
        tempoHeightAbove: 0,
        partHeightAbove: 0,
        volumeHeightAbove: 0,
        dynamicHeightAbove: 0,
        endingHeightAbove: 0,
        chordHeightAbove: 0,
        lyricHeightAbove: 0,
        lyricHeightBelow: 0,
        chordHeightBelow: 0,
        volumeHeightBelow: 0,
        dynamicHeightBelow: 0
      };
    };
    AbsoluteElement.prototype.getFixedCoords = function() {
      return { x: this.x, w: this.fixed.w, t: this.fixed.t, b: this.fixed.b };
    };
    AbsoluteElement.prototype.addExtra = function(extra) {
      this.fixed.w = Math.max(this.fixed.w, extra.dx + extra.w);
      if (this.fixed.t === void 0) this.fixed.t = extra.top;
      else this.fixed.t = Math.max(this.fixed.t, extra.top);
      if (this.fixed.b === void 0) this.fixed.b = extra.bottom;
      else this.fixed.b = Math.min(this.fixed.b, extra.bottom);
      if (extra.dx < this.extraw) this.extraw = extra.dx;
      this.extra[this.extra.length] = extra;
      this._addChild(extra);
    };
    AbsoluteElement.prototype.addHead = function(head) {
      if (head.dx < this.extraw) this.extraw = head.dx;
      this.heads[this.heads.length] = head;
      this.addRight(head);
    };
    AbsoluteElement.prototype.addRight = function(right) {
      this.fixed.w = Math.max(this.fixed.w, right.dx + right.w);
      if (right.top !== void 0) {
        if (this.fixed.t === void 0) this.fixed.t = right.top;
        else this.fixed.t = Math.max(this.fixed.t, right.top);
      }
      if (right.bottom !== void 0) {
        if (this.fixed.b === void 0) this.fixed.b = right.bottom;
        else this.fixed.b = Math.min(this.fixed.b, right.bottom);
      }
      if (right.dx + right.w > this.w) this.w = right.dx + right.w;
      this.right[this.right.length] = right;
      this._addChild(right);
    };
    AbsoluteElement.prototype.addFixed = function(elem) {
      this._addChild(elem);
    };
    AbsoluteElement.prototype.addFixedX = function(elem) {
      this._addChild(elem);
    };
    AbsoluteElement.prototype.addCentered = function(elem) {
      var half = elem.w / 2;
      if (-half < this.extraw) this.extraw = -half;
      this.extra[this.extra.length] = elem;
      if (elem.dx + half > this.w) this.w = elem.dx + half;
      this.right[this.right.length] = elem;
      this._addChild(elem);
    };
    AbsoluteElement.prototype.setLimit = function(member, child) {
      if (!child[member]) return;
      if (!this.specialY[member])
        this.specialY[member] = child[member];
      else
        this.specialY[member] = Math.max(this.specialY[member], child[member]);
    };
    AbsoluteElement.prototype._addChild = function(child) {
      var okToPushTop = true;
      if (this.abcelem.el_type == "clef" && child.type == "barNumber") {
        okToPushTop = false;
      }
      child.parent = this;
      this.children[this.children.length] = child;
      if (okToPushTop) {
        this.pushTop(child.top);
      }
      this.pushBottom(child.bottom);
      this.setLimit("tempoHeightAbove", child);
      this.setLimit("partHeightAbove", child);
      this.setLimit("volumeHeightAbove", child);
      this.setLimit("dynamicHeightAbove", child);
      this.setLimit("endingHeightAbove", child);
      this.setLimit("chordHeightAbove", child);
      this.setLimit("lyricHeightAbove", child);
      this.setLimit("lyricHeightBelow", child);
      this.setLimit("chordHeightBelow", child);
      this.setLimit("volumeHeightBelow", child);
      this.setLimit("dynamicHeightBelow", child);
    };
    AbsoluteElement.prototype.pushTop = function(top) {
      if (top !== void 0) {
        if (this.top === void 0)
          this.top = top;
        else
          this.top = Math.max(top, this.top);
      }
    };
    AbsoluteElement.prototype.pushBottom = function(bottom) {
      if (bottom !== void 0) {
        if (this.bottom === void 0)
          this.bottom = bottom;
        else
          this.bottom = Math.min(bottom, this.bottom);
      }
    };
    AbsoluteElement.prototype.setX = function(x) {
      this.x = x;
      for (var i2 = 0; i2 < this.children.length; i2++)
        this.children[i2].setX(x);
    };
    AbsoluteElement.prototype.center = function(before, after) {
      var midpoint = (after.x - before.x) / 2 + before.x;
      this.x = midpoint - this.w / 2;
      for (var k = 0; k < this.children.length; k++)
        this.children[k].setX(this.x);
    };
    AbsoluteElement.prototype.setHint = function() {
      this.hint = true;
    };
    AbsoluteElement.prototype.highlight = function(klass, color) {
      highlight.bind(this)(klass, color);
    };
    AbsoluteElement.prototype.unhighlight = function(klass, color) {
      unhighlight.bind(this)(klass, color);
    };
    module.exports = AbsoluteElement;
  }
});

// node_modules/abcjs/src/write/creation/elements/relative-element.js
var require_relative_element = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/relative-element.js"(exports, module) {
    var RelativeElement = function RelativeElement2(c, dx, w, pitch, opt) {
      opt = opt || {};
      this.x = 0;
      this.c = c;
      this.dx = dx;
      this.w = w;
      this.pitch = pitch;
      this.scalex = opt.scalex || 1;
      this.scaley = opt.scaley || 1;
      this.type = opt.type || "symbol";
      this.pitch2 = opt.pitch2;
      this.linewidth = opt.linewidth;
      this.klass = opt.klass;
      this.anchor = opt.anchor ? opt.anchor : "middle";
      this.top = pitch;
      if (this.pitch2 !== void 0 && this.pitch2 > this.top) this.top = this.pitch2;
      this.bottom = pitch;
      if (this.pitch2 !== void 0 && this.pitch2 < this.bottom) this.bottom = this.pitch2;
      if (opt.thickness) {
        this.top += opt.thickness / 2;
        this.bottom -= opt.thickness / 2;
      }
      if (opt.stemHeight) {
        if (opt.stemHeight > 0)
          this.top += opt.stemHeight;
        else
          this.bottom += opt.stemHeight;
      }
      if (opt.dim)
        this.dim = opt.dim;
      if (opt.position)
        this.position = opt.position;
      this.height = opt.height ? opt.height : 4;
      if (opt.top)
        this.top = opt.top;
      if (opt.bottom)
        this.bottom = opt.bottom;
      if (opt.name)
        this.name = opt.name;
      else if (this.c)
        this.name = this.c;
      else
        this.name = this.type;
      if (opt.realWidth)
        this.realWidth = opt.realWidth;
      else
        this.realWidth = this.w;
      this.centerVertically = false;
      switch (this.type) {
        case "debug":
          this.chordHeightAbove = this.height;
          break;
        case "lyric":
          if (opt.position && opt.position === "below")
            this.lyricHeightBelow = this.height;
          else
            this.lyricHeightAbove = this.height;
          break;
        case "chord":
          if (opt.position && opt.position === "below")
            this.chordHeightBelow = this.height;
          else
            this.chordHeightAbove = this.height;
          break;
        case "text":
          if (this.pitch === void 0) {
            if (opt.position && opt.position === "below")
              this.chordHeightBelow = this.height;
            else
              this.chordHeightAbove = this.height;
          } else
            this.centerVertically = true;
          break;
        case "part":
          this.partHeightAbove = this.height;
          break;
      }
    };
    RelativeElement.prototype.getChordDim = function() {
      if (this.type === "debug")
        return null;
      if (!this.chordHeightAbove && !this.chordHeightBelow)
        return null;
      var margin = 0;
      var offset = this.type === "chord" ? this.realWidth / 2 : 0;
      var left = this.x - offset - margin;
      var right = left + this.realWidth + margin;
      return { left, right };
    };
    RelativeElement.prototype.invertLane = function(total) {
      if (this.lane === void 0)
        this.lane = 0;
      this.lane = total - this.lane - 1;
    };
    RelativeElement.prototype.putChordInLane = function(i2) {
      this.lane = i2;
      if (this.chordHeightAbove)
        this.chordHeightAbove = this.height * 1.25 * this.lane;
      else
        this.chordHeightBelow = this.height * 1.25 * this.lane;
    };
    RelativeElement.prototype.getLane = function() {
      if (this.lane === void 0)
        return 0;
      return this.lane;
    };
    RelativeElement.prototype.setX = function(x) {
      this.x = x + this.dx;
    };
    module.exports = RelativeElement;
  }
});

// node_modules/abcjs/src/tablatures/render/tab-absolute-elements.js
var require_tab_absolute_elements = __commonJS({
  "node_modules/abcjs/src/tablatures/render/tab-absolute-elements.js"(exports, module) {
    var AbsoluteElement = require_absolute_element();
    var RelativeElement = require_relative_element();
    function isObject(a) {
      return a != null && a.constructor === Object;
    }
    function cloneObject(dest, src) {
      for (var prop in src) {
        if (src.hasOwnProperty(prop)) {
          if (!(Array.isArray(src[prop]) || isObject(src[prop]))) {
            dest[prop] = src[prop];
          }
        }
      }
    }
    function cloneAbsolute(absSrc) {
      var returned = new AbsoluteElement("", 0, 0, "", 0);
      cloneObject(returned, absSrc);
      returned.top = 0;
      returned.bottom = -1;
      if (absSrc.abcelem) {
        returned.abcelem = {};
        cloneObject(returned.abcelem, absSrc.abcelem);
        if (returned.abcelem.el_type === "note")
          returned.abcelem.el_type = "tabNumber";
      }
      absSrc.cloned = returned;
      return returned;
    }
    function cloneAbsoluteAndRelatives(absSrc, plugin) {
      var returned = cloneAbsolute(absSrc);
      if (plugin) {
        var children = absSrc.children;
        var first = true;
        for (var ii = 0; ii < children.length; ii++) {
          var child = children[ii];
          var relative = new RelativeElement("", 0, 0, 0, "");
          cloneObject(relative, child);
          first = plugin.tablature.setRelative(child, relative, first);
          returned.children.push(relative);
        }
      }
      return returned;
    }
    function buildTabAbsolute(plugin, absX, relX) {
      var tabIcon = "tab.tiny";
      var tabYPos = 7.5;
      if (plugin.isTabBig) {
        tabIcon = "tab.big";
        tabYPos = 10;
      }
      var element = {
        el_type: "tab",
        icon: tabIcon,
        Ypos: tabYPos
      };
      tabYPos += plugin.tabSymbolOffset;
      if (!plugin.hideTabSymbol) {
        var tabAbsolute = new AbsoluteElement(element, 0, 0, "symbol", 0);
        tabAbsolute.x = absX;
        var tabRelative = new RelativeElement(tabIcon, 0, 0, 7.5, "tab");
        tabRelative.x = relX;
        tabAbsolute.children.push(tabRelative);
        if (tabAbsolute.abcelem.el_type == "tab") {
          tabRelative.pitch = tabYPos;
        }
      }
      return tabAbsolute;
    }
    function lyricsDim(abs) {
      if (abs.extra) {
        for (var ii = 0; ii < abs.extra.length; ii++) {
          var extra = abs.extra[ii];
          if (extra.type == "lyric") {
            return {
              bottom: extra.bottom,
              height: extra.height
            };
          }
        }
      }
      return null;
    }
    function TabAbsoluteElements() {
      this.accidentals = null;
    }
    function getInitialStaffSize(staffGroup) {
      var returned = 0;
      for (var ii = 0; ii < staffGroup.length; ii++) {
        if (!staffGroup[ii].tabNameInfos) returned++;
      }
      return returned;
    }
    function buildRelativeTabNote(plugin, relX, def, curNote, isGrace) {
      var strNote = curNote.num;
      if (curNote.note.quarter != null) {
        strNote = strNote.toString();
        strNote += curNote.note.quarter;
      }
      var pitch = plugin.semantics.stringToPitch(curNote.str);
      def.notes.push({ num: strNote, str: curNote.str, pitch: curNote.note.emit() });
      var opt = {
        type: "tabNumber"
      };
      var tabNoteRelative = new RelativeElement(
        strNote,
        0,
        0,
        pitch + 0.3,
        opt
      );
      tabNoteRelative.x = relX;
      tabNoteRelative.isGrace = isGrace;
      tabNoteRelative.isAltered = curNote.note.isAltered;
      return tabNoteRelative;
    }
    function getXGrace(abs, index) {
      var found = 0;
      if (abs.extra) {
        for (var ii = 0; ii < abs.extra.length; ii++) {
          if (abs.extra[ii].c.indexOf("noteheads") >= 0) {
            if (found === index) {
              return abs.extra[ii].x + abs.extra[ii].w / 2;
            } else {
              found++;
            }
          }
        }
      }
      return -1;
    }
    function graceInRest(absElem) {
      if (absElem.abcelem) {
        var elem = absElem.abcelem;
        if (elem.rest) {
          return elem.gracenotes;
        }
      }
      return null;
    }
    function convertToNumber(plugin, pitches, graceNotes) {
      var tabPos = plugin.semantics.notesToNumber(pitches, graceNotes);
      if (tabPos.error) {
        plugin.setError(tabPos.error);
        return tabPos;
      }
      if (tabPos.graces && tabPos.notes) {
        var posNote = tabPos.notes.length - 1;
        tabPos.notes[posNote].graces = tabPos.graces;
      }
      return tabPos;
    }
    function buildGraceRelativesForRest(plugin, abs, absChild, graceNotes, tabVoice) {
      for (var mm = 0; mm < graceNotes.length; mm++) {
        var defGrace = { el_type: "note", startChar: absChild.abcelem.startChar, endChar: absChild.abcelem.endChar, notes: [], grace: true };
        var graceX = getXGrace(absChild, mm);
        var curGrace = graceNotes[mm];
        var tabGraceRelative = buildRelativeTabNote(plugin, graceX, defGrace, curGrace, true);
        abs.children.push(tabGraceRelative);
        tabVoice.push(defGrace);
      }
    }
    TabAbsoluteElements.prototype.build = function(plugin, staffAbsolute, tabVoice, voiceIndex, staffIndex, keySig, tabVoiceIndex) {
      var staffSize = getInitialStaffSize(staffAbsolute);
      var source = staffAbsolute[staffIndex + voiceIndex];
      var dest = staffAbsolute[tabVoiceIndex];
      var tabPos = null;
      var defNote = null;
      if (source.children[0].abcelem.el_type != "clef") {
        if (keySig != "none") {
          source.children.splice(0, 0, keySig);
        }
      }
      for (var ii = 0; ii < source.children.length; ii++) {
        var absChild = source.children[ii];
        var absX = absChild.x;
        var relX = absX;
        if (absChild.isClef) {
          dest.children.push(buildTabAbsolute(plugin, absX, relX));
          if (absChild.abcelem.type.indexOf("-8") >= 0) plugin.semantics.clefTranspose = -12;
          if (absChild.abcelem.type.indexOf("+8") >= 0) plugin.semantics.clefTranspose = 12;
        }
        switch (absChild.type) {
          case "staff-extra key-signature":
            this.accidentals = absChild.abcelem.accidentals;
            plugin.semantics.accidentals = this.accidentals;
            break;
          case "bar":
            plugin.semantics.measureAccidentals = {};
            var lastBar = false;
            if (ii === source.children.length - 1) {
              lastBar = true;
            }
            var cloned = cloneAbsoluteAndRelatives(absChild, plugin);
            if (cloned.abcelem.barNumber) {
              delete cloned.abcelem.barNumber;
              for (var bn = 0; bn < cloned.children.length; bn++) {
                if (cloned.children[bn].type === "barNumber") {
                  cloned.children.splice(bn, 1);
                  break;
                }
              }
            }
            cloned.abcelem.lastBar = lastBar;
            dest.children.push(cloned);
            tabVoice.push({
              el_type: absChild.abcelem.el_type,
              type: absChild.abcelem.type,
              endChar: absChild.abcelem.endChar,
              startChar: absChild.abcelem.startChar,
              abselem: cloned
            });
            break;
          case "rest":
            var restGraces = graceInRest(absChild);
            if (restGraces) {
              tabPos = convertToNumber(plugin, null, restGraces);
              if (tabPos.error) return;
              defGrace = { el_type: "note", startChar: absChild.abcelem.startChar, endChar: absChild.abcelem.endChar, notes: [], grace: true };
              buildGraceRelativesForRest(plugin, abs, absChild, tabPos.graces, tabVoice);
            }
            break;
          case "note":
            var abs = cloneAbsolute(absChild);
            abs.x = absChild.heads[0].x + absChild.heads[0].w / 2;
            abs.lyricDim = lyricsDim(absChild);
            var pitches = absChild.abcelem.pitches;
            var graceNotes = absChild.abcelem.gracenotes;
            abs.type = "tabNumber";
            tabPos = convertToNumber(plugin, pitches, graceNotes);
            if (tabPos.error) return;
            if (tabPos.graces) {
              var posNote = tabPos.notes.length - 1;
              tabPos.notes[posNote].graces = tabPos.graces;
            }
            defNote = { el_type: "note", startChar: absChild.abcelem.startChar, endChar: absChild.abcelem.endChar, notes: [] };
            for (var ll = 0; ll < tabPos.notes.length; ll++) {
              var curNote = tabPos.notes[ll];
              if (curNote.graces) {
                for (var mm = 0; mm < curNote.graces.length; mm++) {
                  var defGrace = { el_type: "note", startChar: absChild.abcelem.startChar, endChar: absChild.abcelem.endChar, notes: [], grace: true };
                  var graceX = getXGrace(absChild, mm);
                  var curGrace = curNote.graces[mm];
                  var tabGraceRelative = buildRelativeTabNote(plugin, graceX, defGrace, curGrace, true);
                  abs.children.push(tabGraceRelative);
                  tabVoice.push(defGrace);
                }
              }
              var tabNoteRelative = buildRelativeTabNote(plugin, abs.x + absChild.heads[ll].dx, defNote, curNote, false);
              abs.children.push(tabNoteRelative);
            }
            if (defNote.notes.length > 0) {
              defNote.abselem = abs;
              tabVoice.push(defNote);
              dest.children.push(abs);
            }
            break;
        }
      }
    };
    module.exports = TabAbsoluteElements;
  }
});

// node_modules/abcjs/src/tablatures/render/tab-renderer.js
var require_tab_renderer = __commonJS({
  "node_modules/abcjs/src/tablatures/render/tab-renderer.js"(exports, module) {
    var VoiceElement = require_voice_element();
    var TabAbsoluteElements = require_tab_absolute_elements();
    var spacing = require_spacing();
    function initSpecialY() {
      return {
        tempoHeightAbove: 0,
        partHeightAbove: 0,
        volumeHeightAbove: 0,
        dynamicHeightAbove: 0,
        endingHeightAbove: 0,
        chordHeightAbove: 0,
        lyricHeightAbove: 0,
        lyricHeightBelow: 0,
        chordHeightBelow: 0,
        volumeHeightBelow: 0,
        dynamicHeightBelow: 0
      };
    }
    function getLyricHeight(voice) {
      var maxLyricHeight = 0;
      for (var ii = 0; ii < voice.children.length; ii++) {
        var curAbs = voice.children[ii];
        if (curAbs.specialY) {
          if (curAbs.specialY.lyricHeightBelow > maxLyricHeight) {
            maxLyricHeight = curAbs.specialY.lyricHeightBelow;
          }
        }
      }
      return maxLyricHeight;
    }
    function buildTabName(plugin, renderer, dest) {
      var stringSemantics = plugin.semantics;
      var textSize = renderer.controller.getTextSize;
      var tabName = stringSemantics.tabInfos(plugin);
      var suppress = stringSemantics.suppress(plugin);
      var doDraw = true;
      if (suppress) {
        doDraw = false;
      }
      if (doDraw) {
        var size = textSize.calc(tabName, "tablabelfont", "text instrumentname");
        dest.tabNameInfos = {
          textSize: { height: size.height, width: size.width },
          name: tabName
        };
        return size.height;
      }
      return 0;
    }
    function islastTabInStaff(index, staffGroup) {
      if (staffGroup[index].isTabStaff) {
        if (index === staffGroup.length - 1) return true;
        if (staffGroup[index + 1].isTabStaff) {
          return false;
        } else {
          return true;
        }
      }
      return false;
    }
    function getStaffNumbers(staffs) {
      var nbStaffs = 0;
      for (var ii = 0; ii < staffs.length; ii++) {
        if (!staffs[ii].isTabStaff) {
          nbStaffs++;
        }
      }
      return nbStaffs;
    }
    function getParentStaffIndex(staffs, index) {
      for (var ii = index; ii >= 0; ii--) {
        if (!staffs[ii].isTabStaff) {
          return ii;
        }
      }
      return -1;
    }
    function linkStaffAndTabs(staffs) {
      for (var ii = 0; ii < staffs.length; ii++) {
        if (staffs[ii].isTabStaff) {
          var parentIndex = getParentStaffIndex(staffs, ii);
          staffs[ii].hasStaff = staffs[parentIndex];
          if (!staffs[parentIndex].hasTab) staffs[parentIndex].hasTab = [];
          staffs[parentIndex].hasTab.push(staffs[ii]);
        }
      }
    }
    function isMultiVoiceSingleStaff(staffs, parent) {
      if (getStaffNumbers(staffs) === 1) {
        if (parent.voices.length > 1) return true;
      }
      return false;
    }
    function getNextTabPos(tabIndex, staffGroup) {
      var startIndex = 0;
      var handledVoices = 0;
      var inProgress = true;
      var nbVoices = 0;
      while (inProgress) {
        if (!staffGroup[startIndex])
          return -1;
        if (!staffGroup[startIndex].isTabStaff) {
          nbVoices = staffGroup[startIndex].voices.length;
        }
        if (staffGroup[startIndex].isTabStaff) {
          handledVoices++;
          if (islastTabInStaff(startIndex, staffGroup)) {
            if (handledVoices < nbVoices) return startIndex + 1;
          }
        } else {
          handledVoices = 0;
          if (startIndex >= tabIndex) {
            if (startIndex + 1 == staffGroup.length) return startIndex + 1;
            if (!staffGroup[startIndex + 1].isTabStaff) return startIndex + 1;
          }
        }
        startIndex++;
        if (startIndex > staffGroup.length) return -1;
      }
    }
    function getLastStaff(staffs, lastTab) {
      for (var ii = lastTab; ii >= 0; ii--) {
        if (!staffs[ii].isTabStaff) {
          return staffs[ii];
        }
      }
      return null;
    }
    function checkVoiceKeySig(voices, ii) {
      var curVoice = voices[ii];
      var elem0 = curVoice.children[0].abcelem;
      if (elem0.el_type === "clef") return null;
      if (ii == 0) {
        return "none";
      }
      return voices[ii - 1].children[0];
    }
    function tabRenderer(plugin, renderer, line, staffIndex) {
      var absolutes = new TabAbsoluteElements();
      var tabStaff = {
        clef: {
          type: "TAB"
        }
      };
      var tabSize = plugin.linePitch * plugin.nbLines;
      var staffs = line.staff;
      if (staffs) {
        var firstStaff = staffs[0];
        if (firstStaff) {
          if (firstStaff.clef) {
            if (firstStaff.clef.stafflines == 0) {
              plugin.setError("No tablatures when stafflines=0");
              return;
            }
          }
        }
        staffs.splice(
          staffs.length,
          0,
          tabStaff
        );
      }
      var staffGroup = line.staffGroup;
      var voices = staffGroup.voices;
      var firstVoice = voices[0];
      var lyricsHeight = getLyricHeight(firstVoice);
      var padd = 3;
      var prevIndex = staffIndex;
      var previousStaff = staffGroup.staffs[prevIndex];
      var tabTop = tabSize + padd - previousStaff.bottom - lyricsHeight;
      if (previousStaff.isTabStaff) {
        tabTop = previousStaff.top;
      }
      var staffGroupInfos = {
        bottom: -1,
        isTabStaff: true,
        specialY: initSpecialY(),
        lines: plugin.nbLines,
        linePitch: plugin.linePitch,
        dy: 0.15,
        top: tabTop
      };
      var nextTabPos = getNextTabPos(staffIndex, staffGroup.staffs);
      if (nextTabPos === -1)
        return;
      staffGroupInfos.parentIndex = nextTabPos - 1;
      staffGroup.staffs.splice(nextTabPos, 0, staffGroupInfos);
      staffGroup.height += tabSize + padd;
      var parentStaff = getLastStaff(staffGroup.staffs, nextTabPos);
      var nbVoices = 1;
      if (isMultiVoiceSingleStaff(staffGroup.staffs, parentStaff)) {
        nbVoices = parentStaff.voices.length;
      }
      tabStaff.voices = [];
      for (var ii = 0; ii < nbVoices; ii++) {
        var tabVoice = new VoiceElement(0, 0);
        if (ii > 0) tabVoice.duplicate = true;
        var nameHeight = buildTabName(plugin, renderer, tabVoice) / spacing.STEP;
        nameHeight = Math.max(nameHeight, 1);
        staffGroup.staffs[staffIndex].top += 1;
        staffGroup.height += nameHeight;
        tabVoice.staff = staffGroupInfos;
        var tabVoiceIndex = voices.length;
        voices.splice(voices.length, 0, tabVoice);
        var keySig = checkVoiceKeySig(voices, ii + staffIndex);
        tabStaff.voices[ii] = [];
        absolutes.build(plugin, voices, tabStaff.voices[ii], ii, staffIndex, keySig, tabVoiceIndex);
      }
      linkStaffAndTabs(staffGroup.staffs);
    }
    module.exports = tabRenderer;
  }
});

// node_modules/abcjs/src/synth/note-to-midi.js
var require_note_to_midi = __commonJS({
  "node_modules/abcjs/src/synth/note-to-midi.js"(exports, module) {
    var accidentals = {
      "__": -2,
      "_": -1,
      "_/": -0.5,
      "=": 0,
      "": 0,
      "^/": 0.5,
      "^": 1,
      "^^": 2
    };
    var notesInOrder = ["C", "-", "D", "-", "E", "F", "-", "G", "-", "A", "-", "B", "c", "-", "d", "-", "e", "f", "-", "g", "-", "a", "-", "b"];
    function noteToMidi(note) {
      var reg = note.match(/([_^\/]*)([ABCDEFGabcdefg])(,*)('*)/);
      if (reg && reg.length === 5) {
        var acc = accidentals[reg[1]];
        var pitch = notesInOrder.indexOf(reg[2]);
        var octave = reg[4].length - reg[3].length;
        return 48 + pitch + acc + octave * 12;
      }
      return 0;
    }
    function midiToNote(midi) {
      midi = parseInt(midi, 10);
      var octave = Math.floor(midi / 12);
      var pitch = midi % 12;
      var name = notesInOrder[pitch];
      if (name === "-") {
        name = "^" + notesInOrder[pitch - 1];
      }
      if (octave > 4) {
        name = name.toLowerCase();
        octave -= 5;
        while (octave > 0) {
          name += "'";
          octave--;
        }
      } else {
        while (octave < 4) {
          name += ",";
          octave++;
        }
      }
      return name;
    }
    module.exports = { noteToMidi, midiToNote };
  }
});

// node_modules/abcjs/src/tablatures/instruments/tab-note.js
var require_tab_note = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/tab-note.js"(exports, module) {
    var { noteToMidi, midiToNote } = require_note_to_midi();
    function TabNote(note, clefTranspose) {
      var pitch = noteToMidi(note);
      if (clefTranspose)
        pitch += clefTranspose;
      var newNote = midiToNote(pitch);
      var isFlat = false;
      var isSharp = false;
      var isAltered = false;
      var natural = null;
      var quarter = null;
      var isDouble = false;
      var acc = 0;
      if (note.startsWith("_")) {
        isFlat = true;
        acc = -1;
        if (note[1] == "/") {
          isFlat = false;
          quarter = "v";
          acc = 0;
        } else if (note[1] == "_") {
          isDouble = true;
          acc -= 1;
        }
      } else if (note.startsWith("^")) {
        isSharp = true;
        acc = 1;
        if (note[1] == "/") {
          isSharp = false;
          quarter = "^";
          acc = 0;
        } else if (note[1] == "^") {
          isDouble = true;
          acc += 1;
        }
      } else if (note.startsWith("=")) {
        natural = true;
        acc = 0;
      }
      isAltered = isFlat || isSharp || quarter != null;
      if (isAltered || natural) {
        if (quarter != null || isDouble) {
          newNote = note.slice(2);
        } else {
          newNote = note.slice(1);
        }
      }
      var hasComma = (newNote.match(/,/g) || []).length;
      var hasQuote = (newNote.match(/'/g) || []).length;
      this.pitch = pitch;
      this.pitchAltered = 0;
      this.name = newNote;
      this.acc = acc;
      this.isSharp = isSharp;
      this.isKeySharp = false;
      this.isDouble = isDouble;
      this.isAltered = isAltered;
      this.isFlat = isFlat;
      this.isKeyFlat = false;
      this.natural = natural;
      this.quarter = quarter;
      this.isLower = this.name == this.name.toLowerCase();
      this.name = this.name[0].toUpperCase();
      this.hasComma = hasComma;
      this.isQuoted = hasQuote;
    }
    function cloneNote(self) {
      var newNote = self.name;
      var newTabNote = new TabNote(newNote);
      newTabNote.pitch = self.pitch;
      newTabNote.hasComma = self.hasComma;
      newTabNote.isLower = self.isLower;
      newTabNote.isQuoted = self.isQuoted;
      newTabNote.isSharp = self.isSharp;
      newTabNote.isKeySharp = self.isKeySharp;
      newTabNote.isFlat = self.isFlat;
      newTabNote.isKeyFlat = self.isKeyFlat;
      return newTabNote;
    }
    TabNote.prototype.sameNoteAs = function(note) {
      return note.pitch === this.pitch;
    };
    TabNote.prototype.isLowerThan = function(note) {
      return note.pitch > this.pitch;
    };
    TabNote.prototype.checkKeyAccidentals = function(accidentals, measureAccidentals) {
      if (this.isAltered || this.natural)
        return;
      if (measureAccidentals[this.name.toUpperCase()]) {
        switch (measureAccidentals[this.name.toUpperCase()]) {
          case "__":
            this.acc = -2;
            this.pitchAltered = -2;
            return;
          case "_":
            this.acc = -1;
            this.pitchAltered = -1;
            return;
          case "=":
            this.acc = 0;
            this.pitchAltered = 0;
            return;
          case "^":
            this.acc = 1;
            this.pitchAltered = 1;
            return;
          case "^^":
            this.acc = 2;
            this.pitchAltered = 2;
            return;
        }
      } else if (accidentals) {
        var curNote = this.name;
        for (var iii = 0; iii < accidentals.length; iii++) {
          var curAccidentals = accidentals[iii];
          if (curNote == curAccidentals.note.toUpperCase()) {
            if (curAccidentals.acc == "flat") {
              this.acc = -1;
              this.isKeyFlat = true;
              this.pitchAltered = -1;
            }
            if (curAccidentals.acc == "sharp") {
              this.acc = 1;
              this.isKeySharp = true;
              this.pitchAltered = 1;
            }
          }
        }
      }
    };
    TabNote.prototype.getAccidentalEquiv = function() {
      var cloned = cloneNote(this);
      if (cloned.isSharp || cloned.isKeySharp) {
        cloned = cloned.nextNote();
        cloned.isFlat = true;
        cloned.isSharp = false;
        cloned.isKeySharp = false;
      } else if (cloned.isFlat || cloned.isKeyFlat) {
        cloned = cloned.prevNote();
        cloned.isSharp = true;
        cloned.isFlat = false;
        cloned.isKeyFlat = false;
      }
      return cloned;
    };
    TabNote.prototype.nextNote = function() {
      var note = midiToNote(this.pitch + 1 + this.pitchAltered);
      return new TabNote(note);
    };
    TabNote.prototype.prevNote = function() {
      var note = midiToNote(this.pitch - 1 + this.pitchAltered);
      return new TabNote(note);
    };
    TabNote.prototype.emitNoAccidentals = function() {
      var returned = this.name;
      if (this.isLower) {
        returned = returned.toLowerCase();
      }
      for (var ii = 0; ii < this.isQuoted; ii++) {
        returned += "'";
      }
      for (var jj = 0; jj < this.hasComma; jj++) {
        returned += ",";
      }
      return returned;
    };
    TabNote.prototype.emit = function() {
      var returned = this.name;
      if (this.isSharp || this.isKeySharp) {
        returned = "^" + returned;
        if (this.isDouble) {
          returned = "^" + returned;
        }
      }
      if (this.isFlat || this.isKeyFlat) {
        returned = "_" + returned;
        if (this.isDouble) {
          returned = "_" + returned;
        }
      }
      if (this.quarter) {
        if (this.quarter == "^") {
          returned = "^/" + returned;
        } else {
          returned = "_/" + returned;
        }
      }
      if (this.natural) {
        returned = "=" + returned;
      }
      for (var ii = 1; ii <= this.hasComma; ii++) {
        returned += ",";
      }
      if (this.isLower) {
        returned = returned.toLowerCase();
        for (var jj = 1; jj <= this.isQuoted; jj++) {
          returned += "'";
        }
      }
      return returned;
    };
    module.exports = TabNote;
  }
});

// node_modules/abcjs/src/tablatures/instruments/tab-notes.js
var require_tab_notes = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/tab-notes.js"(exports, module) {
    var TabNote = require_tab_note();
    var notes = ["A", "B", "C", "D", "E", "F", "G"];
    function tabNotes(fromNote, toNote) {
      var fromN = new TabNote(fromNote);
      var toN = new TabNote(toNote);
      if (toN.isLowerThan(fromN)) {
        var from = fromN.emit();
        var tn = toN.emit();
        return {
          error: "Invalid string Instrument tuning : " + tn + " string lower than " + from + " string"
        };
      }
      var buildReturned = [];
      var startIndex = notes.indexOf(fromN.name);
      var toIndex = notes.indexOf(toN.name);
      if (startIndex == -1 || toIndex == -1) {
        return buildReturned;
      }
      var finished = false;
      while (!finished) {
        buildReturned.push(fromN.emit());
        fromN = fromN.nextNote();
        if (fromN.sameNoteAs(toN)) {
          finished = true;
        }
      }
      return buildReturned;
    }
    module.exports = tabNotes;
  }
});

// node_modules/abcjs/src/tablatures/instruments/string-patterns.js
var require_string_patterns = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/string-patterns.js"(exports, module) {
    var { noteToMidi } = require_note_to_midi();
    var TabNote = require_tab_note();
    var tabNotes = require_tab_notes();
    function buildCapo(self) {
      var capoTuning = null;
      var tuning = self.tuning;
      if (self.capo > 0) {
        capoTuning = [];
        for (var iii = 0; iii < tuning.length; iii++) {
          var curNote = new TabNote(tuning[iii]);
          for (var jjj = 0; jjj < self.capo; jjj++) {
            curNote = curNote.nextNote();
          }
          capoTuning[iii] = curNote.emit();
        }
      }
      return capoTuning;
    }
    function buildPatterns(self) {
      var strings = [];
      var tuning = self.tuning;
      if (self.capo > 0) {
        tuning = self.capoTuning;
      }
      var pos = tuning.length - 1;
      for (var iii = 0; iii < tuning.length; iii++) {
        var nextNote = self.highestNote;
        if (iii != tuning.length - 1) {
          nextNote = tuning[iii + 1];
        }
        var stringNotes = tabNotes(tuning[iii], nextNote);
        if (stringNotes.error) {
          return stringNotes;
        }
        strings[pos--] = stringNotes;
      }
      return strings;
    }
    function buildSecond(first) {
      var seconds = [];
      seconds[0] = [];
      var strings = first.strings;
      for (var iii = 1; iii < strings.length; iii++) {
        seconds[iii] = strings[iii - 1];
      }
      return seconds;
    }
    function sameString(self, chord) {
      for (var jjjj = 0; jjjj < chord.length - 1; jjjj++) {
        var curPos = chord[jjjj];
        var nextPos = chord[jjjj + 1];
        if (curPos.str == nextPos.str) {
          if (curPos.str == self.strings.length - 1) {
            curPos.num = "?";
            nextPos.num = "?";
            return;
          }
          if (nextPos.num < curPos.num) {
            nextPos.str++;
            nextPos = noteToNumber(
              self,
              nextPos.note,
              nextPos.str,
              self.secondPos,
              self.strings[nextPos.str].length
            );
          } else {
            curPos.str++;
            curPos = noteToNumber(
              self,
              curPos.note,
              curPos.str,
              self.secondPos,
              self.strings[curPos.str].length
            );
          }
          chord[jjjj] = curPos;
          chord[jjjj + 1] = nextPos;
        }
      }
      return null;
    }
    function handleChordNotes(self, notes) {
      var retNotes = [];
      for (var iiii = 0; iiii < notes.length; iiii++) {
        if (notes[iiii].endTie)
          continue;
        var note = new TabNote(notes[iiii].name, self.clefTranspose);
        note.checkKeyAccidentals(self.accidentals, self.measureAccidentals);
        var curPos = toNumber(self, note);
        retNotes.push(curPos);
      }
      sameString(self, retNotes);
      return retNotes;
    }
    function noteToNumber(self, note, stringNumber, secondPosition, firstSize) {
      var strings = self.strings;
      note.checkKeyAccidentals(self.accidentals, self.measureAccidentals);
      if (secondPosition) {
        strings = secondPosition;
      }
      var noteName = note.emitNoAccidentals();
      var num = strings[stringNumber].indexOf(noteName);
      var acc = note.acc;
      if (num != -1) {
        if (secondPosition) {
          num += firstSize;
        }
        if ((note.isFlat || note.acc == -1) && num == 0) {
          var noteEquiv = note.getAccidentalEquiv();
          stringNumber++;
          num = strings[stringNumber].indexOf(noteEquiv.emit());
          acc = 0;
        }
        return {
          num: num + acc,
          str: stringNumber,
          note
        };
      }
      return null;
    }
    function toNumber(self, note) {
      if (note.isAltered || note.natural) {
        var acc;
        if (note.isFlat) {
          if (note.isDouble)
            acc = "__";
          else
            acc = "_";
        } else if (note.isSharp) {
          if (note.isDouble)
            acc = "^^";
          else
            acc = "^";
        } else if (note.natural)
          acc = "=";
        self.measureAccidentals[note.name.toUpperCase()] = acc;
      }
      for (var i2 = self.stringPitches.length - 1; i2 >= 0; i2--) {
        if (note.pitch + note.pitchAltered >= self.stringPitches[i2]) {
          var num = note.pitch + note.pitchAltered - self.stringPitches[i2];
          if (note.quarter === "^") num -= 0.5;
          else if (note.quarter === "v") num += 0.5;
          return {
            num: Math.round(num),
            str: self.stringPitches.length - 1 - i2,
            // reverse the strings because string 0 is on the bottom
            note
          };
        }
      }
      return {
        num: "?",
        str: self.stringPitches.length - 1,
        note
      };
    }
    StringPatterns.prototype.stringToPitch = function(stringNumber) {
      var startingPitch = 5.3;
      var bottom = this.strings.length - 1;
      return startingPitch + (bottom - stringNumber) * this.linePitch;
    };
    function invalidNumber(retNotes, note) {
      var number = {
        num: "?",
        str: 0,
        note
      };
      retNotes.push(number);
      retNotes.error = note.emit() + ": unexpected note for instrument";
    }
    StringPatterns.prototype.notesToNumber = function(notes, graces) {
      var note;
      var number;
      var error = null;
      var retNotes = null;
      if (notes) {
        retNotes = [];
        if (notes.length > 1) {
          retNotes = handleChordNotes(this, notes);
          if (retNotes.error) {
            error = retNotes.error;
          }
        } else {
          if (!notes[0].endTie) {
            note = new TabNote(notes[0].name, this.clefTranspose);
            note.checkKeyAccidentals(this.accidentals, this.measureAccidentals);
            number = toNumber(this, note);
            if (number) {
              retNotes.push(number);
            } else {
              invalidNumber(retNotes, note);
              error = retNotes.error;
            }
          }
        }
      }
      if (error) return retNotes;
      var retGraces = null;
      if (graces) {
        retGraces = [];
        for (var iiii = 0; iiii < graces.length; iiii++) {
          note = new TabNote(graces[iiii].name, this.clefTranspose);
          note.checkKeyAccidentals(this.accidentals, this.measureAccidentals);
          number = toNumber(this, note);
          if (number) {
            retGraces.push(number);
          } else {
            invalidNumber(retGraces, note);
            error = retNotes.error;
          }
        }
      }
      return {
        notes: retNotes,
        graces: retGraces,
        error
      };
    };
    StringPatterns.prototype.toString = function() {
      var arr = [];
      for (var i2 = 0; i2 < this.tuning.length; i2++) {
        var str = this.tuning[i2].replaceAll(",", "").replaceAll("'", "").toUpperCase();
        if (str[0] === "_") str = str[1] + "b ";
        else if (str[0] === "^") str = str[1] + "# ";
        arr.push(str);
      }
      return arr.join("");
    };
    StringPatterns.prototype.tabInfos = function(plugin) {
      var name = plugin.params.label;
      if (name) {
        var tunePos = name.indexOf("%T");
        var tuning = "";
        if (tunePos != -1) {
          tuning = this.toString();
          if (plugin.capo > 0) {
            tuning += " capo:" + plugin.capo;
          }
          name = name.replace("%T", tuning);
        }
        return name;
      }
      return "";
    };
    StringPatterns.prototype.suppress = function(plugin) {
      var suppress = plugin.params.suppress;
      if (suppress) {
        return true;
      }
      return false;
    };
    function StringPatterns(plugin) {
      var tuning = plugin.tuning;
      var capo = plugin.capo;
      var highestNote = plugin.params.highestNote;
      this.linePitch = plugin.linePitch;
      this.highestNote = "a'";
      if (highestNote) {
        this.highestNote = highestNote;
      }
      this.measureAccidentals = {};
      this.capo = 0;
      if (capo) {
        this.capo = parseInt(capo, 10);
      }
      this.transpose = plugin.transpose ? plugin.transpose : 0;
      this.tuning = tuning;
      this.stringPitches = [];
      for (var i2 = 0; i2 < this.tuning.length; i2++) {
        var pitch = noteToMidi(this.tuning[i2]) + this.capo;
        this.stringPitches.push(pitch);
      }
      if (this.capo > 0) {
        this.capoTuning = buildCapo(this);
      }
      this.strings = buildPatterns(this);
      if (this.strings.error) {
        plugin.setError(this.strings.error);
        plugin.inError = true;
        return;
      }
      this.secondPos = buildSecond(this);
    }
    module.exports = StringPatterns;
  }
});

// node_modules/abcjs/src/tablatures/instruments/tab-string.js
var require_tab_string = __commonJS({
  "node_modules/abcjs/src/tablatures/instruments/tab-string.js"(exports, module) {
    var StringTablature = require_string_tablature();
    var tabRenderer = require_tab_renderer();
    var StringPatterns = require_string_patterns();
    Plugin.prototype.init = function(abcTune, tuneNumber, params, tabSettings) {
      this.tune = abcTune;
      this.params = params;
      this.tuneNumber = tuneNumber;
      this.inError = false;
      this.abcTune = abcTune;
      this.linePitch = 3;
      this.nbLines = tabSettings.defaultTuning.length;
      this.isTabBig = tabSettings.isTabBig;
      this.tabSymbolOffset = tabSettings.tabSymbolOffset;
      this.capo = params.capo;
      this.transpose = params.visualTranspose;
      this.hideTabSymbol = params.hideTabSymbol;
      this.tablature = new StringTablature(this.nbLines, this.linePitch);
      var tuning = params.tuning;
      if (!tuning) {
        tuning = tabSettings.defaultTuning;
      }
      this.tuning = tuning;
      this.semantics = new StringPatterns(this);
    };
    Plugin.prototype.setError = function(error) {
      if (error) {
        this.error = error;
        this.inError = true;
        if (this.tune.warnings) {
          this.tune.warnings.push(error);
        } else {
          this.tune.warnings = [error];
        }
      }
    };
    Plugin.prototype.render = function(renderer, line, staffIndex) {
      if (this.inError) return;
      if (this.tablature.bypass(line)) return;
      tabRenderer(this, renderer, line, staffIndex);
    };
    function Plugin() {
    }
    var AbcStringTab = function() {
      return { name: "StringTab", tablature: Plugin };
    };
    module.exports = AbcStringTab;
  }
});

// node_modules/abcjs/src/tablatures/abc_tablatures.js
var require_abc_tablatures = __commonJS({
  "node_modules/abcjs/src/tablatures/abc_tablatures.js"(exports, module) {
    var TabString = require_tab_string();
    var pluginTab = {
      "violin": { name: "StringTab", defaultTuning: ["G,", "D", "A", "e"], isTabBig: false, tabSymbolOffset: 0 },
      "fiddle": { name: "StringTab", defaultTuning: ["G,", "D", "A", "e"], isTabBig: false, tabSymbolOffset: 0 },
      "mandolin": { name: "StringTab", defaultTuning: ["G,", "D", "A", "e"], isTabBig: false, tabSymbolOffset: 0 },
      "guitar": { name: "StringTab", defaultTuning: ["E,", "A,", "D", "G", "B", "e"], isTabBig: true, tabSymbolOffset: 0 },
      "fiveString": { name: "StringTab", defaultTuning: ["C,", "G,", "D", "A", "e"], isTabBig: false, tabSymbolOffset: -0.95 }
    };
    var abcTablatures = {
      inited: false,
      plugins: {},
      /**
       * to be called once per plugin for registration 
       * @param {*} plugin 
       */
      register: function(plugin) {
        var name = plugin.name;
        var tablature = plugin.tablature;
        this.plugins[name] = tablature;
      },
      setError: function(tune, msg) {
        if (tune.warnings) {
          tune.warning.push(msg);
        } else {
          tune.warnings = [msg];
        }
      },
      /**
       * handle params for current processed score
       * @param {*} tune current tune 
       * @param {*} tuneNumber number in tune list
       * @param {*} params params to be processed for tablature
       * @return prepared tablatures plugin instances for current tune
       */
      preparePlugins: function(tune, tuneNumber, params) {
        if (!this.inited) {
          this.register(new TabString());
          this.inited = true;
        }
        var returned = null;
        var nbPlugins = 0;
        if (params.tablature) {
          var tabs = params.tablature;
          returned = [];
          for (var ii = 0; ii < tabs.length; ii++) {
            var args = tabs[ii];
            var instrument = args["instrument"];
            if (instrument == null) {
              this.setError(tune, "tablature 'instrument' is missing");
              return returned;
            }
            var tabName = pluginTab[instrument];
            var plugin = null;
            if (tabName) {
              plugin = this.plugins[tabName.name];
            }
            if (plugin) {
              if (params.visualTranspose != 0) {
                args.visualTranspose = params.visualTranspose;
              }
              args.abcSrc = params.tablature.abcSrc;
              var pluginInstance = {
                classz: plugin,
                tuneNumber,
                params: args,
                instance: null,
                tabType: tabName
              };
              returned.push(pluginInstance);
              nbPlugins++;
            } else if (instrument === "") {
              returned.push(null);
            } else {
              this.setError(tune, "Undefined tablature plugin: " + instrument);
              return returned;
            }
          }
        }
        return returned;
      },
      /**
       * Call requested plugin
       * @param {*} renderer 
       * @param {*} abcTune 
       */
      layoutTablatures: function layoutTablatures(renderer, abcTune) {
        var tabs = abcTune.tablatures;
        var staffLineCount = 0;
        if (tabs && tabs.length > 0) {
          var nTabs = tabs.length;
          for (var kk = 0; kk < nTabs; ++kk) {
            if (tabs[kk] && tabs[kk].params.firstStaffOnly) {
              tabs[kk].params.suppress = false;
            }
          }
        }
        for (var ii = 0; ii < abcTune.lines.length; ii++) {
          var line = abcTune.lines[ii];
          if (line.staff) {
            staffLineCount++;
          }
          if (staffLineCount > 1) {
            if (tabs && tabs.length > 0) {
              var nTabs = tabs.length;
              for (var kk = 0; kk < nTabs; ++kk) {
                if (tabs[kk].params.firstStaffOnly) {
                  tabs[kk].params.suppress = true;
                }
              }
            }
          }
          var curStaff = line.staff;
          if (curStaff) {
            var maxStaves = curStaff.length;
            for (var jj = 0; jj < curStaff.length; jj++) {
              if (tabs[jj] && jj < maxStaves) {
                var tabPlugin = tabs[jj];
                if (tabPlugin.instance == null) {
                  tabPlugin.instance = new tabPlugin.classz();
                  tabPlugin.instance.init(
                    abcTune,
                    tabPlugin.tuneNumber,
                    tabPlugin.params,
                    tabPlugin.tabType
                  );
                }
                tabPlugin.instance.render(renderer, line, jj);
              }
            }
          }
        }
      }
    };
    module.exports = abcTablatures;
  }
});

// node_modules/abcjs/src/api/abc_tunebook.js
var require_abc_tunebook = __commonJS({
  "node_modules/abcjs/src/api/abc_tunebook.js"(exports, module) {
    var Parse = require_abc_parse();
    var bookParser = require_abc_parse_book();
    var tablatures = require_abc_tablatures();
    var tunebook = {};
    (function() {
      "use strict";
      tunebook.numberOfTunes = function(abc) {
        var tunes = abc.split("\nX:");
        var num = tunes.length;
        if (num === 0) num = 1;
        return num;
      };
      var TuneBook = tunebook.TuneBook = function(book) {
        var parsed = bookParser(book);
        this.header = parsed.header;
        this.tunes = parsed.tunes;
      };
      TuneBook.prototype.getTuneById = function(id) {
        for (var i2 = 0; i2 < this.tunes.length; i2++) {
          if (this.tunes[i2].id === "" + id)
            return this.tunes[i2];
        }
        return null;
      };
      TuneBook.prototype.getTuneByTitle = function(title) {
        for (var i2 = 0; i2 < this.tunes.length; i2++) {
          if (this.tunes[i2].title === title)
            return this.tunes[i2];
        }
        return null;
      };
      tunebook.parseOnly = function(abc, params) {
        var numTunes = tunebook.numberOfTunes(abc);
        var output = [];
        for (var i2 = 0; i2 < numTunes; i2++) {
          output.push(1);
        }
        function callback() {
        }
        return tunebook.renderEngine(callback, output, abc, params);
      };
      tunebook.renderEngine = function(callback, output, abc, params) {
        var ret = [];
        var isArray = function(testObject) {
          return testObject && !testObject.propertyIsEnumerable("length") && typeof testObject === "object" && typeof testObject.length === "number";
        };
        if (output === void 0 || abc === void 0)
          return;
        if (!isArray(output))
          output = [output];
        if (params === void 0)
          params = {};
        var currentTune = params.startingTune ? parseInt(params.startingTune, 10) : 0;
        var book = new TuneBook(abc);
        var abcParser = new Parse();
        for (var i2 = 0; i2 < output.length; i2++) {
          var div = output[i2];
          if (div === "*") {
          } else if (typeof div === "string")
            div = document.getElementById(div);
          if (div) {
            if (currentTune >= 0 && currentTune < book.tunes.length) {
              abcParser.parse(book.tunes[currentTune].abc, params, book.tunes[currentTune].startPos - book.header.length);
              var tune = abcParser.getTune();
              if (params.tablature) {
                tune.tablatures = tablatures.preparePlugins(tune, currentTune, params);
              }
              var warnings = abcParser.getWarnings();
              if (warnings)
                tune.warnings = warnings;
              var override = callback(div, tune, i2, book.tunes[currentTune].abc);
              ret.push(override ? override : tune);
            } else {
              if (div["innerHTML"])
                div.innerHTML = "";
            }
          }
          currentTune++;
        }
        return ret;
      };
      function flattenTune(tuneObj) {
        var staves = [];
        for (var j = 0; j < tuneObj.lines.length; j++) {
          var line = tuneObj.lines[j];
          if (line.staff) {
            for (var k = 0; k < line.staff.length; k++) {
              var staff = line.staff[k];
              if (!staves[k])
                staves[k] = staff;
              else {
                for (var i2 = 0; i2 < staff.voices.length; i2++) {
                  if (staves[k].voices[i2])
                    staves[k].voices[i2] = staves[k].voices[i2].concat(staff.voices[i2]);
                }
              }
            }
          }
        }
        return staves;
      }
      function measuresParser(staff, tune) {
        var voices = [];
        var lastChord = null;
        var measureStartChord = null;
        var fragStart = null;
        var hasNotes = false;
        for (var i2 = 0; i2 < staff.voices.length; i2++) {
          var voice = staff.voices[i2];
          voices.push([]);
          for (var j = 0; j < voice.length; j++) {
            var elem = voice[j];
            if (fragStart === null && elem.startChar >= 0) {
              fragStart = elem.startChar;
              if (elem.chord === void 0)
                measureStartChord = lastChord;
              else
                measureStartChord = null;
            }
            if (elem.chord)
              lastChord = elem;
            if (elem.el_type === "bar") {
              if (hasNotes) {
                var frag = tune.abc.substring(fragStart, elem.endChar);
                var measure = { abc: frag };
                lastChord = measureStartChord && measureStartChord.chord && measureStartChord.chord.length > 0 ? measureStartChord.chord[0].name : null;
                if (lastChord)
                  measure.lastChord = lastChord;
                if (elem.startEnding)
                  measure.startEnding = elem.startEnding;
                if (elem.endEnding)
                  measure.endEnding = elem.endEnding;
                voices[i2].push(measure);
                fragStart = null;
                hasNotes = false;
              }
            } else if (elem.el_type === "note") {
              hasNotes = true;
            }
          }
        }
        return voices;
      }
      tunebook.extractMeasures = function(abc) {
        var tunes = [];
        var book = new TuneBook(abc);
        for (var i2 = 0; i2 < book.tunes.length; i2++) {
          var tune = book.tunes[i2];
          var arr = tune.abc.split("K:");
          var arr2 = arr[1].split("\n");
          var header = arr[0] + "K:" + arr2[0] + "\n";
          var lastChord = null;
          var measureStartChord = null;
          var fragStart = null;
          var measures = [];
          var hasNotes = false;
          var tuneObj = tunebook.parseOnly(tune.abc)[0];
          var hasPickup = tuneObj.getPickupLength() > 0;
          for (var j = 0; j < tuneObj.lines.length; j++) {
            var line = tuneObj.lines[j];
            if (line.staff) {
              for (var k = 0; k < 1; k++) {
                var staff = line.staff[k];
                for (var kk = 0; kk < 1; kk++) {
                  var voice = staff.voices[kk];
                  for (var kkk = 0; kkk < voice.length; kkk++) {
                    var elem = voice[kkk];
                    if (fragStart === null && elem.startChar >= 0) {
                      fragStart = elem.startChar;
                      if (elem.chord === void 0)
                        measureStartChord = lastChord;
                      else
                        measureStartChord = null;
                    }
                    if (elem.chord)
                      lastChord = elem;
                    if (elem.el_type === "bar") {
                      if (hasNotes) {
                        var frag = tune.abc.substring(fragStart, elem.endChar);
                        var measure = { abc: frag };
                        lastChord = measureStartChord && measureStartChord.chord && measureStartChord.chord.length > 0 ? measureStartChord.chord[0].name : null;
                        if (lastChord)
                          measure.lastChord = lastChord;
                        if (elem.startEnding)
                          measure.startEnding = elem.startEnding;
                        if (elem.endEnding)
                          measure.endEnding = elem.endEnding;
                        measures.push(measure);
                        fragStart = null;
                        hasNotes = false;
                      }
                    } else if (elem.el_type === "note") {
                      hasNotes = true;
                    }
                  }
                }
              }
            }
          }
          tunes.push({
            header,
            measures,
            hasPickup
          });
        }
        return tunes;
      };
    })();
    module.exports = tunebook;
  }
});

// node_modules/abcjs/src/str/output.js
var require_output = __commonJS({
  "node_modules/abcjs/src/str/output.js"(exports, module) {
    var keyAccidentals = require_key_accidentals();
    var { relativeMajor, transposeKey, relativeMode } = require_relative_major();
    var transposeChordName = require_transpose_chord();
    var strTranspose;
    (function() {
      "use strict";
      strTranspose = function(abc, abcTune, steps) {
        if (abcTune === "TEST")
          return { keyAccidentals, relativeMajor, transposeKey, relativeMode, transposeChordName };
        steps = parseInt(steps, 10);
        var changes = [];
        var i2;
        for (i2 = 0; i2 < abcTune.length; i2++)
          changes = changes.concat(transposeOneTune(abc, abcTune[i2], steps));
        changes = changes.sort(function(a, b) {
          return b.start - a.start;
        });
        var output = abc.split("");
        for (i2 = 0; i2 < changes.length; i2++) {
          var ch = changes[i2];
          output.splice(ch.start, ch.end - ch.start, ch.note);
        }
        return output.join("");
      };
      function transposeOneTune(abc, abcTune, steps) {
        var changes = [];
        var key = abcTune.getKeySignature();
        if (key.root === "Hp" || key.root === "HP")
          return changes;
        changes = changes.concat(changeAllKeySigs(abc, steps));
        for (var i2 = 0; i2 < abcTune.lines.length; i2++) {
          var staves = abcTune.lines[i2].staff;
          if (staves) {
            for (var j = 0; j < staves.length; j++) {
              var staff = staves[j];
              if (staff.clef.type !== "perc")
                changes = changes.concat(transposeVoices(abc, staff.voices, staff.key, steps));
            }
          }
        }
        return changes;
      }
      function changeAllKeySigs(abc, steps) {
        var changes = [];
        var arr = abc.split("K:");
        var count = arr[0].length;
        for (var i2 = 1; i2 < arr.length; i2++) {
          var segment = arr[i2];
          var match = segment.match(/^( *)([A-G])([#b]?)(\w*)/);
          if (match) {
            var start = count + 2 + match[1].length;
            var key = match[2] + match[3] + match[4];
            var destinationKey = newKey({ root: match[2], acc: match[3], mode: match[4] }, steps);
            var dest = destinationKey.root + destinationKey.acc + destinationKey.mode;
            changes.push({ start, end: start + key.length, note: dest });
          }
          count += segment.length + 2;
        }
        return changes;
      }
      function transposeVoices(abc, voices, key, steps) {
        var changes = [];
        var destinationKey = newKey(key, steps);
        for (var i2 = 0; i2 < voices.length; i2++) {
          changes = changes.concat(transposeVoice(abc, voices[i2], key.root, createKeyAccidentals(key), destinationKey, steps));
        }
        return changes;
      }
      function createKeyAccidentals(key) {
        var ret = {};
        for (var i2 = 0; i2 < key.accidentals.length; i2++) {
          var acc = key.accidentals[i2];
          if (acc.acc === "flat")
            ret[acc.note.toUpperCase()] = "_";
          else if (acc.acc === "sharp")
            ret[acc.note.toUpperCase()] = "^";
        }
        return ret;
      }
      function setLetterDistance(destinationKey, keyRoot, steps) {
        var letterDistance = letters.indexOf(destinationKey.root) - letters.indexOf(keyRoot);
        if (keyRoot === "none")
          letterDistance = letters.indexOf(destinationKey.root);
        if (letterDistance === 0) {
          if (steps > 2)
            letterDistance += 7;
          else if (steps === -12)
            letterDistance -= 7;
        } else if (steps > 0 && letterDistance < 0)
          letterDistance += 7;
        else if (steps < 0 && letterDistance > 0)
          letterDistance -= 7;
        if (steps > 12)
          letterDistance += 7;
        else if (steps < -12)
          letterDistance -= 7;
        return letterDistance;
      }
      function transposeVoice(abc, voice, keyRoot, keyAccidentals2, destinationKey, steps) {
        var changes = [];
        var letterDistance = setLetterDistance(destinationKey, keyRoot, steps);
        var measureAccidentals = {};
        var transposedMeasureAccidentals = {};
        for (var i2 = 0; i2 < voice.length; i2++) {
          var el = voice[i2];
          if (el.chord) {
            for (var c = 0; c < el.chord.length; c++) {
              var ch = el.chord[c];
              if (ch.position === "default") {
                var prefersFlats = destinationKey.accidentals.length && destinationKey.accidentals[0].acc === "flat";
                var newChord = transposeChordName(ch.name, steps, prefersFlats, true);
                newChord = newChord.replace(/♭/g, "b").replace(/♯/g, "#");
                if (newChord !== ch.name)
                  changes.push(replaceChord(abc, el.startChar, el.endChar, newChord));
              }
            }
          }
          if (el.el_type === "note" && el.pitches) {
            for (var j = 0; j < el.pitches.length; j++) {
              var note = parseNote(el.pitches[j].name, keyRoot, keyAccidentals2, measureAccidentals);
              if (note.acc)
                measureAccidentals[note.name.toUpperCase()] = note.acc;
              var newPitch = transposePitch(note, destinationKey, letterDistance, transposedMeasureAccidentals);
              if (newPitch.acc)
                transposedMeasureAccidentals[newPitch.upper] = newPitch.acc;
              changes.push(replaceNote(abc, el.startChar, el.endChar, newPitch.acc + newPitch.name, j));
            }
            if (el.gracenotes) {
              for (var g = 0; g < el.gracenotes.length; g++) {
                var grace = parseNote(el.gracenotes[g].name, keyRoot, keyAccidentals2, measureAccidentals);
                if (grace.acc)
                  measureAccidentals[grace.name.toUpperCase()] = grace.acc;
                var newGrace = transposePitch(grace, destinationKey, letterDistance, measureAccidentals);
                if (newGrace.acc)
                  transposedMeasureAccidentals[newGrace.upper] = newGrace.acc;
                changes.push(replaceGrace(abc, el.startChar, el.endChar, newGrace.acc + newGrace.name, g));
              }
            }
          } else if (el.el_type === "bar") {
            measureAccidentals = {};
            transposedMeasureAccidentals = {};
          } else if (el.el_type === "keySignature") {
            keyRoot = el.root;
            keyAccidentals2 = createKeyAccidentals(el);
            destinationKey = newKey(el, steps);
            letterDistance = setLetterDistance(destinationKey, keyRoot, steps);
          }
        }
        return changes;
      }
      var letters = "CDEFGAB";
      var octaves = [",,,,", ",,,", ",,", ",", "", "'", "''", "'''", "''''"];
      function newKey(key, steps) {
        if (key.root === "none") {
          return { root: transposeKey("C", steps), mode: "", acc: "", accidentals: [] };
        }
        var major = relativeMajor(key.root + key.acc + key.mode);
        var newMajor = transposeKey(major, steps);
        var newMode = relativeMode(newMajor, key.mode);
        var acc = keyAccidentals(newMajor);
        return { root: newMode[0], mode: key.mode, acc: newMode.length > 1 ? newMode[1] : "", accidentals: acc };
      }
      function transposePitch(note, key, letterDistance, measureAccidentals) {
        var pitch = note.pitch;
        var origDistFromC = letters.indexOf(note.name);
        var root = letters.indexOf(key.root);
        var index = (root + pitch) % 7;
        var newDistFromC = origDistFromC + letterDistance;
        var oct = note.oct;
        while (newDistFromC > 6) {
          oct++;
          newDistFromC -= 7;
        }
        while (newDistFromC < 0) {
          oct--;
          newDistFromC += 7;
        }
        var name = letters[index];
        var acc = "";
        var adj = note.adj;
        var keyAcc = "=";
        for (var i2 = 0; i2 < key.accidentals.length; i2++) {
          if (key.accidentals[i2].note.toLowerCase() === name.toLowerCase()) {
            adj = adj + (key.accidentals[i2].acc === "flat" ? -1 : 1);
            keyAcc = key.accidentals[i2].acc === "flat" ? "_" : "^";
            break;
          }
        }
        switch (adj) {
          case -2:
            acc = "__";
            break;
          case -1:
            acc = "_";
            break;
          case 0:
            acc = "=";
            break;
          case 1:
            acc = "^";
            break;
          case 2:
            acc = "^^";
            break;
          case -3:
            var newNote = {};
            newNote.pitch = note.pitch - 1;
            newNote.oct = note.oct;
            newNote.name = letters[letters.indexOf(note.name) - 1];
            if (!newNote.name) {
              newNote.name = "B";
              newNote.oct--;
            }
            if (newNote.name === "B" || newNote.name === "E")
              newNote.adj = note.adj + 1;
            else
              newNote.adj = note.adj + 2;
            return transposePitch(newNote, key, letterDistance + 1, measureAccidentals);
          case 3:
            var newNote = {};
            newNote.pitch = note.pitch + 1;
            newNote.oct = note.oct;
            newNote.name = letters[letters.indexOf(note.name) + 1];
            if (!newNote.name) {
              newNote.name = "C";
              newNote.oct++;
            }
            if (newNote.name === "C" || newNote.name === "F")
              newNote.adj = note.adj - 1;
            else
              newNote.adj = note.adj - 2;
            return transposePitch(newNote, key, letterDistance + 1, measureAccidentals);
        }
        if ((measureAccidentals[name] === acc || !measureAccidentals[name] && acc === keyAcc) && !note.courtesy)
          acc = "";
        switch (oct) {
          case 0:
            name = name + ",,,";
            break;
          case 1:
            name = name + ",,";
            break;
          case 2:
            name = name + ",";
            break;
          // case 3: it is already correct
          case 4:
            name = name.toLowerCase();
            break;
          case 5:
            name = name.toLowerCase() + "'";
            break;
          case 6:
            name = name.toLowerCase() + "''";
            break;
          case 7:
            name = name.toLowerCase() + "'''";
            break;
          case 8:
            name = name.toLowerCase() + "''''";
            break;
        }
        if (oct > 4)
          name = name.toLowerCase();
        return { acc, name, upper: name.toUpperCase() };
      }
      var regPitch = /([_^=]*)([A-Ga-g])([,']*)/;
      var regNote = /([_^=]*[A-Ga-g][,']*)(\d*\/*\d*)([\>\<\-\)\.\s\\]*)/;
      var regOptionalNote = /([_^=]*[A-Ga-g][,']*)?(\d*\/*\d*)?([\>\<\-\)]*)?/;
      var regSpace = /(\s*)$/;
      function parseNote(note, keyRoot, keyAccidentals2, measureAccidentals) {
        var root = keyRoot === "none" ? 0 : letters.indexOf(keyRoot);
        var reg = note.match(regPitch);
        var name = reg[2].toUpperCase();
        var pos = letters.indexOf(name) - root;
        if (pos < 0) pos += 7;
        var oct = octaves.indexOf(reg[3]);
        if (name === reg[2])
          oct--;
        var currentAcc = measureAccidentals[name] || keyAccidentals2[name] || "=";
        return { acc: reg[1], name, pitch: pos, oct, adj: calcAdjustment(reg[1], keyAccidentals2[name], measureAccidentals[name]), courtesy: reg[1] === currentAcc };
      }
      function replaceNote(abc, start, end, newPitch, index) {
        var note = abc.substring(start, end);
        var match = note.match(new RegExp(regNote.source + regSpace.source), "");
        if (match) {
          var noteLen = match[1].length;
          var trailingLen = match[2].length + match[3].length + match[4].length;
          var leadingLen = end - start - noteLen - trailingLen;
          start += leadingLen;
          end -= trailingLen;
        } else {
          var regPreBracket = /([^\[]*)/;
          var regOpenBracket = /\[/;
          var regCloseBracket = /\-?](\d*\/*\d*)?([\>\<\-\)]*)/;
          match = note.match(new RegExp(regPreBracket.source + regOpenBracket.source + regOptionalNote.source + regOptionalNote.source + regOptionalNote.source + regOptionalNote.source + regOptionalNote.source + regOptionalNote.source + regOptionalNote.source + regOptionalNote.source + regCloseBracket.source + regSpace.source));
          if (match) {
            var count = 1 + match[1].length;
            for (var i2 = 0; i2 < index; i2++) {
              if (match[i2 * 3 + 2])
                count += match[i2 * 3 + 2].length;
              if (match[i2 * 3 + 3])
                count += match[i2 * 3 + 3].length;
              if (match[i2 * 3 + 4])
                count += match[i2 * 3 + 4].length;
            }
            start += count;
            var endLen = match[index * 3 + 2] ? match[index * 3 + 2].length : 0;
            end = start + endLen;
          }
        }
        return { start, end, note: newPitch };
      }
      function replaceGrace(abc, start, end, newGrace, index) {
        var note = abc.substring(start, end);
        var regOpenBrace = /\{/;
        var regCloseBrace = /\}/;
        var regPreBrace = /([^\{]*)/;
        var regPreNote = /(\/*)/;
        var match = note.match(new RegExp(regPreBrace.source + regOpenBrace.source + regPreNote.source + regOptionalNote.source + regPreNote.source + regOptionalNote.source + regPreNote.source + regOptionalNote.source + regPreNote.source + regOptionalNote.source + regPreNote.source + regOptionalNote.source + regPreNote.source + regOptionalNote.source + regPreNote.source + regOptionalNote.source + regPreNote.source + regOptionalNote.source + regCloseBrace.source));
        if (match) {
          var count = 1 + match[1].length;
          for (var i2 = 0; i2 < index; i2++) {
            if (match[i2 * 3 + 2])
              count += match[i2 * 3 + 2].length;
            if (match[i2 * 3 + 3])
              count += match[i2 * 3 + 3].length;
            if (match[i2 * 3 + 4])
              count += match[i2 * 3 + 4].length;
            if (match[i2 * 3 + 5])
              count += match[i2 * 3 + 5].length;
          }
          if (match[index * 3 + 2])
            count += match[i2 * 3 + 2].length;
          start += count;
          var endLen = match[index * 3 + 3] ? match[index * 3 + 3].length : 0;
          endLen += match[index * 3 + 4] ? match[index * 3 + 4].length : 0;
          endLen += match[index * 3 + 5] ? match[index * 3 + 5].length : 0;
          end = start + endLen;
        }
        return { start, end, note: newGrace };
      }
      function replaceChord(abc, start, end, newChord) {
        var match = abc.substring(start, end).match(/([^"]+)?(".+")+/);
        if (match[1])
          start += match[1].length;
        end = start + match[2].length;
        return { start: start + 1, end: end - 1, note: newChord };
      }
      function calcAdjustment(thisAccidental, keyAccidental, measureAccidental) {
        if (!thisAccidental && measureAccidental) {
          thisAccidental = measureAccidental;
        }
        if (!thisAccidental)
          return 0;
        switch (keyAccidental) {
          case void 0:
            switch (thisAccidental) {
              case "__":
                return -2;
              case "_":
                return -1;
              case "=":
                return 0;
              case "^":
                return 1;
              case "^^":
                return 2;
              default:
                return 0;
            }
          case "_":
            switch (thisAccidental) {
              case "__":
                return -1;
              case "_":
                return 0;
              case "=":
                return 1;
              case "^":
                return 2;
              case "^^":
                return 3;
              default:
                return 0;
            }
          case "^":
            switch (thisAccidental) {
              case "__":
                return -3;
              case "_":
                return -2;
              case "=":
                return -1;
              case "^":
                return 0;
              case "^^":
                return 1;
              default:
                return 0;
            }
        }
        return 0;
      }
    })();
    module.exports = strTranspose;
  }
});

// node_modules/abcjs/src/write/creation/elements/beam-element.js
var require_beam_element = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/beam-element.js"(exports, module) {
    var BeamElem = function BeamElem2(stemHeight, type, flat, firstElement) {
      this.type = "BeamElem";
      this.isflat = !!flat;
      this.isgrace = !!(type && type === "grace");
      this.forceup = !!(this.isgrace || type && type === "up");
      this.forcedown = !!(type && type === "down");
      this.elems = [];
      this.total = 0;
      this.average = 6;
      this.allrests = true;
      this.stemHeight = stemHeight;
      this.beams = [];
      if (firstElement && firstElement.duration) {
        this.duration = firstElement.duration;
        if (firstElement.startTriplet) {
          this.duration *= firstElement.tripletMultiplier;
        }
        this.duration = Math.round(this.duration * 1e3) / 1e3;
      } else
        this.duration = 0;
    };
    BeamElem.prototype.setHint = function() {
      this.hint = true;
    };
    BeamElem.prototype.runningDirection = function(abcelem) {
      var pitch = abcelem.averagepitch;
      if (pitch === void 0) return;
      this.total = Math.round(this.total + pitch);
      if (!this.count)
        this.count = 0;
      this.count++;
    };
    BeamElem.prototype.add = function(abselem) {
      var pitch = abselem.abcelem.averagepitch;
      if (pitch === void 0) return;
      if (!abselem.abcelem.rest)
        this.allrests = false;
      abselem.beam = this;
      this.elems.push(abselem);
      this.total = Math.round(this.total + pitch);
      if (this.min === void 0 || abselem.abcelem.minpitch < this.min) {
        this.min = abselem.abcelem.minpitch;
      }
      if (this.max === void 0 || abselem.abcelem.maxpitch > this.max) {
        this.max = abselem.abcelem.maxpitch;
      }
    };
    BeamElem.prototype.addBeam = function(beam) {
      this.beams.push(beam);
    };
    BeamElem.prototype.setStemDirection = function() {
      this.average = calcAverage(this.total, this.count);
      if (this.forceup) {
        this.stemsUp = true;
      } else if (this.forcedown) {
        this.stemsUp = false;
      } else {
        var middleLine = 6;
        this.stemsUp = this.average < middleLine;
      }
      delete this.count;
      this.total = 0;
    };
    BeamElem.prototype.calcDir = function() {
      this.average = calcAverage(this.total, this.elems.length);
      if (this.forceup) {
        this.stemsUp = true;
      } else if (this.forcedown) {
        this.stemsUp = false;
      } else {
        var middleLine = 6;
        this.stemsUp = this.average < middleLine;
      }
      var dir = this.stemsUp ? "up" : "down";
      for (var i2 = 0; i2 < this.elems.length; i2++) {
        for (var j = 0; j < this.elems[i2].heads.length; j++) {
          this.elems[i2].heads[j].stemDir = dir;
        }
      }
    };
    function calcAverage(total, numElements) {
      if (!numElements)
        return 0;
      return total / numElements;
    }
    module.exports = BeamElem;
  }
});

// node_modules/abcjs/src/write/creation/elements/brace-element.js
var require_brace_element = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/brace-element.js"(exports, module) {
    var BraceElem = function BraceElem2(voice, type) {
      this.startVoice = voice;
      this.type = type;
    };
    BraceElem.prototype.setBottomStaff = function(voice) {
      this.endVoice = voice;
      if (this.startVoice.header && !this.endVoice.header) {
        this.header = this.startVoice.header;
        delete this.startVoice.header;
      }
    };
    BraceElem.prototype.continuing = function(voice) {
      this.lastContinuedVoice = voice;
    };
    BraceElem.prototype.getWidth = function() {
      return 10;
    };
    BraceElem.prototype.isStartVoice = function(voice) {
      if (this.startVoice && this.startVoice.staff && this.startVoice.staff.voices.length > 0 && this.startVoice.staff.voices[0] === voice)
        return true;
      return false;
    };
    module.exports = BraceElem;
  }
});

// node_modules/abcjs/src/write/creation/glyphs.js
var require_glyphs = __commonJS({
  "node_modules/abcjs/src/write/creation/glyphs.js"(exports, module) {
    var spacing = require_spacing();
    var glyphs = {
      "0": { d: [["M", 4.83, -14.97], ["c", 0.33, -0.03, 1.11, 0, 1.47, 0.06], ["c", 1.68, 0.36, 2.97, 1.59, 3.78, 3.6], ["c", 1.2, 2.97, 0.81, 6.96, -0.9, 9.27], ["c", -0.78, 1.08, -1.71, 1.71, -2.91, 1.95], ["c", -0.45, 0.09, -1.32, 0.09, -1.77, 0], ["c", -0.81, -0.18, -1.47, -0.51, -2.07, -1.02], ["c", -2.34, -2.07, -3.15, -6.72, -1.74, -10.2], ["c", 0.87, -2.16, 2.28, -3.42, 4.14, -3.66], ["z"], ["m", 1.11, 0.87], ["c", -0.21, -0.06, -0.69, -0.09, -0.87, -0.06], ["c", -0.54, 0.12, -0.87, 0.42, -1.17, 0.99], ["c", -0.36, 0.66, -0.51, 1.56, -0.6, 3], ["c", -0.03, 0.75, -0.03, 4.59, 0, 5.31], ["c", 0.09, 1.5, 0.27, 2.4, 0.6, 3.06], ["c", 0.24, 0.48, 0.57, 0.78, 0.96, 0.9], ["c", 0.27, 0.09, 0.78, 0.09, 1.05, 0], ["c", 0.39, -0.12, 0.72, -0.42, 0.96, -0.9], ["c", 0.33, -0.66, 0.51, -1.56, 0.6, -3.06], ["c", 0.03, -0.72, 0.03, -4.56, 0, -5.31], ["c", -0.09, -1.47, -0.27, -2.37, -0.6, -3.03], ["c", -0.24, -0.48, -0.54, -0.78, -0.93, -0.9], ["z"]], w: 10.78, h: 14.959 },
      "1": { d: [["M", 3.3, -15.06], ["c", 0.06, -0.06, 0.21, -0.03, 0.66, 0.15], ["c", 0.81, 0.39, 1.08, 0.39, 1.83, 0.03], ["c", 0.21, -0.09, 0.39, -0.15, 0.42, -0.15], ["c", 0.12, 0, 0.21, 0.09, 0.27, 0.21], ["c", 0.06, 0.12, 0.06, 0.33, 0.06, 5.94], ["c", 0, 3.93, 0, 5.85, 0.03, 6.03], ["c", 0.06, 0.36, 0.15, 0.69, 0.27, 0.96], ["c", 0.36, 0.75, 0.93, 1.17, 1.68, 1.26], ["c", 0.3, 0.03, 0.39, 0.09, 0.39, 0.3], ["c", 0, 0.15, -0.03, 0.18, -0.09, 0.24], ["c", -0.06, 0.06, -0.09, 0.06, -0.48, 0.06], ["c", -0.42, 0, -0.69, -0.03, -2.1, -0.24], ["c", -0.9, -0.15, -1.77, -0.15, -2.67, 0], ["c", -1.41, 0.21, -1.68, 0.24, -2.1, 0.24], ["c", -0.39, 0, -0.42, 0, -0.48, -0.06], ["c", -0.06, -0.06, -0.06, -0.09, -0.06, -0.24], ["c", 0, -0.21, 0.06, -0.27, 0.36, -0.3], ["c", 0.75, -0.09, 1.32, -0.51, 1.68, -1.26], ["c", 0.12, -0.27, 0.21, -0.6, 0.27, -0.96], ["c", 0.03, -0.18, 0.03, -1.59, 0.03, -4.29], ["c", 0, -3.87, 0, -4.05, -0.06, -4.14], ["c", -0.09, -0.15, -0.18, -0.24, -0.39, -0.24], ["c", -0.12, 0, -0.15, 0.03, -0.21, 0.06], ["c", -0.03, 0.06, -0.45, 0.99, -0.96, 2.13], ["c", -0.48, 1.14, -0.9, 2.1, -0.93, 2.16], ["c", -0.06, 0.15, -0.21, 0.24, -0.33, 0.24], ["c", -0.24, 0, -0.42, -0.18, -0.42, -0.39], ["c", 0, -0.06, 3.27, -7.62, 3.33, -7.74], ["z"]], w: 8.94, h: 15.058 },
      "2": { d: [["M", 4.23, -14.97], ["c", 0.57, -0.06, 1.68, 0, 2.34, 0.18], ["c", 0.69, 0.18, 1.5, 0.54, 2.01, 0.9], ["c", 1.35, 0.96, 1.95, 2.25, 1.77, 3.81], ["c", -0.15, 1.35, -0.66, 2.34, -1.68, 3.15], ["c", -0.6, 0.48, -1.44, 0.93, -3.12, 1.65], ["c", -1.32, 0.57, -1.8, 0.81, -2.37, 1.14], ["c", -0.57, 0.33, -0.57, 0.33, -0.24, 0.27], ["c", 0.39, -0.09, 1.26, -0.09, 1.68, 0], ["c", 0.72, 0.15, 1.41, 0.45, 2.1, 0.9], ["c", 0.99, 0.63, 1.86, 0.87, 2.55, 0.75], ["c", 0.24, -0.06, 0.42, -0.15, 0.57, -0.3], ["c", 0.12, -0.09, 0.3, -0.42, 0.3, -0.51], ["c", 0, -0.09, 0.12, -0.21, 0.24, -0.24], ["c", 0.18, -0.03, 0.39, 0.12, 0.39, 0.3], ["c", 0, 0.12, -0.15, 0.57, -0.3, 0.87], ["c", -0.54, 1.02, -1.56, 1.74, -2.79, 2.01], ["c", -0.42, 0.09, -1.23, 0.09, -1.62, 0.03], ["c", -0.81, -0.18, -1.32, -0.45, -2.01, -1.11], ["c", -0.45, -0.45, -0.63, -0.57, -0.96, -0.69], ["c", -0.84, -0.27, -1.89, 0.12, -2.25, 0.9], ["c", -0.12, 0.21, -0.21, 0.54, -0.21, 0.72], ["c", 0, 0.12, -0.12, 0.21, -0.27, 0.24], ["c", -0.15, 0, -0.27, -0.03, -0.33, -0.15], ["c", -0.09, -0.21, 0.09, -1.08, 0.33, -1.71], ["c", 0.24, -0.66, 0.66, -1.26, 1.29, -1.89], ["c", 0.45, -0.45, 0.9, -0.81, 1.92, -1.56], ["c", 1.29, -0.93, 1.89, -1.44, 2.34, -1.98], ["c", 0.87, -1.05, 1.26, -2.19, 1.2, -3.63], ["c", -0.06, -1.29, -0.39, -2.31, -0.96, -2.91], ["c", -0.36, -0.33, -0.72, -0.51, -1.17, -0.54], ["c", -0.84, -0.03, -1.53, 0.42, -1.59, 1.05], ["c", -0.03, 0.33, 0.12, 0.6, 0.57, 1.14], ["c", 0.45, 0.54, 0.54, 0.87, 0.42, 1.41], ["c", -0.15, 0.63, -0.54, 1.11, -1.08, 1.38], ["c", -0.63, 0.33, -1.2, 0.33, -1.83, 0], ["c", -0.24, -0.12, -0.33, -0.18, -0.54, -0.39], ["c", -0.18, -0.18, -0.27, -0.3, -0.36, -0.51], ["c", -0.24, -0.45, -0.27, -0.84, -0.21, -1.38], ["c", 0.12, -0.75, 0.45, -1.41, 1.02, -1.98], ["c", 0.72, -0.72, 1.74, -1.17, 2.85, -1.32], ["z"]], w: 10.764, h: 14.97 },
      "3": { d: [["M", 3.78, -14.97], ["c", 0.3, -0.03, 1.41, 0, 1.83, 0.06], ["c", 2.22, 0.3, 3.51, 1.32, 3.72, 2.91], ["c", 0.03, 0.33, 0.03, 1.26, -0.03, 1.65], ["c", -0.12, 0.84, -0.48, 1.47, -1.05, 1.77], ["c", -0.27, 0.15, -0.36, 0.24, -0.45, 0.39], ["c", -0.09, 0.21, -0.09, 0.36, 0, 0.57], ["c", 0.09, 0.15, 0.18, 0.24, 0.51, 0.39], ["c", 0.75, 0.42, 1.23, 1.14, 1.41, 2.13], ["c", 0.06, 0.42, 0.06, 1.35, 0, 1.71], ["c", -0.18, 0.81, -0.48, 1.38, -1.02, 1.95], ["c", -0.75, 0.72, -1.8, 1.2, -3.18, 1.38], ["c", -0.42, 0.06, -1.56, 0.06, -1.95, 0], ["c", -1.89, -0.33, -3.18, -1.29, -3.51, -2.64], ["c", -0.03, -0.12, -0.03, -0.33, -0.03, -0.6], ["c", 0, -0.36, 0, -0.42, 0.06, -0.63], ["c", 0.12, -0.3, 0.27, -0.51, 0.51, -0.75], ["c", 0.24, -0.24, 0.45, -0.39, 0.75, -0.51], ["c", 0.21, -0.06, 0.27, -0.06, 0.6, -0.06], ["c", 0.33, 0, 0.39, 0, 0.6, 0.06], ["c", 0.3, 0.12, 0.51, 0.27, 0.75, 0.51], ["c", 0.36, 0.33, 0.57, 0.75, 0.6, 1.2], ["c", 0, 0.21, 0, 0.27, -0.06, 0.42], ["c", -0.09, 0.18, -0.12, 0.24, -0.54, 0.54], ["c", -0.51, 0.36, -0.63, 0.54, -0.6, 0.87], ["c", 0.06, 0.54, 0.54, 0.9, 1.38, 0.99], ["c", 0.36, 0.06, 0.72, 0.03, 0.96, -0.06], ["c", 0.81, -0.27, 1.29, -1.23, 1.44, -2.79], ["c", 0.03, -0.45, 0.03, -1.95, -0.03, -2.37], ["c", -0.09, -0.75, -0.33, -1.23, -0.75, -1.44], ["c", -0.33, -0.18, -0.45, -0.18, -1.98, -0.18], ["c", -1.35, 0, -1.41, 0, -1.5, -0.06], ["c", -0.18, -0.12, -0.24, -0.39, -0.12, -0.6], ["c", 0.12, -0.15, 0.15, -0.15, 1.68, -0.15], ["c", 1.5, 0, 1.62, 0, 1.89, -0.15], ["c", 0.18, -0.09, 0.42, -0.36, 0.54, -0.57], ["c", 0.18, -0.42, 0.27, -0.9, 0.3, -1.95], ["c", 0.03, -1.2, -0.06, -1.8, -0.36, -2.37], ["c", -0.24, -0.48, -0.63, -0.81, -1.14, -0.96], ["c", -0.3, -0.06, -1.08, -0.06, -1.38, 0.03], ["c", -0.6, 0.15, -0.9, 0.42, -0.96, 0.84], ["c", -0.03, 0.3, 0.06, 0.45, 0.63, 0.84], ["c", 0.33, 0.24, 0.42, 0.39, 0.45, 0.63], ["c", 0.03, 0.72, -0.57, 1.5, -1.32, 1.65], ["c", -1.05, 0.27, -2.1, -0.57, -2.1, -1.65], ["c", 0, -0.45, 0.15, -0.96, 0.39, -1.38], ["c", 0.12, -0.21, 0.54, -0.63, 0.81, -0.81], ["c", 0.57, -0.42, 1.38, -0.69, 2.25, -0.81], ["z"]], w: 9.735, h: 14.967 },
      "4": { d: [["M", 8.64, -14.94], ["c", 0.27, -0.09, 0.42, -0.12, 0.54, -0.03], ["c", 0.09, 0.06, 0.15, 0.21, 0.15, 0.3], ["c", -0.03, 0.06, -1.92, 2.31, -4.23, 5.04], ["c", -2.31, 2.73, -4.23, 4.98, -4.26, 5.01], ["c", -0.03, 0.06, 0.12, 0.06, 2.55, 0.06], ["l", 2.61, 0], ["l", 0, -2.37], ["c", 0, -2.19, 0.03, -2.37, 0.06, -2.46], ["c", 0.03, -0.06, 0.21, -0.18, 0.57, -0.42], ["c", 1.08, -0.72, 1.38, -1.08, 1.86, -2.16], ["c", 0.12, -0.3, 0.24, -0.54, 0.27, -0.57], ["c", 0.12, -0.12, 0.39, -0.06, 0.45, 0.12], ["c", 0.06, 0.09, 0.06, 0.57, 0.06, 3.96], ["l", 0, 3.9], ["l", 1.08, 0], ["c", 1.05, 0, 1.11, 0, 1.2, 0.06], ["c", 0.24, 0.15, 0.24, 0.54, 0, 0.69], ["c", -0.09, 0.06, -0.15, 0.06, -1.2, 0.06], ["l", -1.08, 0], ["l", 0, 0.33], ["c", 0, 0.57, 0.09, 1.11, 0.3, 1.53], ["c", 0.36, 0.75, 0.93, 1.17, 1.68, 1.26], ["c", 0.3, 0.03, 0.39, 0.09, 0.39, 0.3], ["c", 0, 0.15, -0.03, 0.18, -0.09, 0.24], ["c", -0.06, 0.06, -0.09, 0.06, -0.48, 0.06], ["c", -0.42, 0, -0.69, -0.03, -2.1, -0.24], ["c", -0.9, -0.15, -1.77, -0.15, -2.67, 0], ["c", -1.41, 0.21, -1.68, 0.24, -2.1, 0.24], ["c", -0.39, 0, -0.42, 0, -0.48, -0.06], ["c", -0.06, -0.06, -0.06, -0.09, -0.06, -0.24], ["c", 0, -0.21, 0.06, -0.27, 0.36, -0.3], ["c", 0.75, -0.09, 1.32, -0.51, 1.68, -1.26], ["c", 0.21, -0.42, 0.3, -0.96, 0.3, -1.53], ["l", 0, -0.33], ["l", -2.7, 0], ["c", -2.91, 0, -2.85, 0, -3.09, -0.15], ["c", -0.18, -0.12, -0.3, -0.39, -0.27, -0.54], ["c", 0.03, -0.06, 0.18, -0.24, 0.33, -0.45], ["c", 0.75, -0.9, 1.59, -2.07, 2.13, -3.03], ["c", 0.33, -0.54, 0.84, -1.62, 1.05, -2.16], ["c", 0.57, -1.41, 0.84, -2.64, 0.9, -4.05], ["c", 0.03, -0.63, 0.06, -0.72, 0.24, -0.81], ["l", 0.12, -0.06], ["l", 0.45, 0.12], ["c", 0.66, 0.18, 1.02, 0.24, 1.47, 0.27], ["c", 0.6, 0.03, 1.23, -0.09, 2.01, -0.33], ["z"]], w: 11.795, h: 14.994 },
      "5": { d: [["M", 1.02, -14.94], ["c", 0.12, -0.09, 0.03, -0.09, 1.08, 0.06], ["c", 2.49, 0.36, 4.35, 0.36, 6.96, -0.06], ["c", 0.57, -0.09, 0.66, -0.06, 0.81, 0.06], ["c", 0.15, 0.18, 0.12, 0.24, -0.15, 0.51], ["c", -1.29, 1.26, -3.24, 2.04, -5.58, 2.31], ["c", -0.6, 0.09, -1.2, 0.12, -1.71, 0.12], ["c", -0.39, 0, -0.45, 0, -0.57, 0.06], ["c", -0.09, 0.06, -0.15, 0.12, -0.21, 0.21], ["l", -0.06, 0.12], ["l", 0, 1.65], ["l", 0, 1.65], ["l", 0.21, -0.21], ["c", 0.66, -0.57, 1.41, -0.96, 2.19, -1.14], ["c", 0.33, -0.06, 1.41, -0.06, 1.95, 0], ["c", 2.61, 0.36, 4.02, 1.74, 4.26, 4.14], ["c", 0.03, 0.45, 0.03, 1.08, -0.03, 1.44], ["c", -0.18, 1.02, -0.78, 2.01, -1.59, 2.7], ["c", -0.72, 0.57, -1.62, 1.02, -2.49, 1.2], ["c", -1.38, 0.27, -3.03, 0.06, -4.2, -0.54], ["c", -1.08, -0.54, -1.71, -1.32, -1.86, -2.28], ["c", -0.09, -0.69, 0.09, -1.29, 0.57, -1.74], ["c", 0.24, -0.24, 0.45, -0.39, 0.75, -0.51], ["c", 0.21, -0.06, 0.27, -0.06, 0.6, -0.06], ["c", 0.33, 0, 0.39, 0, 0.6, 0.06], ["c", 0.3, 0.12, 0.51, 0.27, 0.75, 0.51], ["c", 0.36, 0.33, 0.57, 0.75, 0.6, 1.2], ["c", 0, 0.21, 0, 0.27, -0.06, 0.42], ["c", -0.09, 0.18, -0.12, 0.24, -0.54, 0.54], ["c", -0.18, 0.12, -0.36, 0.3, -0.42, 0.33], ["c", -0.36, 0.42, -0.18, 0.99, 0.36, 1.26], ["c", 0.51, 0.27, 1.47, 0.36, 2.01, 0.27], ["c", 0.93, -0.21, 1.47, -1.17, 1.65, -2.91], ["c", 0.06, -0.45, 0.06, -1.89, 0, -2.31], ["c", -0.15, -1.2, -0.51, -2.1, -1.05, -2.55], ["c", -0.21, -0.18, -0.54, -0.36, -0.81, -0.39], ["c", -0.3, -0.06, -0.84, -0.03, -1.26, 0.06], ["c", -0.93, 0.18, -1.65, 0.6, -2.16, 1.2], ["c", -0.15, 0.21, -0.27, 0.3, -0.39, 0.3], ["c", -0.15, 0, -0.3, -0.09, -0.36, -0.18], ["c", -0.06, -0.09, -0.06, -0.15, -0.06, -3.66], ["c", 0, -3.39, 0, -3.57, 0.06, -3.66], ["c", 0.03, -0.06, 0.09, -0.15, 0.15, -0.18], ["z"]], w: 10.212, h: 14.997 },
      "6": { d: [["M", 4.98, -14.97], ["c", 0.36, -0.03, 1.2, 0, 1.59, 0.06], ["c", 0.9, 0.15, 1.68, 0.51, 2.25, 1.05], ["c", 0.57, 0.51, 0.87, 1.23, 0.84, 1.98], ["c", -0.03, 0.51, -0.21, 0.9, -0.6, 1.26], ["c", -0.24, 0.24, -0.45, 0.39, -0.75, 0.51], ["c", -0.21, 0.06, -0.27, 0.06, -0.6, 0.06], ["c", -0.33, 0, -0.39, 0, -0.6, -0.06], ["c", -0.3, -0.12, -0.51, -0.27, -0.75, -0.51], ["c", -0.39, -0.36, -0.57, -0.78, -0.57, -1.26], ["c", 0, -0.27, 0, -0.3, 0.09, -0.42], ["c", 0.03, -0.09, 0.18, -0.21, 0.3, -0.3], ["c", 0.12, -0.09, 0.3, -0.21, 0.39, -0.27], ["c", 0.09, -0.06, 0.21, -0.18, 0.27, -0.24], ["c", 0.06, -0.12, 0.09, -0.15, 0.09, -0.33], ["c", 0, -0.18, -0.03, -0.24, -0.09, -0.36], ["c", -0.24, -0.39, -0.75, -0.6, -1.38, -0.57], ["c", -0.54, 0.03, -0.9, 0.18, -1.23, 0.48], ["c", -0.81, 0.72, -1.08, 2.16, -0.96, 5.37], ["l", 0, 0.63], ["l", 0.3, -0.12], ["c", 0.78, -0.27, 1.29, -0.33, 2.1, -0.27], ["c", 1.47, 0.12, 2.49, 0.54, 3.27, 1.29], ["c", 0.48, 0.51, 0.81, 1.11, 0.96, 1.89], ["c", 0.06, 0.27, 0.06, 0.42, 0.06, 0.93], ["c", 0, 0.54, 0, 0.69, -0.06, 0.96], ["c", -0.15, 0.78, -0.48, 1.38, -0.96, 1.89], ["c", -0.54, 0.51, -1.17, 0.87, -1.98, 1.08], ["c", -1.14, 0.3, -2.4, 0.33, -3.24, 0.03], ["c", -1.5, -0.48, -2.64, -1.89, -3.27, -4.02], ["c", -0.36, -1.23, -0.51, -2.82, -0.42, -4.08], ["c", 0.3, -3.66, 2.28, -6.3, 4.95, -6.66], ["z"], ["m", 0.66, 7.41], ["c", -0.27, -0.09, -0.81, -0.12, -1.08, -0.06], ["c", -0.72, 0.18, -1.08, 0.69, -1.23, 1.71], ["c", -0.06, 0.54, -0.06, 3, 0, 3.54], ["c", 0.18, 1.26, 0.72, 1.77, 1.8, 1.74], ["c", 0.39, -0.03, 0.63, -0.09, 0.9, -0.27], ["c", 0.66, -0.42, 0.9, -1.32, 0.9, -3.24], ["c", 0, -2.22, -0.36, -3.12, -1.29, -3.42], ["z"]], w: 9.956, h: 14.982 },
      "7": { d: [["M", 0.21, -14.97], ["c", 0.21, -0.06, 0.45, 0, 0.54, 0.15], ["c", 0.06, 0.09, 0.06, 0.15, 0.06, 0.39], ["c", 0, 0.24, 0, 0.33, 0.06, 0.42], ["c", 0.06, 0.12, 0.21, 0.24, 0.27, 0.24], ["c", 0.03, 0, 0.12, -0.12, 0.24, -0.21], ["c", 0.96, -1.2, 2.58, -1.35, 3.99, -0.42], ["c", 0.15, 0.12, 0.42, 0.3, 0.54, 0.45], ["c", 0.48, 0.39, 0.81, 0.57, 1.29, 0.6], ["c", 0.69, 0.03, 1.5, -0.3, 2.13, -0.87], ["c", 0.09, -0.09, 0.27, -0.3, 0.39, -0.45], ["c", 0.12, -0.15, 0.24, -0.27, 0.3, -0.3], ["c", 0.18, -0.06, 0.39, 0.03, 0.51, 0.21], ["c", 0.06, 0.18, 0.06, 0.24, -0.27, 0.72], ["c", -0.18, 0.24, -0.54, 0.78, -0.78, 1.17], ["c", -2.37, 3.54, -3.54, 6.27, -3.87, 9], ["c", -0.03, 0.33, -0.03, 0.66, -0.03, 1.26], ["c", 0, 0.9, 0, 1.08, 0.15, 1.89], ["c", 0.06, 0.45, 0.06, 0.48, 0.03, 0.6], ["c", -0.06, 0.09, -0.21, 0.21, -0.3, 0.21], ["c", -0.03, 0, -0.27, -0.06, -0.54, -0.15], ["c", -0.84, -0.27, -1.11, -0.3, -1.65, -0.3], ["c", -0.57, 0, -0.84, 0.03, -1.56, 0.27], ["c", -0.6, 0.18, -0.69, 0.21, -0.81, 0.15], ["c", -0.12, -0.06, -0.21, -0.18, -0.21, -0.3], ["c", 0, -0.15, 0.6, -1.44, 1.2, -2.61], ["c", 1.14, -2.22, 2.73, -4.68, 5.1, -8.01], ["c", 0.21, -0.27, 0.36, -0.48, 0.33, -0.48], ["c", 0, 0, -0.12, 0.06, -0.27, 0.12], ["c", -0.54, 0.3, -0.99, 0.39, -1.56, 0.39], ["c", -0.75, 0.03, -1.2, -0.18, -1.83, -0.75], ["c", -0.99, -0.9, -1.83, -1.17, -2.31, -0.72], ["c", -0.18, 0.15, -0.36, 0.51, -0.45, 0.84], ["c", -0.06, 0.24, -0.06, 0.33, -0.09, 1.98], ["c", 0, 1.62, -0.03, 1.74, -0.06, 1.8], ["c", -0.15, 0.24, -0.54, 0.24, -0.69, 0], ["c", -0.06, -0.09, -0.06, -0.15, -0.06, -3.57], ["c", 0, -3.42, 0, -3.48, 0.06, -3.57], ["c", 0.03, -0.06, 0.09, -0.12, 0.15, -0.15], ["z"]], w: 10.561, h: 15.093 },
      "8": { d: [["M", 4.98, -14.97], ["c", 0.33, -0.03, 1.02, -0.03, 1.32, 0], ["c", 1.32, 0.12, 2.49, 0.6, 3.21, 1.32], ["c", 0.39, 0.39, 0.66, 0.81, 0.78, 1.29], ["c", 0.09, 0.36, 0.09, 1.08, 0, 1.44], ["c", -0.21, 0.84, -0.66, 1.59, -1.59, 2.55], ["l", -0.3, 0.3], ["l", 0.27, 0.18], ["c", 1.47, 0.93, 2.31, 2.31, 2.25, 3.75], ["c", -0.03, 0.75, -0.24, 1.35, -0.63, 1.95], ["c", -0.45, 0.66, -1.02, 1.14, -1.83, 1.53], ["c", -1.8, 0.87, -4.2, 0.87, -6, 0.03], ["c", -1.62, -0.78, -2.52, -2.16, -2.46, -3.66], ["c", 0.06, -0.99, 0.54, -1.77, 1.8, -2.97], ["c", 0.54, -0.51, 0.54, -0.54, 0.48, -0.57], ["c", -0.39, -0.27, -0.96, -0.78, -1.2, -1.14], ["c", -0.75, -1.11, -0.87, -2.4, -0.3, -3.6], ["c", 0.69, -1.35, 2.25, -2.25, 4.2, -2.4], ["z"], ["m", 1.53, 0.69], ["c", -0.42, -0.09, -1.11, -0.12, -1.38, -0.06], ["c", -0.3, 0.06, -0.6, 0.18, -0.81, 0.3], ["c", -0.21, 0.12, -0.6, 0.51, -0.72, 0.72], ["c", -0.51, 0.87, -0.42, 1.89, 0.21, 2.52], ["c", 0.21, 0.21, 0.36, 0.3, 1.95, 1.23], ["c", 0.96, 0.54, 1.74, 0.99, 1.77, 1.02], ["c", 0.09, 0, 0.63, -0.6, 0.99, -1.11], ["c", 0.21, -0.36, 0.48, -0.87, 0.57, -1.23], ["c", 0.06, -0.24, 0.06, -0.36, 0.06, -0.72], ["c", 0, -0.45, -0.03, -0.66, -0.15, -0.99], ["c", -0.39, -0.81, -1.29, -1.44, -2.49, -1.68], ["z"], ["m", -1.44, 8.07], ["l", -1.89, -1.08], ["c", -0.03, 0, -0.18, 0.15, -0.39, 0.33], ["c", -1.2, 1.08, -1.65, 1.95, -1.59, 3], ["c", 0.09, 1.59, 1.35, 2.85, 3.21, 3.24], ["c", 0.33, 0.06, 0.45, 0.06, 0.93, 0.06], ["c", 0.63, 0, 0.81, -0.03, 1.29, -0.27], ["c", 0.9, -0.42, 1.47, -1.41, 1.41, -2.4], ["c", -0.06, -0.66, -0.39, -1.29, -0.9, -1.65], ["c", -0.12, -0.09, -1.05, -0.63, -2.07, -1.23], ["z"]], w: 10.926, h: 14.989 },
      "9": { d: [["M", 4.23, -14.97], ["c", 0.42, -0.03, 1.29, 0, 1.62, 0.06], ["c", 0.51, 0.12, 0.93, 0.3, 1.38, 0.57], ["c", 1.53, 1.02, 2.52, 3.24, 2.73, 5.94], ["c", 0.18, 2.55, -0.48, 4.98, -1.83, 6.57], ["c", -1.05, 1.26, -2.4, 1.89, -3.93, 1.83], ["c", -1.23, -0.06, -2.31, -0.45, -3.03, -1.14], ["c", -0.57, -0.51, -0.87, -1.23, -0.84, -1.98], ["c", 0.03, -0.51, 0.21, -0.9, 0.6, -1.26], ["c", 0.24, -0.24, 0.45, -0.39, 0.75, -0.51], ["c", 0.21, -0.06, 0.27, -0.06, 0.6, -0.06], ["c", 0.33, 0, 0.39, 0, 0.6, 0.06], ["c", 0.3, 0.12, 0.51, 0.27, 0.75, 0.51], ["c", 0.39, 0.36, 0.57, 0.78, 0.57, 1.26], ["c", 0, 0.27, 0, 0.3, -0.09, 0.42], ["c", -0.03, 0.09, -0.18, 0.21, -0.3, 0.3], ["c", -0.12, 0.09, -0.3, 0.21, -0.39, 0.27], ["c", -0.09, 0.06, -0.21, 0.18, -0.27, 0.24], ["c", -0.06, 0.12, -0.06, 0.15, -0.06, 0.33], ["c", 0, 0.18, 0, 0.24, 0.06, 0.36], ["c", 0.24, 0.39, 0.75, 0.6, 1.38, 0.57], ["c", 0.54, -0.03, 0.9, -0.18, 1.23, -0.48], ["c", 0.81, -0.72, 1.08, -2.16, 0.96, -5.37], ["l", 0, -0.63], ["l", -0.3, 0.12], ["c", -0.78, 0.27, -1.29, 0.33, -2.1, 0.27], ["c", -1.47, -0.12, -2.49, -0.54, -3.27, -1.29], ["c", -0.48, -0.51, -0.81, -1.11, -0.96, -1.89], ["c", -0.06, -0.27, -0.06, -0.42, -0.06, -0.96], ["c", 0, -0.51, 0, -0.66, 0.06, -0.93], ["c", 0.15, -0.78, 0.48, -1.38, 0.96, -1.89], ["c", 0.15, -0.12, 0.33, -0.27, 0.42, -0.36], ["c", 0.69, -0.51, 1.62, -0.81, 2.76, -0.93], ["z"], ["m", 1.17, 0.66], ["c", -0.21, -0.06, -0.57, -0.06, -0.81, -0.03], ["c", -0.78, 0.12, -1.26, 0.69, -1.41, 1.74], ["c", -0.12, 0.63, -0.15, 1.95, -0.09, 2.79], ["c", 0.12, 1.71, 0.63, 2.4, 1.77, 2.46], ["c", 1.08, 0.03, 1.62, -0.48, 1.8, -1.74], ["c", 0.06, -0.54, 0.06, -3, 0, -3.54], ["c", -0.15, -1.05, -0.51, -1.53, -1.26, -1.68], ["z"]], w: 9.959, h: 14.986 },
      "rests.multimeasure": { d: [["M", 0, -4], ["l", 0, 16], ["l", 1, 0], ["l", 0, -5], ["l", 40, 0], ["l", 0, 5], ["l", 1, 0], ["l", 0, -16], ["l", -1, 0], ["l", 0, 5], ["l", -40, 0], ["l", 0, -5], ["z"]], w: 42, h: 18 },
      "rests.whole": { d: [["M", 0.06, 0.03], ["l", 0.09, -0.06], ["l", 5.46, 0], ["l", 5.49, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 2.19], ["l", 0, 2.19], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -5.49, 0], ["l", -5.46, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -2.19], ["l", 0, -2.19], ["z"]], w: 11.25, h: 4.68 },
      "rests.half": { d: [["M", 0.06, -4.62], ["l", 0.09, -0.06], ["l", 5.46, 0], ["l", 5.49, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 2.19], ["l", 0, 2.19], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -5.49, 0], ["l", -5.46, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -2.19], ["l", 0, -2.19], ["z"]], w: 11.25, h: 4.68 },
      "rests.quarter": { d: [["M", 1.89, -11.82], ["c", 0.12, -0.06, 0.24, -0.06, 0.36, -0.03], ["c", 0.09, 0.06, 4.74, 5.58, 4.86, 5.82], ["c", 0.21, 0.39, 0.15, 0.78, -0.15, 1.26], ["c", -0.24, 0.33, -0.72, 0.81, -1.62, 1.56], ["c", -0.45, 0.36, -0.87, 0.75, -0.96, 0.84], ["c", -0.93, 0.99, -1.14, 2.49, -0.6, 3.63], ["c", 0.18, 0.39, 0.27, 0.48, 1.32, 1.68], ["c", 1.92, 2.25, 1.83, 2.16, 1.83, 2.34], ["c", 0, 0.18, -0.18, 0.36, -0.36, 0.39], ["c", -0.15, 0, -0.27, -0.06, -0.48, -0.27], ["c", -0.75, -0.75, -2.46, -1.29, -3.39, -1.08], ["c", -0.45, 0.09, -0.69, 0.27, -0.9, 0.69], ["c", -0.12, 0.3, -0.21, 0.66, -0.24, 1.14], ["c", -0.03, 0.66, 0.09, 1.35, 0.3, 2.01], ["c", 0.15, 0.42, 0.24, 0.66, 0.45, 0.96], ["c", 0.18, 0.24, 0.18, 0.33, 0.03, 0.42], ["c", -0.12, 0.06, -0.18, 0.03, -0.45, -0.3], ["c", -1.08, -1.38, -2.07, -3.36, -2.4, -4.83], ["c", -0.27, -1.05, -0.15, -1.77, 0.27, -2.07], ["c", 0.21, -0.12, 0.42, -0.15, 0.87, -0.15], ["c", 0.87, 0.06, 2.1, 0.39, 3.3, 0.9], ["l", 0.39, 0.18], ["l", -1.65, -1.95], ["c", -2.52, -2.97, -2.61, -3.09, -2.7, -3.27], ["c", -0.09, -0.24, -0.12, -0.48, -0.03, -0.75], ["c", 0.15, -0.48, 0.57, -0.96, 1.83, -2.01], ["c", 0.45, -0.36, 0.84, -0.72, 0.93, -0.78], ["c", 0.69, -0.75, 1.02, -1.8, 0.9, -2.79], ["c", -0.06, -0.33, -0.21, -0.84, -0.39, -1.11], ["c", -0.09, -0.15, -0.45, -0.6, -0.81, -1.05], ["c", -0.36, -0.42, -0.69, -0.81, -0.72, -0.87], ["c", -0.09, -0.18, 0, -0.42, 0.21, -0.51], ["z"]], w: 7.888, h: 21.435 },
      "rests.8th": { d: [["M", 1.68, -6.12], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.12, 0, 0.18, 0, 0.33, -0.09], ["c", 0.39, -0.18, 1.32, -1.29, 1.68, -1.98], ["c", 0.09, -0.21, 0.24, -0.3, 0.39, -0.3], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.27, 1.11, -1.86, 6.42], ["c", -1.02, 3.48, -1.89, 6.39, -1.92, 6.42], ["c", 0, 0.03, -0.12, 0.12, -0.24, 0.15], ["c", -0.18, 0.09, -0.21, 0.09, -0.45, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.15, -0.57, 1.68, -4.92], ["c", 0.96, -2.67, 1.74, -4.89, 1.71, -4.89], ["l", -0.51, 0.15], ["c", -1.08, 0.36, -1.74, 0.48, -2.55, 0.48], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 7.534, h: 13.883 },
      "rests.16th": { d: [["M", 3.33, -6.12], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.15, 0.39, 0.57, 0.57, 0.87, 0.42], ["c", 0.39, -0.18, 1.2, -1.23, 1.62, -2.07], ["c", 0.06, -0.15, 0.24, -0.24, 0.36, -0.24], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.45, 1.86, -2.67, 10.17], ["c", -1.5, 5.55, -2.73, 10.14, -2.76, 10.17], ["c", -0.03, 0.03, -0.12, 0.12, -0.24, 0.15], ["c", -0.18, 0.09, -0.21, 0.09, -0.45, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.12, -0.57, 1.44, -4.92], ["c", 0.81, -2.67, 1.47, -4.86, 1.47, -4.89], ["c", -0.03, 0, -0.27, 0.06, -0.54, 0.15], ["c", -1.08, 0.36, -1.77, 0.48, -2.58, 0.48], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.09, 0.09, 0.27, 0.18, 0.45, 0.21], ["c", 0.12, 0, 0.18, 0, 0.33, -0.09], ["c", 0.33, -0.15, 1.02, -0.93, 1.41, -1.59], ["c", 0.12, -0.21, 0.18, -0.39, 0.39, -1.08], ["c", 0.66, -2.1, 1.17, -3.84, 1.17, -3.87], ["c", 0, 0, -0.21, 0.06, -0.42, 0.15], ["c", -0.51, 0.15, -1.2, 0.33, -1.68, 0.42], ["c", -0.33, 0.06, -0.51, 0.06, -0.96, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 9.724, h: 21.383 },
      "rests.32nd": { d: [["M", 4.23, -13.62], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.12, 0, 0.18, 0, 0.27, -0.06], ["c", 0.33, -0.21, 0.99, -1.11, 1.44, -1.98], ["c", 0.09, -0.24, 0.21, -0.33, 0.39, -0.33], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.57, 2.67, -3.21, 13.89], ["c", -1.8, 7.62, -3.3, 13.89, -3.3, 13.92], ["c", -0.03, 0.06, -0.12, 0.12, -0.24, 0.18], ["c", -0.21, 0.09, -0.24, 0.09, -0.48, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.09, -0.57, 1.23, -4.92], ["c", 0.69, -2.67, 1.26, -4.86, 1.29, -4.89], ["c", 0, -0.03, -0.12, -0.03, -0.48, 0.12], ["c", -1.17, 0.39, -2.22, 0.57, -3, 0.54], ["c", -0.42, -0.03, -0.75, -0.12, -1.11, -0.3], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.12, 0.09, 0.3, 0.18, 0.48, 0.21], ["c", 0.12, 0, 0.18, 0, 0.3, -0.09], ["c", 0.42, -0.21, 1.29, -1.29, 1.56, -1.89], ["c", 0.03, -0.12, 1.23, -4.59, 1.23, -4.65], ["c", 0, -0.03, -0.18, 0.03, -0.39, 0.12], ["c", -0.63, 0.18, -1.2, 0.36, -1.74, 0.45], ["c", -0.39, 0.06, -0.54, 0.06, -1.02, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.18, 0.18, 0.51, 0.27, 0.72, 0.15], ["c", 0.3, -0.12, 0.69, -0.57, 1.08, -1.17], ["c", 0.42, -0.6, 0.39, -0.51, 1.05, -3.03], ["c", 0.33, -1.26, 0.6, -2.31, 0.6, -2.34], ["c", 0, 0, -0.21, 0.03, -0.45, 0.12], ["c", -0.57, 0.18, -1.14, 0.33, -1.62, 0.42], ["c", -0.33, 0.06, -0.51, 0.06, -0.96, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 11.373, h: 28.883 },
      "rests.64th": { d: [["M", 5.13, -13.62], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.15, 0.63, 0.21, 0.81, 0.33, 0.96], ["c", 0.18, 0.21, 0.54, 0.3, 0.75, 0.18], ["c", 0.24, -0.12, 0.63, -0.66, 1.08, -1.56], ["c", 0.33, -0.66, 0.39, -0.72, 0.6, -0.72], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.69, 3.66, -3.54, 17.64], ["c", -1.95, 9.66, -3.57, 17.61, -3.57, 17.64], ["c", -0.03, 0.06, -0.12, 0.12, -0.24, 0.18], ["c", -0.21, 0.09, -0.24, 0.09, -0.48, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.06, -0.57, 1.05, -4.95], ["c", 0.6, -2.7, 1.08, -4.89, 1.08, -4.92], ["c", 0, 0, -0.24, 0.06, -0.51, 0.15], ["c", -0.66, 0.24, -1.2, 0.36, -1.77, 0.48], ["c", -0.42, 0.06, -0.57, 0.06, -1.05, 0.06], ["c", -0.69, 0, -0.87, -0.03, -1.35, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.09, 0.09, 0.27, 0.18, 0.45, 0.21], ["c", 0.21, 0.03, 0.39, -0.09, 0.72, -0.42], ["c", 0.45, -0.45, 1.02, -1.26, 1.17, -1.65], ["c", 0.03, -0.09, 0.27, -1.14, 0.54, -2.34], ["c", 0.27, -1.2, 0.48, -2.19, 0.51, -2.22], ["c", 0, -0.03, -0.09, -0.03, -0.48, 0.12], ["c", -1.17, 0.39, -2.22, 0.57, -3, 0.54], ["c", -0.42, -0.03, -0.75, -0.12, -1.11, -0.3], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.15, 0.39, 0.57, 0.57, 0.9, 0.42], ["c", 0.36, -0.18, 1.2, -1.26, 1.47, -1.89], ["c", 0.03, -0.09, 0.3, -1.2, 0.57, -2.43], ["l", 0.51, -2.28], ["l", -0.54, 0.18], ["c", -1.11, 0.36, -1.8, 0.48, -2.61, 0.48], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.15, 0.63, 0.21, 0.81, 0.33, 0.96], ["c", 0.21, 0.21, 0.54, 0.3, 0.75, 0.18], ["c", 0.36, -0.18, 0.93, -0.93, 1.29, -1.68], ["c", 0.12, -0.24, 0.18, -0.48, 0.63, -2.55], ["l", 0.51, -2.31], ["c", 0, -0.03, -0.18, 0.03, -0.39, 0.12], ["c", -1.14, 0.36, -2.1, 0.54, -2.82, 0.51], ["c", -0.42, -0.03, -0.75, -0.12, -1.11, -0.3], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 12.453, h: 36.383 },
      "rests.128th": { d: [["M", 6.03, -21.12], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.21, 0, 0.33, -0.06, 0.54, -0.36], ["c", 0.15, -0.21, 0.54, -0.93, 0.78, -1.47], ["c", 0.15, -0.33, 0.18, -0.39, 0.3, -0.48], ["c", 0.18, -0.09, 0.45, 0, 0.51, 0.15], ["c", 0.03, 0.09, -7.11, 42.75, -7.17, 42.84], ["c", -0.03, 0.03, -0.15, 0.09, -0.24, 0.15], ["c", -0.18, 0.06, -0.24, 0.06, -0.45, 0.06], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.03, -0.57, 0.84, -4.98], ["c", 0.51, -2.7, 0.93, -4.92, 0.9, -4.92], ["c", 0, 0, -0.15, 0.06, -0.36, 0.12], ["c", -0.78, 0.27, -1.62, 0.48, -2.31, 0.57], ["c", -0.15, 0.03, -0.54, 0.03, -0.81, 0.03], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.63, 0.48], ["c", 0.12, 0, 0.18, 0, 0.3, -0.09], ["c", 0.42, -0.21, 1.14, -1.11, 1.5, -1.83], ["c", 0.12, -0.27, 0.12, -0.27, 0.54, -2.52], ["c", 0.24, -1.23, 0.42, -2.25, 0.39, -2.25], ["c", 0, 0, -0.24, 0.06, -0.51, 0.18], ["c", -1.26, 0.39, -2.25, 0.57, -3.06, 0.54], ["c", -0.42, -0.03, -0.75, -0.12, -1.11, -0.3], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.15, 0.63, 0.21, 0.81, 0.33, 0.96], ["c", 0.18, 0.21, 0.51, 0.3, 0.75, 0.18], ["c", 0.36, -0.15, 1.05, -0.99, 1.41, -1.77], ["l", 0.15, -0.3], ["l", 0.42, -2.25], ["c", 0.21, -1.26, 0.42, -2.28, 0.39, -2.28], ["l", -0.51, 0.15], ["c", -1.11, 0.39, -1.89, 0.51, -2.7, 0.51], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.15, 0.63, 0.21, 0.81, 0.33, 0.96], ["c", 0.18, 0.18, 0.48, 0.27, 0.72, 0.21], ["c", 0.33, -0.12, 1.14, -1.26, 1.41, -1.95], ["c", 0, -0.09, 0.21, -1.11, 0.45, -2.34], ["c", 0.21, -1.2, 0.39, -2.22, 0.39, -2.28], ["c", 0.03, -0.03, 0, -0.03, -0.45, 0.12], ["c", -0.57, 0.18, -1.2, 0.33, -1.71, 0.42], ["c", -0.3, 0.06, -0.51, 0.06, -0.93, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.18, 0, 0.36, -0.09, 0.57, -0.33], ["c", 0.33, -0.36, 0.78, -1.14, 0.93, -1.56], ["c", 0.03, -0.12, 0.24, -1.2, 0.45, -2.4], ["c", 0.24, -1.2, 0.42, -2.22, 0.42, -2.28], ["c", 0.03, -0.03, 0, -0.03, -0.39, 0.09], ["c", -1.05, 0.36, -1.8, 0.48, -2.58, 0.48], ["c", -0.63, 0, -0.84, -0.03, -1.29, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 12.992, h: 43.883 },
      "accidentals.sharp": { d: [["M", 5.73, -11.19], ["c", 0.21, -0.12, 0.54, -0.03, 0.66, 0.24], ["c", 0.06, 0.12, 0.06, 0.21, 0.06, 2.31], ["c", 0, 1.23, 0, 2.22, 0.03, 2.22], ["c", 0, 0, 0.27, -0.12, 0.6, -0.24], ["c", 0.69, -0.27, 0.78, -0.3, 0.96, -0.15], ["c", 0.21, 0.15, 0.21, 0.18, 0.21, 1.38], ["c", 0, 1.02, 0, 1.11, -0.06, 1.2], ["c", -0.03, 0.06, -0.09, 0.12, -0.12, 0.15], ["c", -0.06, 0.03, -0.42, 0.21, -0.84, 0.36], ["l", -0.75, 0.33], ["l", -0.03, 2.43], ["c", 0, 1.32, 0, 2.43, 0.03, 2.43], ["c", 0, 0, 0.27, -0.12, 0.6, -0.24], ["c", 0.69, -0.27, 0.78, -0.3, 0.96, -0.15], ["c", 0.21, 0.15, 0.21, 0.18, 0.21, 1.38], ["c", 0, 1.02, 0, 1.11, -0.06, 1.2], ["c", -0.03, 0.06, -0.09, 0.12, -0.12, 0.15], ["c", -0.06, 0.03, -0.42, 0.21, -0.84, 0.36], ["l", -0.75, 0.33], ["l", -0.03, 2.52], ["c", 0, 2.28, -0.03, 2.55, -0.06, 2.64], ["c", -0.21, 0.36, -0.72, 0.36, -0.93, 0], ["c", -0.03, -0.09, -0.06, -0.33, -0.06, -2.43], ["l", 0, -2.31], ["l", -1.29, 0.51], ["l", -1.26, 0.51], ["l", 0, 2.43], ["c", 0, 2.58, 0, 2.52, -0.15, 2.67], ["c", -0.06, 0.09, -0.27, 0.18, -0.36, 0.18], ["c", -0.12, 0, -0.33, -0.09, -0.39, -0.18], ["c", -0.15, -0.15, -0.15, -0.09, -0.15, -2.43], ["c", 0, -1.23, 0, -2.22, -0.03, -2.22], ["c", 0, 0, -0.27, 0.12, -0.6, 0.24], ["c", -0.69, 0.27, -0.78, 0.3, -0.96, 0.15], ["c", -0.21, -0.15, -0.21, -0.18, -0.21, -1.38], ["c", 0, -1.02, 0, -1.11, 0.06, -1.2], ["c", 0.03, -0.06, 0.09, -0.12, 0.12, -0.15], ["c", 0.06, -0.03, 0.42, -0.21, 0.84, -0.36], ["l", 0.78, -0.33], ["l", 0, -2.43], ["c", 0, -1.32, 0, -2.43, -0.03, -2.43], ["c", 0, 0, -0.27, 0.12, -0.6, 0.24], ["c", -0.69, 0.27, -0.78, 0.3, -0.96, 0.15], ["c", -0.21, -0.15, -0.21, -0.18, -0.21, -1.38], ["c", 0, -1.02, 0, -1.11, 0.06, -1.2], ["c", 0.03, -0.06, 0.09, -0.12, 0.12, -0.15], ["c", 0.06, -0.03, 0.42, -0.21, 0.84, -0.36], ["l", 0.78, -0.33], ["l", 0, -2.52], ["c", 0, -2.28, 0.03, -2.55, 0.06, -2.64], ["c", 0.21, -0.36, 0.72, -0.36, 0.93, 0], ["c", 0.03, 0.09, 0.06, 0.33, 0.06, 2.43], ["l", 0.03, 2.31], ["l", 1.26, -0.51], ["l", 1.26, -0.51], ["l", 0, -2.43], ["c", 0, -2.28, 0, -2.43, 0.06, -2.55], ["c", 0.06, -0.12, 0.12, -0.18, 0.27, -0.24], ["z"], ["m", -0.33, 10.65], ["l", 0, -2.43], ["l", -1.29, 0.51], ["l", -1.26, 0.51], ["l", 0, 2.46], ["l", 0, 2.43], ["l", 0.09, -0.03], ["c", 0.06, -0.03, 0.63, -0.27, 1.29, -0.51], ["l", 1.17, -0.48], ["l", 0, -2.46], ["z"]], w: 8.25, h: 22.462 },
      "accidentals.halfsharp": { d: [["M", 2.43, -10.05], ["c", 0.21, -0.12, 0.54, -0.03, 0.66, 0.24], ["c", 0.06, 0.12, 0.06, 0.21, 0.06, 2.01], ["c", 0, 1.05, 0, 1.89, 0.03, 1.89], ["l", 0.72, -0.48], ["c", 0.69, -0.48, 0.69, -0.51, 0.87, -0.51], ["c", 0.15, 0, 0.18, 0.03, 0.27, 0.09], ["c", 0.21, 0.15, 0.21, 0.18, 0.21, 1.41], ["c", 0, 1.11, -0.03, 1.14, -0.09, 1.23], ["c", -0.03, 0.03, -0.48, 0.39, -1.02, 0.75], ["l", -0.99, 0.66], ["l", 0, 2.37], ["c", 0, 1.32, 0, 2.37, 0.03, 2.37], ["l", 0.72, -0.48], ["c", 0.69, -0.48, 0.69, -0.51, 0.87, -0.51], ["c", 0.15, 0, 0.18, 0.03, 0.27, 0.09], ["c", 0.21, 0.15, 0.21, 0.18, 0.21, 1.41], ["c", 0, 1.11, -0.03, 1.14, -0.09, 1.23], ["c", -0.03, 0.03, -0.48, 0.39, -1.02, 0.75], ["l", -0.99, 0.66], ["l", 0, 2.25], ["c", 0, 1.95, 0, 2.28, -0.06, 2.37], ["c", -0.06, 0.12, -0.12, 0.21, -0.24, 0.27], ["c", -0.27, 0.12, -0.54, 0.03, -0.69, -0.24], ["c", -0.06, -0.12, -0.06, -0.21, -0.06, -2.01], ["c", 0, -1.05, 0, -1.89, -0.03, -1.89], ["l", -0.72, 0.48], ["c", -0.69, 0.48, -0.69, 0.48, -0.87, 0.48], ["c", -0.15, 0, -0.18, 0, -0.27, -0.06], ["c", -0.21, -0.15, -0.21, -0.18, -0.21, -1.41], ["c", 0, -1.11, 0.03, -1.14, 0.09, -1.23], ["c", 0.03, -0.03, 0.48, -0.39, 1.02, -0.75], ["l", 0.99, -0.66], ["l", 0, -2.37], ["c", 0, -1.32, 0, -2.37, -0.03, -2.37], ["l", -0.72, 0.48], ["c", -0.69, 0.48, -0.69, 0.48, -0.87, 0.48], ["c", -0.15, 0, -0.18, 0, -0.27, -0.06], ["c", -0.21, -0.15, -0.21, -0.18, -0.21, -1.41], ["c", 0, -1.11, 0.03, -1.14, 0.09, -1.23], ["c", 0.03, -0.03, 0.48, -0.39, 1.02, -0.75], ["l", 0.99, -0.66], ["l", 0, -2.25], ["c", 0, -2.13, 0, -2.28, 0.06, -2.4], ["c", 0.06, -0.12, 0.12, -0.18, 0.27, -0.24], ["z"]], w: 5.25, h: 20.174 },
      "accidentals.nat": { d: [["M", 0.21, -11.4], ["c", 0.24, -0.06, 0.78, 0, 0.99, 0.15], ["c", 0.03, 0.03, 0.03, 0.48, 0, 2.61], ["c", -0.03, 1.44, -0.03, 2.61, -0.03, 2.61], ["c", 0, 0.03, 0.75, -0.09, 1.68, -0.24], ["c", 0.96, -0.18, 1.71, -0.27, 1.74, -0.27], ["c", 0.15, 0.03, 0.27, 0.15, 0.36, 0.3], ["l", 0.06, 0.12], ["l", 0.09, 8.67], ["c", 0.09, 6.96, 0.12, 8.67, 0.09, 8.67], ["c", -0.03, 0.03, -0.12, 0.06, -0.21, 0.09], ["c", -0.24, 0.09, -0.72, 0.09, -0.96, 0], ["c", -0.09, -0.03, -0.18, -0.06, -0.21, -0.09], ["c", -0.03, -0.03, -0.03, -0.48, 0, -2.61], ["c", 0.03, -1.44, 0.03, -2.61, 0.03, -2.61], ["c", 0, -0.03, -0.75, 0.09, -1.68, 0.24], ["c", -0.96, 0.18, -1.71, 0.27, -1.74, 0.27], ["c", -0.15, -0.03, -0.27, -0.15, -0.36, -0.3], ["l", -0.06, -0.15], ["l", -0.09, -7.53], ["c", -0.06, -4.14, -0.09, -8.04, -0.12, -8.67], ["l", 0, -1.11], ["l", 0.15, -0.06], ["c", 0.09, -0.03, 0.21, -0.06, 0.27, -0.09], ["z"], ["m", 3.75, 8.4], ["c", 0, -0.33, 0, -0.42, -0.03, -0.42], ["c", -0.12, 0, -2.79, 0.45, -2.79, 0.48], ["c", -0.03, 0, -0.09, 6.3, -0.09, 6.33], ["c", 0.03, 0, 2.79, -0.45, 2.82, -0.48], ["c", 0, 0, 0.09, -4.53, 0.09, -5.91], ["z"]], w: 5.4, h: 22.8 },
      "accidentals.flat": { d: [["M", -0.36, -14.07], ["c", 0.33, -0.06, 0.87, 0, 1.08, 0.15], ["c", 0.06, 0.03, 0.06, 0.36, -0.03, 5.25], ["c", -0.06, 2.85, -0.09, 5.19, -0.09, 5.19], ["c", 0, 0.03, 0.12, -0.03, 0.24, -0.12], ["c", 0.63, -0.42, 1.41, -0.66, 2.19, -0.72], ["c", 0.81, -0.03, 1.47, 0.21, 2.04, 0.78], ["c", 0.57, 0.54, 0.87, 1.26, 0.93, 2.04], ["c", 0.03, 0.57, -0.09, 1.08, -0.36, 1.62], ["c", -0.42, 0.81, -1.02, 1.38, -2.82, 2.61], ["c", -1.14, 0.78, -1.44, 1.02, -1.8, 1.44], ["c", -0.18, 0.18, -0.39, 0.39, -0.45, 0.42], ["c", -0.27, 0.18, -0.57, 0.15, -0.81, -0.06], ["c", -0.06, -0.09, -0.12, -0.18, -0.15, -0.27], ["c", -0.03, -0.06, -0.09, -3.27, -0.18, -8.34], ["c", -0.09, -4.53, -0.15, -8.58, -0.18, -9.03], ["l", 0, -0.78], ["l", 0.12, -0.06], ["c", 0.06, -0.03, 0.18, -0.09, 0.27, -0.12], ["z"], ["m", 3.18, 11.01], ["c", -0.21, -0.12, -0.54, -0.15, -0.81, -0.06], ["c", -0.54, 0.15, -0.99, 0.63, -1.17, 1.26], ["c", -0.06, 0.3, -0.12, 2.88, -0.06, 3.87], ["c", 0.03, 0.42, 0.03, 0.81, 0.06, 0.9], ["l", 0.03, 0.12], ["l", 0.45, -0.39], ["c", 0.63, -0.54, 1.26, -1.17, 1.56, -1.59], ["c", 0.3, -0.42, 0.6, -0.99, 0.72, -1.41], ["c", 0.18, -0.69, 0.09, -1.47, -0.18, -2.07], ["c", -0.15, -0.3, -0.33, -0.51, -0.6, -0.63], ["z"]], w: 6.75, h: 18.801 },
      "accidentals.halfflat": { d: [["M", 4.83, -14.07], ["c", 0.33, -0.06, 0.87, 0, 1.08, 0.15], ["c", 0.06, 0.03, 0.06, 0.6, -0.12, 9.06], ["c", -0.09, 5.55, -0.15, 9.06, -0.18, 9.12], ["c", -0.03, 0.09, -0.09, 0.18, -0.15, 0.27], ["c", -0.24, 0.21, -0.54, 0.24, -0.81, 0.06], ["c", -0.06, -0.03, -0.27, -0.24, -0.45, -0.42], ["c", -0.36, -0.42, -0.66, -0.66, -1.8, -1.44], ["c", -1.23, -0.84, -1.83, -1.32, -2.25, -1.77], ["c", -0.66, -0.78, -0.96, -1.56, -0.93, -2.46], ["c", 0.09, -1.41, 1.11, -2.58, 2.4, -2.79], ["c", 0.3, -0.06, 0.84, -0.03, 1.23, 0.06], ["c", 0.54, 0.12, 1.08, 0.33, 1.53, 0.63], ["c", 0.12, 0.09, 0.24, 0.15, 0.24, 0.12], ["c", 0, 0, -0.12, -8.37, -0.18, -9.75], ["l", 0, -0.66], ["l", 0.12, -0.06], ["c", 0.06, -0.03, 0.18, -0.09, 0.27, -0.12], ["z"], ["m", -1.65, 10.95], ["c", -0.6, -0.18, -1.08, 0.09, -1.38, 0.69], ["c", -0.27, 0.6, -0.36, 1.38, -0.18, 2.07], ["c", 0.12, 0.42, 0.42, 0.99, 0.72, 1.41], ["c", 0.3, 0.42, 0.93, 1.05, 1.56, 1.59], ["l", 0.48, 0.39], ["l", 0, -0.12], ["c", 0.03, -0.09, 0.03, -0.48, 0.06, -0.9], ["c", 0.03, -0.57, 0.03, -1.08, 0, -2.22], ["c", -0.03, -1.62, -0.03, -1.62, -0.24, -2.07], ["c", -0.21, -0.42, -0.6, -0.75, -1.02, -0.84], ["z"]], w: 6.728, h: 18.801 },
      "accidentals.dblflat": { d: [["M", -0.36, -14.07], ["c", 0.33, -0.06, 0.87, 0, 1.08, 0.15], ["c", 0.06, 0.03, 0.06, 0.36, -0.03, 5.25], ["c", -0.06, 2.85, -0.09, 5.19, -0.09, 5.19], ["c", 0, 0.03, 0.12, -0.03, 0.24, -0.12], ["c", 0.63, -0.42, 1.41, -0.66, 2.19, -0.72], ["c", 0.81, -0.03, 1.47, 0.21, 2.04, 0.78], ["c", 0.57, 0.54, 0.87, 1.26, 0.93, 2.04], ["c", 0.03, 0.57, -0.09, 1.08, -0.36, 1.62], ["c", -0.42, 0.81, -1.02, 1.38, -2.82, 2.61], ["c", -1.14, 0.78, -1.44, 1.02, -1.8, 1.44], ["c", -0.18, 0.18, -0.39, 0.39, -0.45, 0.42], ["c", -0.27, 0.18, -0.57, 0.15, -0.81, -0.06], ["c", -0.06, -0.09, -0.12, -0.18, -0.15, -0.27], ["c", -0.03, -0.06, -0.09, -3.27, -0.18, -8.34], ["c", -0.09, -4.53, -0.15, -8.58, -0.18, -9.03], ["l", 0, -0.78], ["l", 0.12, -0.06], ["c", 0.06, -0.03, 0.18, -0.09, 0.27, -0.12], ["z"], ["m", 3.18, 11.01], ["c", -0.21, -0.12, -0.54, -0.15, -0.81, -0.06], ["c", -0.54, 0.15, -0.99, 0.63, -1.17, 1.26], ["c", -0.06, 0.3, -0.12, 2.88, -0.06, 3.87], ["c", 0.03, 0.42, 0.03, 0.81, 0.06, 0.9], ["l", 0.03, 0.12], ["l", 0.45, -0.39], ["c", 0.63, -0.54, 1.26, -1.17, 1.56, -1.59], ["c", 0.3, -0.42, 0.6, -0.99, 0.72, -1.41], ["c", 0.18, -0.69, 0.09, -1.47, -0.18, -2.07], ["c", -0.15, -0.3, -0.33, -0.51, -0.6, -0.63], ["z"], ["m", 3, -11], ["c", 0.33, -0.06, 0.87, 0, 1.08, 0.15], ["c", 0.06, 0.03, 0.06, 0.36, -0.03, 5.25], ["c", -0.06, 2.85, -0.09, 5.19, -0.09, 5.19], ["c", 0, 0.03, 0.12, -0.03, 0.24, -0.12], ["c", 0.63, -0.42, 1.41, -0.66, 2.19, -0.72], ["c", 0.81, -0.03, 1.47, 0.21, 2.04, 0.78], ["c", 0.57, 0.54, 0.87, 1.26, 0.93, 2.04], ["c", 0.03, 0.57, -0.09, 1.08, -0.36, 1.62], ["c", -0.42, 0.81, -1.02, 1.38, -2.82, 2.61], ["c", -1.14, 0.78, -1.44, 1.02, -1.8, 1.44], ["c", -0.18, 0.18, -0.39, 0.39, -0.45, 0.42], ["c", -0.27, 0.18, -0.57, 0.15, -0.81, -0.06], ["c", -0.06, -0.09, -0.12, -0.18, -0.15, -0.27], ["c", -0.03, -0.06, -0.09, -3.27, -0.18, -8.34], ["c", -0.09, -4.53, -0.15, -8.58, -0.18, -9.03], ["l", 0, -0.78], ["l", 0.12, -0.06], ["c", 0.06, -0.03, 0.18, -0.09, 0.27, -0.12], ["z"], ["m", 3.18, 11.01], ["c", -0.21, -0.12, -0.54, -0.15, -0.81, -0.06], ["c", -0.54, 0.15, -0.99, 0.63, -1.17, 1.26], ["c", -0.06, 0.3, -0.12, 2.88, -0.06, 3.87], ["c", 0.03, 0.42, 0.03, 0.81, 0.06, 0.9], ["l", 0.03, 0.12], ["l", 0.45, -0.39], ["c", 0.63, -0.54, 1.26, -1.17, 1.56, -1.59], ["c", 0.3, -0.42, 0.6, -0.99, 0.72, -1.41], ["c", 0.18, -0.69, 0.09, -1.47, -0.18, -2.07], ["c", -0.15, -0.3, -0.33, -0.51, -0.6, -0.63], ["z"]], w: 12.1, h: 18.804 },
      "accidentals.dblsharp": { d: [["M", -0.18, -3.96], ["c", 0.06, -0.03, 0.12, -0.06, 0.15, -0.06], ["c", 0.09, 0, 2.76, 0.27, 2.79, 0.3], ["c", 0.12, 0.03, 0.15, 0.12, 0.15, 0.51], ["c", 0.06, 0.96, 0.24, 1.59, 0.57, 2.1], ["c", 0.06, 0.09, 0.15, 0.21, 0.18, 0.24], ["l", 0.09, 0.06], ["l", 0.09, -0.06], ["c", 0.03, -0.03, 0.12, -0.15, 0.18, -0.24], ["c", 0.33, -0.51, 0.51, -1.14, 0.57, -2.1], ["c", 0, -0.39, 0.03, -0.45, 0.12, -0.51], ["c", 0.03, 0, 0.66, -0.09, 1.44, -0.15], ["c", 1.47, -0.15, 1.5, -0.15, 1.56, -0.03], ["c", 0.03, 0.06, 0, 0.42, -0.09, 1.44], ["c", -0.09, 0.72, -0.15, 1.35, -0.15, 1.38], ["c", 0, 0.03, -0.03, 0.09, -0.06, 0.12], ["c", -0.06, 0.06, -0.12, 0.09, -0.51, 0.09], ["c", -1.08, 0.06, -1.8, 0.3, -2.28, 0.75], ["l", -0.12, 0.09], ["l", 0.09, 0.09], ["c", 0.12, 0.15, 0.39, 0.33, 0.63, 0.45], ["c", 0.42, 0.18, 0.96, 0.27, 1.68, 0.33], ["c", 0.39, 0, 0.45, 0.03, 0.51, 0.09], ["c", 0.03, 0.03, 0.06, 0.09, 0.06, 0.12], ["c", 0, 0.03, 0.06, 0.66, 0.15, 1.38], ["c", 0.09, 1.02, 0.12, 1.38, 0.09, 1.44], ["c", -0.06, 0.12, -0.09, 0.12, -1.56, -0.03], ["c", -0.78, -0.06, -1.41, -0.15, -1.44, -0.15], ["c", -0.09, -0.06, -0.12, -0.12, -0.12, -0.54], ["c", -0.06, -0.93, -0.24, -1.56, -0.57, -2.07], ["c", -0.06, -0.09, -0.15, -0.21, -0.18, -0.24], ["l", -0.09, -0.06], ["l", -0.09, 0.06], ["c", -0.03, 0.03, -0.12, 0.15, -0.18, 0.24], ["c", -0.33, 0.51, -0.51, 1.14, -0.57, 2.07], ["c", 0, 0.42, -0.03, 0.48, -0.12, 0.54], ["c", -0.03, 0, -0.66, 0.09, -1.44, 0.15], ["c", -1.47, 0.15, -1.5, 0.15, -1.56, 0.03], ["c", -0.03, -0.06, 0, -0.42, 0.09, -1.44], ["c", 0.09, -0.72, 0.15, -1.35, 0.15, -1.38], ["c", 0, -0.03, 0.03, -0.09, 0.06, -0.12], ["c", 0.06, -0.06, 0.12, -0.09, 0.51, -0.09], ["c", 0.72, -0.06, 1.26, -0.15, 1.68, -0.33], ["c", 0.24, -0.12, 0.51, -0.3, 0.63, -0.45], ["l", 0.09, -0.09], ["l", -0.12, -0.09], ["c", -0.48, -0.45, -1.2, -0.69, -2.28, -0.75], ["c", -0.39, 0, -0.45, -0.03, -0.51, -0.09], ["c", -0.03, -0.03, -0.06, -0.09, -0.06, -0.12], ["c", 0, -0.03, -0.06, -0.63, -0.12, -1.38], ["c", -0.09, -0.72, -0.15, -1.35, -0.15, -1.38], ["z"]], w: 7.95, h: 7.977 },
      "dots.dot": { d: [["M", 1.32, -1.68], ["c", 0.09, -0.03, 0.27, -0.06, 0.39, -0.06], ["c", 0.96, 0, 1.74, 0.78, 1.74, 1.71], ["c", 0, 0.96, -0.78, 1.74, -1.71, 1.74], ["c", -0.96, 0, -1.74, -0.78, -1.74, -1.71], ["c", 0, -0.78, 0.54, -1.5, 1.32, -1.68], ["z"]], w: 3.45, h: 3.45 },
      "noteheads.dbl": { d: [["M", -0.69, -4.02], ["c", 0.18, -0.09, 0.36, -0.09, 0.54, 0], ["c", 0.18, 0.09, 0.24, 0.15, 0.33, 0.3], ["c", 0.06, 0.15, 0.06, 0.18, 0.06, 1.41], ["l", 0, 1.23], ["l", 0.12, -0.18], ["c", 0.72, -1.26, 2.64, -2.31, 4.86, -2.64], ["c", 0.81, -0.15, 1.11, -0.15, 2.13, -0.15], ["c", 0.99, 0, 1.29, 0, 2.1, 0.15], ["c", 0.75, 0.12, 1.38, 0.27, 2.04, 0.54], ["c", 1.35, 0.51, 2.34, 1.26, 2.82, 2.1], ["l", 0.12, 0.18], ["l", 0, -1.23], ["c", 0, -1.2, 0, -1.26, 0.06, -1.38], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["c", 0.18, -0.09, 0.36, -0.09, 0.54, 0], ["c", 0.18, 0.09, 0.24, 0.15, 0.33, 0.3], ["l", 0.06, 0.15], ["l", 0, 3.54], ["l", 0, 3.54], ["l", -0.06, 0.15], ["c", -0.09, 0.18, -0.15, 0.24, -0.33, 0.33], ["c", -0.18, 0.09, -0.36, 0.09, -0.54, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.06, -0.12, -0.06, -0.18, -0.06, -1.38], ["l", 0, -1.23], ["l", -0.12, 0.18], ["c", -0.48, 0.84, -1.47, 1.59, -2.82, 2.1], ["c", -0.84, 0.33, -1.71, 0.54, -2.85, 0.66], ["c", -0.45, 0.06, -2.16, 0.06, -2.61, 0], ["c", -1.14, -0.12, -2.01, -0.33, -2.85, -0.66], ["c", -1.35, -0.51, -2.34, -1.26, -2.82, -2.1], ["l", -0.12, -0.18], ["l", 0, 1.23], ["c", 0, 1.23, 0, 1.26, -0.06, 1.38], ["c", -0.09, 0.18, -0.15, 0.24, -0.33, 0.33], ["c", -0.18, 0.09, -0.36, 0.09, -0.54, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["l", -0.06, -0.15], ["l", 0, -3.54], ["c", 0, -3.48, 0, -3.54, 0.06, -3.66], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["z"], ["m", 7.71, 0.63], ["c", -0.36, -0.06, -0.9, -0.06, -1.14, 0], ["c", -0.3, 0.03, -0.66, 0.24, -0.87, 0.42], ["c", -0.6, 0.54, -0.9, 1.62, -0.75, 2.82], ["c", 0.12, 0.93, 0.51, 1.68, 1.11, 2.31], ["c", 0.75, 0.72, 1.83, 1.2, 2.85, 1.26], ["c", 1.05, 0.06, 1.83, -0.54, 2.1, -1.65], ["c", 0.21, -0.9, 0.12, -1.95, -0.24, -2.82], ["c", -0.36, -0.81, -1.08, -1.53, -1.95, -1.95], ["c", -0.3, -0.15, -0.78, -0.3, -1.11, -0.39], ["z"]], w: 16.83, h: 8.145 },
      "noteheads.whole": { d: [["M", 6.51, -4.05], ["c", 0.51, -0.03, 2.01, 0, 2.52, 0.03], ["c", 1.41, 0.18, 2.64, 0.51, 3.72, 1.08], ["c", 1.2, 0.63, 1.95, 1.41, 2.19, 2.31], ["c", 0.09, 0.33, 0.09, 0.9, 0, 1.23], ["c", -0.24, 0.9, -0.99, 1.68, -2.19, 2.31], ["c", -1.08, 0.57, -2.28, 0.9, -3.75, 1.08], ["c", -0.66, 0.06, -2.31, 0.06, -2.97, 0], ["c", -1.47, -0.18, -2.67, -0.51, -3.75, -1.08], ["c", -1.2, -0.63, -1.95, -1.41, -2.19, -2.31], ["c", -0.09, -0.33, -0.09, -0.9, 0, -1.23], ["c", 0.24, -0.9, 0.99, -1.68, 2.19, -2.31], ["c", 1.2, -0.63, 2.61, -0.99, 4.23, -1.11], ["z"], ["m", 0.57, 0.66], ["c", -0.87, -0.15, -1.53, 0, -2.04, 0.51], ["c", -0.15, 0.15, -0.24, 0.27, -0.33, 0.48], ["c", -0.24, 0.51, -0.36, 1.08, -0.33, 1.77], ["c", 0.03, 0.69, 0.18, 1.26, 0.42, 1.77], ["c", 0.6, 1.17, 1.74, 1.98, 3.18, 2.22], ["c", 1.11, 0.21, 1.95, -0.15, 2.34, -0.99], ["c", 0.24, -0.51, 0.36, -1.08, 0.33, -1.8], ["c", -0.06, -1.11, -0.45, -2.04, -1.17, -2.76], ["c", -0.63, -0.63, -1.47, -1.05, -2.4, -1.2], ["z"]], w: 14.985, h: 8.097 },
      "noteheads.half": { d: [["M", 7.44, -4.05], ["c", 0.06, -0.03, 0.27, -0.03, 0.48, -0.03], ["c", 1.05, 0, 1.71, 0.24, 2.1, 0.81], ["c", 0.42, 0.6, 0.45, 1.35, 0.18, 2.4], ["c", -0.42, 1.59, -1.14, 2.73, -2.16, 3.39], ["c", -1.41, 0.93, -3.18, 1.44, -5.4, 1.53], ["c", -1.17, 0.03, -1.89, -0.21, -2.28, -0.81], ["c", -0.42, -0.6, -0.45, -1.35, -0.18, -2.4], ["c", 0.42, -1.59, 1.14, -2.73, 2.16, -3.39], ["c", 0.63, -0.42, 1.23, -0.72, 1.98, -0.96], ["c", 0.9, -0.3, 1.65, -0.42, 3.12, -0.54], ["z"], ["m", 1.29, 0.87], ["c", -0.27, -0.09, -0.63, -0.12, -0.9, -0.03], ["c", -0.72, 0.24, -1.53, 0.69, -3.27, 1.8], ["c", -2.34, 1.5, -3.3, 2.25, -3.57, 2.79], ["c", -0.36, 0.72, -0.06, 1.5, 0.66, 1.77], ["c", 0.24, 0.12, 0.69, 0.09, 0.99, 0], ["c", 0.84, -0.3, 1.92, -0.93, 4.14, -2.37], ["c", 1.62, -1.08, 2.37, -1.71, 2.61, -2.19], ["c", 0.36, -0.72, 0.06, -1.5, -0.66, -1.77], ["z"]], w: 10.37, h: 8.132 },
      "noteheads.quarter": { d: [["M", 6.09, -4.05], ["c", 0.36, -0.03, 1.2, 0, 1.53, 0.06], ["c", 1.17, 0.24, 1.89, 0.84, 2.16, 1.83], ["c", 0.06, 0.18, 0.06, 0.3, 0.06, 0.66], ["c", 0, 0.45, 0, 0.63, -0.15, 1.08], ["c", -0.66, 2.04, -3.06, 3.93, -5.52, 4.38], ["c", -0.54, 0.09, -1.44, 0.09, -1.83, 0.03], ["c", -1.23, -0.27, -1.98, -0.87, -2.25, -1.86], ["c", -0.06, -0.18, -0.06, -0.3, -0.06, -0.66], ["c", 0, -0.45, 0, -0.63, 0.15, -1.08], ["c", 0.24, -0.78, 0.75, -1.53, 1.44, -2.22], ["c", 1.2, -1.2, 2.85, -2.01, 4.47, -2.22], ["z"]], w: 9.81, h: 8.094 },
      "noteheads.slash.nostem": { d: [["M", 9.3, -7.77], ["c", 0.06, -0.06, 0.18, -0.06, 1.71, -0.06], ["l", 1.65, 0], ["l", 0.09, 0.09], ["c", 0.06, 0.06, 0.06, 0.09, 0.06, 0.15], ["c", -0.03, 0.12, -9.21, 15.24, -9.3, 15.33], ["c", -0.06, 0.06, -0.18, 0.06, -1.71, 0.06], ["l", -1.65, 0], ["l", -0.09, -0.09], ["c", -0.06, -0.06, -0.06, -0.09, -0.06, -0.15], ["c", 0.03, -0.12, 9.21, -15.24, 9.3, -15.33], ["z"]], w: 12.81, h: 15.63 },
      "noteheads.indeterminate": { d: [["M", 0.78, -4.05], ["c", 0.12, -0.03, 0.24, -0.03, 0.36, 0.03], ["c", 0.03, 0.03, 0.93, 0.72, 1.95, 1.56], ["l", 1.86, 1.5], ["l", 1.86, -1.5], ["c", 1.02, -0.84, 1.92, -1.53, 1.95, -1.56], ["c", 0.21, -0.12, 0.33, -0.09, 0.75, 0.24], ["c", 0.3, 0.27, 0.36, 0.36, 0.36, 0.54], ["c", 0, 0.03, -0.03, 0.12, -0.06, 0.18], ["c", -0.03, 0.06, -0.9, 0.75, -1.89, 1.56], ["l", -1.8, 1.47], ["c", 0, 0.03, 0.81, 0.69, 1.8, 1.5], ["c", 0.99, 0.81, 1.86, 1.5, 1.89, 1.56], ["c", 0.03, 0.06, 0.06, 0.15, 0.06, 0.18], ["c", 0, 0.18, -0.06, 0.27, -0.36, 0.54], ["c", -0.42, 0.33, -0.54, 0.36, -0.75, 0.24], ["c", -0.03, -0.03, -0.93, -0.72, -1.95, -1.56], ["l", -1.86, -1.5], ["l", -1.86, 1.5], ["c", -1.02, 0.84, -1.92, 1.53, -1.95, 1.56], ["c", -0.21, 0.12, -0.33, 0.09, -0.75, -0.24], ["c", -0.3, -0.27, -0.36, -0.36, -0.36, -0.54], ["c", 0, -0.03, 0.03, -0.12, 0.06, -0.18], ["c", 0.03, -0.06, 0.9, -0.75, 1.89, -1.56], ["l", 1.8, -1.47], ["c", 0, -0.03, -0.81, -0.69, -1.8, -1.5], ["c", -0.99, -0.81, -1.86, -1.5, -1.89, -1.56], ["c", -0.06, -0.12, -0.09, -0.21, -0.03, -0.36], ["c", 0.03, -0.09, 0.57, -0.57, 0.72, -0.63], ["z"]], w: 9.843, h: 8.139 },
      "scripts.ufermata": { d: [["M", -0.75, -10.77], ["c", 0.12, 0, 0.45, -0.03, 0.69, -0.03], ["c", 2.91, -0.03, 5.55, 1.53, 7.41, 4.35], ["c", 1.17, 1.71, 1.95, 3.72, 2.43, 6.03], ["c", 0.12, 0.51, 0.12, 0.57, 0.03, 0.69], ["c", -0.12, 0.21, -0.48, 0.27, -0.69, 0.12], ["c", -0.12, -0.09, -0.18, -0.24, -0.27, -0.69], ["c", -0.78, -3.63, -3.42, -6.54, -6.78, -7.38], ["c", -0.78, -0.21, -1.2, -0.24, -2.07, -0.24], ["c", -0.63, 0, -0.84, 0, -1.2, 0.06], ["c", -1.83, 0.27, -3.42, 1.08, -4.8, 2.37], ["c", -1.41, 1.35, -2.4, 3.21, -2.85, 5.19], ["c", -0.09, 0.45, -0.15, 0.6, -0.27, 0.69], ["c", -0.21, 0.15, -0.57, 0.09, -0.69, -0.12], ["c", -0.09, -0.12, -0.09, -0.18, 0.03, -0.69], ["c", 0.33, -1.62, 0.78, -3, 1.47, -4.38], ["c", 1.77, -3.54, 4.44, -5.67, 7.56, -5.97], ["z"], ["m", 0.33, 7.47], ["c", 1.38, -0.3, 2.58, 0.9, 2.31, 2.25], ["c", -0.15, 0.72, -0.78, 1.35, -1.47, 1.5], ["c", -1.38, 0.27, -2.58, -0.93, -2.31, -2.31], ["c", 0.15, -0.69, 0.78, -1.29, 1.47, -1.44], ["z"]], w: 19.748, h: 11.289 },
      "scripts.dfermata": { d: [["M", -9.63, -0.42], ["c", 0.15, -0.09, 0.36, -0.06, 0.51, 0.03], ["c", 0.12, 0.09, 0.18, 0.24, 0.27, 0.66], ["c", 0.78, 3.66, 3.42, 6.57, 6.78, 7.41], ["c", 0.78, 0.21, 1.2, 0.24, 2.07, 0.24], ["c", 0.63, 0, 0.84, 0, 1.2, -0.06], ["c", 1.83, -0.27, 3.42, -1.08, 4.8, -2.37], ["c", 1.41, -1.35, 2.4, -3.21, 2.85, -5.22], ["c", 0.09, -0.42, 0.15, -0.57, 0.27, -0.66], ["c", 0.21, -0.15, 0.57, -0.09, 0.69, 0.12], ["c", 0.09, 0.12, 0.09, 0.18, -0.03, 0.69], ["c", -0.33, 1.62, -0.78, 3, -1.47, 4.38], ["c", -1.92, 3.84, -4.89, 6, -8.31, 6], ["c", -3.42, 0, -6.39, -2.16, -8.31, -6], ["c", -0.48, -0.96, -0.84, -1.92, -1.14, -2.97], ["c", -0.18, -0.69, -0.42, -1.74, -0.42, -1.92], ["c", 0, -0.12, 0.09, -0.27, 0.24, -0.33], ["z"], ["m", 9.21, 0], ["c", 1.2, -0.27, 2.34, 0.63, 2.34, 1.86], ["c", 0, 0.9, -0.66, 1.68, -1.5, 1.89], ["c", -1.38, 0.27, -2.58, -0.93, -2.31, -2.31], ["c", 0.15, -0.69, 0.78, -1.29, 1.47, -1.44], ["z"]], w: 19.744, h: 11.274 },
      "scripts.sforzato": { d: [["M", -6.45, -3.69], ["c", 0.06, -0.03, 0.15, -0.06, 0.18, -0.06], ["c", 0.06, 0, 2.85, 0.72, 6.24, 1.59], ["l", 6.33, 1.65], ["c", 0.33, 0.06, 0.45, 0.21, 0.45, 0.51], ["c", 0, 0.3, -0.12, 0.45, -0.45, 0.51], ["l", -6.33, 1.65], ["c", -3.39, 0.87, -6.18, 1.59, -6.21, 1.59], ["c", -0.21, 0, -0.48, -0.24, -0.51, -0.45], ["c", 0, -0.15, 0.06, -0.36, 0.18, -0.45], ["c", 0.09, -0.06, 0.87, -0.27, 3.84, -1.05], ["c", 2.04, -0.54, 3.84, -0.99, 4.02, -1.02], ["c", 0.15, -0.06, 1.14, -0.24, 2.22, -0.42], ["c", 1.05, -0.18, 1.92, -0.36, 1.92, -0.36], ["c", 0, 0, -0.87, -0.18, -1.92, -0.36], ["c", -1.08, -0.18, -2.07, -0.36, -2.22, -0.42], ["c", -0.18, -0.03, -1.98, -0.48, -4.02, -1.02], ["c", -2.97, -0.78, -3.75, -0.99, -3.84, -1.05], ["c", -0.12, -0.09, -0.18, -0.3, -0.18, -0.45], ["c", 0.03, -0.15, 0.15, -0.3, 0.3, -0.39], ["z"]], w: 13.5, h: 7.5 },
      "scripts.staccato": { d: [["M", -0.36, -1.47], ["c", 0.93, -0.21, 1.86, 0.51, 1.86, 1.47], ["c", 0, 0.93, -0.87, 1.65, -1.8, 1.47], ["c", -0.54, -0.12, -1.02, -0.57, -1.14, -1.08], ["c", -0.21, -0.81, 0.27, -1.65, 1.08, -1.86], ["z"]], w: 2.989, h: 3.004 },
      "scripts.tenuto": { d: [["M", -4.2, -0.48], ["l", 0.12, -0.06], ["l", 4.08, 0], ["l", 4.08, 0], ["l", 0.12, 0.06], ["c", 0.39, 0.21, 0.39, 0.75, 0, 0.96], ["l", -0.12, 0.06], ["l", -4.08, 0], ["l", -4.08, 0], ["l", -0.12, -0.06], ["c", -0.39, -0.21, -0.39, -0.75, 0, -0.96], ["z"]], w: 8.985, h: 1.08 },
      "scripts.umarcato": { d: [["M", -0.15, -8.19], ["c", 0.15, -0.12, 0.36, -0.03, 0.45, 0.15], ["c", 0.21, 0.42, 3.45, 7.65, 3.45, 7.71], ["c", 0, 0.12, -0.12, 0.27, -0.21, 0.3], ["c", -0.03, 0.03, -0.51, 0.03, -1.14, 0.03], ["c", -1.05, 0, -1.08, 0, -1.17, -0.06], ["c", -0.09, -0.06, -0.24, -0.36, -1.17, -2.4], ["c", -0.57, -1.29, -1.05, -2.34, -1.08, -2.34], ["c", 0, -0.03, -0.51, 1.02, -1.08, 2.34], ["c", -0.93, 2.07, -1.08, 2.34, -1.14, 2.4], ["c", -0.06, 0.03, -0.15, 0.06, -0.18, 0.06], ["c", -0.15, 0, -0.33, -0.18, -0.33, -0.33], ["c", 0, -0.06, 3.24, -7.32, 3.45, -7.71], ["c", 0.03, -0.06, 0.09, -0.15, 0.15, -0.15], ["z"]], w: 7.5, h: 8.245 },
      "scripts.dmarcato": { d: [["M", -3.57, 0.03], ["c", 0.03, 0, 0.57, -0.03, 1.17, -0.03], ["c", 1.05, 0, 1.08, 0, 1.17, 0.06], ["c", 0.09, 0.06, 0.24, 0.36, 1.17, 2.4], ["c", 0.57, 1.29, 1.05, 2.34, 1.08, 2.34], ["c", 0, 0.03, 0.51, -1.02, 1.08, -2.34], ["c", 0.93, -2.07, 1.08, -2.34, 1.14, -2.4], ["c", 0.06, -0.03, 0.15, -0.06, 0.18, -0.06], ["c", 0.15, 0, 0.33, 0.18, 0.33, 0.33], ["c", 0, 0.09, -3.45, 7.74, -3.54, 7.83], ["c", -0.12, 0.12, -0.3, 0.12, -0.42, 0], ["c", -0.09, -0.09, -3.54, -7.74, -3.54, -7.83], ["c", 0, -0.09, 0.12, -0.27, 0.18, -0.3], ["z"]], w: 7.5, h: 8.25 },
      "scripts.stopped": { d: [["M", -0.27, -4.08], ["c", 0.18, -0.09, 0.36, -0.09, 0.54, 0], ["c", 0.18, 0.09, 0.24, 0.15, 0.33, 0.3], ["l", 0.06, 0.15], ["l", 0, 1.5], ["l", 0, 1.47], ["l", 1.47, 0], ["l", 1.5, 0], ["l", 0.15, 0.06], ["c", 0.15, 0.09, 0.21, 0.15, 0.3, 0.33], ["c", 0.09, 0.18, 0.09, 0.36, 0, 0.54], ["c", -0.09, 0.18, -0.15, 0.24, -0.33, 0.33], ["c", -0.12, 0.06, -0.18, 0.06, -1.62, 0.06], ["l", -1.47, 0], ["l", 0, 1.47], ["l", 0, 1.47], ["l", -0.06, 0.15], ["c", -0.09, 0.18, -0.15, 0.24, -0.33, 0.33], ["c", -0.18, 0.09, -0.36, 0.09, -0.54, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["l", -0.06, -0.15], ["l", 0, -1.47], ["l", 0, -1.47], ["l", -1.47, 0], ["c", -1.44, 0, -1.5, 0, -1.62, -0.06], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.09, -0.18, -0.09, -0.36, 0, -0.54], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["l", 0.15, -0.06], ["l", 1.47, 0], ["l", 1.47, 0], ["l", 0, -1.47], ["c", 0, -1.44, 0, -1.5, 0.06, -1.62], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["z"]], w: 8.295, h: 8.295 },
      "scripts.upbow": { d: [["M", -4.65, -15.54], ["c", 0.12, -0.09, 0.36, -0.06, 0.48, 0.03], ["c", 0.03, 0.03, 0.09, 0.09, 0.12, 0.15], ["c", 0.03, 0.06, 0.66, 2.13, 1.41, 4.62], ["c", 1.35, 4.41, 1.38, 4.56, 2.01, 6.96], ["l", 0.63, 2.46], ["l", 0.63, -2.46], ["c", 0.63, -2.4, 0.66, -2.55, 2.01, -6.96], ["c", 0.75, -2.49, 1.38, -4.56, 1.41, -4.62], ["c", 0.06, -0.15, 0.18, -0.21, 0.36, -0.24], ["c", 0.15, 0, 0.3, 0.06, 0.39, 0.18], ["c", 0.15, 0.21, 0.24, -0.18, -2.1, 7.56], ["c", -1.2, 3.96, -2.22, 7.32, -2.25, 7.41], ["c", 0, 0.12, -0.06, 0.27, -0.09, 0.3], ["c", -0.12, 0.21, -0.6, 0.21, -0.72, 0], ["c", -0.03, -0.03, -0.09, -0.18, -0.09, -0.3], ["c", -0.03, -0.09, -1.05, -3.45, -2.25, -7.41], ["c", -2.34, -7.74, -2.25, -7.35, -2.1, -7.56], ["c", 0.03, -0.03, 0.09, -0.09, 0.15, -0.12], ["z"]], w: 9.73, h: 15.608 },
      "scripts.downbow": { d: [["M", -5.55, -9.93], ["l", 0.09, -0.06], ["l", 5.46, 0], ["l", 5.46, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 4.77], ["c", 0, 5.28, 0, 4.89, -0.18, 5.01], ["c", -0.18, 0.12, -0.42, 0.06, -0.54, -0.12], ["c", -0.06, -0.09, -0.06, -0.18, -0.06, -2.97], ["l", 0, -2.85], ["l", -4.83, 0], ["l", -4.83, 0], ["l", 0, 2.85], ["c", 0, 2.79, 0, 2.88, -0.06, 2.97], ["c", -0.15, 0.24, -0.51, 0.24, -0.66, 0], ["c", -0.06, -0.09, -0.06, -0.21, -0.06, -4.89], ["l", 0, -4.77], ["z"]], w: 11.22, h: 9.992 },
      "scripts.turn": { d: [["M", -4.77, -3.9], ["c", 0.36, -0.06, 1.05, -0.06, 1.44, 0.03], ["c", 0.78, 0.15, 1.5, 0.51, 2.34, 1.14], ["c", 0.6, 0.45, 1.05, 0.87, 2.22, 2.01], ["c", 1.11, 1.08, 1.62, 1.5, 2.22, 1.86], ["c", 0.6, 0.36, 1.32, 0.57, 1.92, 0.57], ["c", 0.9, 0, 1.71, -0.57, 1.89, -1.35], ["c", 0.24, -0.93, -0.39, -1.89, -1.35, -2.1], ["l", -0.15, -0.06], ["l", -0.09, 0.15], ["c", -0.03, 0.09, -0.15, 0.24, -0.24, 0.33], ["c", -0.72, 0.72, -2.04, 0.54, -2.49, -0.36], ["c", -0.48, -0.93, 0.03, -1.86, 1.17, -2.19], ["c", 0.3, -0.09, 1.02, -0.09, 1.35, 0], ["c", 0.99, 0.27, 1.74, 0.87, 2.25, 1.83], ["c", 0.69, 1.41, 0.63, 3, -0.21, 4.26], ["c", -0.21, 0.3, -0.69, 0.81, -0.99, 1.02], ["c", -0.3, 0.21, -0.84, 0.45, -1.17, 0.54], ["c", -1.23, 0.36, -2.49, 0.15, -3.72, -0.6], ["c", -0.75, -0.48, -1.41, -1.02, -2.85, -2.46], ["c", -1.11, -1.08, -1.62, -1.5, -2.22, -1.86], ["c", -0.6, -0.36, -1.32, -0.57, -1.92, -0.57], ["c", -0.9, 0, -1.71, 0.57, -1.89, 1.35], ["c", -0.24, 0.93, 0.39, 1.89, 1.35, 2.1], ["l", 0.15, 0.06], ["l", 0.09, -0.15], ["c", 0.03, -0.09, 0.15, -0.24, 0.24, -0.33], ["c", 0.72, -0.72, 2.04, -0.54, 2.49, 0.36], ["c", 0.48, 0.93, -0.03, 1.86, -1.17, 2.19], ["c", -0.3, 0.09, -1.02, 0.09, -1.35, 0], ["c", -0.99, -0.27, -1.74, -0.87, -2.25, -1.83], ["c", -0.69, -1.41, -0.63, -3, 0.21, -4.26], ["c", 0.21, -0.3, 0.69, -0.81, 0.99, -1.02], ["c", 0.48, -0.33, 1.11, -0.57, 1.74, -0.66], ["z"]], w: 16.366, h: 7.893 },
      "scripts.trill": { d: [["M", -0.51, -16.02], ["c", 0.12, -0.09, 0.21, -0.18, 0.21, -0.18], ["l", -0.81, 4.02], ["l", -0.81, 4.02], ["c", 0.03, 0, 0.51, -0.27, 1.08, -0.6], ["c", 0.6, -0.3, 1.14, -0.63, 1.26, -0.66], ["c", 1.14, -0.54, 2.31, -0.6, 3.09, -0.18], ["c", 0.27, 0.15, 0.54, 0.36, 0.6, 0.51], ["l", 0.06, 0.12], ["l", 0.21, -0.21], ["c", 0.9, -0.81, 2.22, -0.99, 3.12, -0.42], ["c", 0.6, 0.42, 0.9, 1.14, 0.78, 2.07], ["c", -0.15, 1.29, -1.05, 2.31, -1.95, 2.25], ["c", -0.48, -0.03, -0.78, -0.3, -0.96, -0.81], ["c", -0.09, -0.27, -0.09, -0.9, -0.03, -1.2], ["c", 0.21, -0.75, 0.81, -1.23, 1.59, -1.32], ["l", 0.24, -0.03], ["l", -0.09, -0.12], ["c", -0.51, -0.66, -1.62, -0.63, -2.31, 0.03], ["c", -0.39, 0.42, -0.3, 0.09, -1.23, 4.77], ["l", -0.81, 4.14], ["c", -0.03, 0, -0.12, -0.03, -0.21, -0.09], ["c", -0.33, -0.15, -0.54, -0.18, -0.99, -0.18], ["c", -0.42, 0, -0.66, 0.03, -1.05, 0.18], ["c", -0.12, 0.06, -0.21, 0.09, -0.21, 0.09], ["c", 0, -0.03, 0.36, -1.86, 0.81, -4.11], ["c", 0.9, -4.47, 0.87, -4.26, 0.69, -4.53], ["c", -0.21, -0.36, -0.66, -0.51, -1.17, -0.36], ["c", -0.15, 0.06, -2.22, 1.14, -2.58, 1.38], ["c", -0.12, 0.09, -0.12, 0.09, -0.21, 0.6], ["l", -0.09, 0.51], ["l", 0.21, 0.24], ["c", 0.63, 0.75, 1.02, 1.47, 1.2, 2.19], ["c", 0.06, 0.27, 0.06, 0.36, 0.06, 0.81], ["c", 0, 0.42, 0, 0.54, -0.06, 0.78], ["c", -0.15, 0.54, -0.33, 0.93, -0.63, 1.35], ["c", -0.18, 0.24, -0.57, 0.63, -0.81, 0.78], ["c", -0.24, 0.15, -0.63, 0.36, -0.84, 0.42], ["c", -0.27, 0.06, -0.66, 0.06, -0.87, 0.03], ["c", -0.81, -0.18, -1.32, -1.05, -1.38, -2.46], ["c", -0.03, -0.6, 0.03, -0.99, 0.33, -2.46], ["c", 0.21, -1.08, 0.24, -1.32, 0.21, -1.29], ["c", -1.2, 0.48, -2.4, 0.75, -3.21, 0.72], ["c", -0.69, -0.06, -1.17, -0.3, -1.41, -0.72], ["c", -0.39, -0.75, -0.12, -1.8, 0.66, -2.46], ["c", 0.24, -0.18, 0.69, -0.42, 1.02, -0.51], ["c", 0.69, -0.18, 1.53, -0.15, 2.31, 0.09], ["c", 0.3, 0.09, 0.75, 0.3, 0.99, 0.45], ["c", 0.12, 0.09, 0.15, 0.09, 0.15, 0.03], ["c", 0.03, -0.03, 0.33, -1.59, 0.72, -3.45], ["c", 0.36, -1.86, 0.66, -3.42, 0.69, -3.45], ["c", 0, -0.03, 0.03, -0.03, 0.21, 0.03], ["c", 0.21, 0.06, 0.27, 0.06, 0.48, 0.06], ["c", 0.42, -0.03, 0.78, -0.18, 1.26, -0.48], ["c", 0.15, -0.12, 0.36, -0.27, 0.48, -0.39], ["z"], ["m", -5.73, 7.68], ["c", -0.27, -0.03, -0.96, -0.06, -1.2, -0.03], ["c", -0.81, 0.12, -1.35, 0.57, -1.5, 1.2], ["c", -0.18, 0.66, 0.12, 1.14, 0.75, 1.29], ["c", 0.66, 0.12, 1.92, -0.12, 3.18, -0.66], ["l", 0.33, -0.15], ["l", 0.09, -0.39], ["c", 0.06, -0.21, 0.09, -0.42, 0.09, -0.45], ["c", 0, -0.03, -0.45, -0.3, -0.75, -0.45], ["c", -0.27, -0.15, -0.66, -0.27, -0.99, -0.36], ["z"], ["m", 4.29, 3.63], ["c", -0.24, -0.39, -0.51, -0.75, -0.51, -0.69], ["c", -0.06, 0.12, -0.39, 1.92, -0.45, 2.28], ["c", -0.09, 0.54, -0.12, 1.14, -0.06, 1.38], ["c", 0.06, 0.42, 0.21, 0.6, 0.51, 0.57], ["c", 0.39, -0.06, 0.75, -0.48, 0.93, -1.14], ["c", 0.09, -0.33, 0.09, -1.05, 0, -1.38], ["c", -0.09, -0.39, -0.24, -0.69, -0.42, -1.02], ["z"]], w: 17.963, h: 16.49 },
      "scripts.segno": { d: [["M", -3.72, -11.22], ["c", 0.78, -0.09, 1.59, 0.03, 2.31, 0.42], ["c", 1.2, 0.6, 2.01, 1.71, 2.31, 3.09], ["c", 0.09, 0.42, 0.09, 1.2, 0.03, 1.5], ["c", -0.15, 0.45, -0.39, 0.81, -0.66, 0.93], ["c", -0.33, 0.18, -0.84, 0.21, -1.23, 0.15], ["c", -0.81, -0.18, -1.32, -0.93, -1.26, -1.89], ["c", 0.03, -0.36, 0.09, -0.57, 0.24, -0.9], ["c", 0.15, -0.33, 0.45, -0.6, 0.72, -0.75], ["c", 0.12, -0.06, 0.18, -0.09, 0.18, -0.12], ["c", 0, -0.03, -0.03, -0.15, -0.09, -0.24], ["c", -0.18, -0.45, -0.54, -0.87, -0.96, -1.08], ["c", -1.11, -0.57, -2.34, -0.18, -2.88, 0.9], ["c", -0.24, 0.51, -0.33, 1.11, -0.24, 1.83], ["c", 0.27, 1.92, 1.5, 3.54, 3.93, 5.13], ["c", 0.48, 0.33, 1.26, 0.78, 1.29, 0.78], ["c", 0.03, 0, 1.35, -2.19, 2.94, -4.89], ["l", 2.88, -4.89], ["l", 0.84, 0], ["l", 0.87, 0], ["l", -0.03, 0.06], ["c", -0.15, 0.21, -6.15, 10.41, -6.15, 10.44], ["c", 0, 0, 0.21, 0.15, 0.48, 0.27], ["c", 2.61, 1.47, 4.35, 3.03, 5.13, 4.65], ["c", 1.14, 2.34, 0.51, 5.07, -1.44, 6.39], ["c", -0.66, 0.42, -1.32, 0.63, -2.13, 0.69], ["c", -2.01, 0.09, -3.81, -1.41, -4.26, -3.54], ["c", -0.09, -0.42, -0.09, -1.2, -0.03, -1.5], ["c", 0.15, -0.45, 0.39, -0.81, 0.66, -0.93], ["c", 0.33, -0.18, 0.84, -0.21, 1.23, -0.15], ["c", 0.81, 0.18, 1.32, 0.93, 1.26, 1.89], ["c", -0.03, 0.36, -0.09, 0.57, -0.24, 0.9], ["c", -0.15, 0.33, -0.45, 0.6, -0.72, 0.75], ["c", -0.12, 0.06, -0.18, 0.09, -0.18, 0.12], ["c", 0, 0.03, 0.03, 0.15, 0.09, 0.24], ["c", 0.18, 0.45, 0.54, 0.87, 0.96, 1.08], ["c", 1.11, 0.57, 2.34, 0.18, 2.88, -0.9], ["c", 0.24, -0.51, 0.33, -1.11, 0.24, -1.83], ["c", -0.27, -1.92, -1.5, -3.54, -3.93, -5.13], ["c", -0.48, -0.33, -1.26, -0.78, -1.29, -0.78], ["c", -0.03, 0, -1.35, 2.19, -2.91, 4.89], ["l", -2.88, 4.89], ["l", -0.87, 0], ["l", -0.87, 0], ["l", 0.03, -0.06], ["c", 0.15, -0.21, 6.15, -10.41, 6.15, -10.44], ["c", 0, 0, -0.21, -0.15, -0.48, -0.3], ["c", -2.61, -1.44, -4.35, -3, -5.13, -4.62], ["c", -0.9, -1.89, -0.72, -4.02, 0.48, -5.52], ["c", 0.69, -0.84, 1.68, -1.41, 2.73, -1.53], ["z"], ["m", 8.76, 9.09], ["c", 0.03, -0.03, 0.15, -0.03, 0.27, -0.03], ["c", 0.33, 0.03, 0.57, 0.18, 0.72, 0.48], ["c", 0.09, 0.18, 0.09, 0.57, 0, 0.75], ["c", -0.09, 0.18, -0.21, 0.3, -0.36, 0.39], ["c", -0.15, 0.06, -0.21, 0.06, -0.39, 0.06], ["c", -0.21, 0, -0.27, 0, -0.39, -0.06], ["c", -0.3, -0.15, -0.48, -0.45, -0.48, -0.75], ["c", 0, -0.39, 0.24, -0.72, 0.63, -0.84], ["z"], ["m", -10.53, 2.61], ["c", 0.03, -0.03, 0.15, -0.03, 0.27, -0.03], ["c", 0.33, 0.03, 0.57, 0.18, 0.72, 0.48], ["c", 0.09, 0.18, 0.09, 0.57, 0, 0.75], ["c", -0.09, 0.18, -0.21, 0.3, -0.36, 0.39], ["c", -0.15, 0.06, -0.21, 0.06, -0.39, 0.06], ["c", -0.21, 0, -0.27, 0, -0.39, -0.06], ["c", -0.3, -0.15, -0.48, -0.45, -0.48, -0.75], ["c", 0, -0.39, 0.24, -0.72, 0.63, -0.84], ["z"]], w: 15, h: 22.504 },
      "scripts.coda": { d: [["M", -0.21, -10.47], ["c", 0.18, -0.12, 0.42, -0.06, 0.54, 0.12], ["c", 0.06, 0.09, 0.06, 0.18, 0.06, 1.5], ["l", 0, 1.38], ["l", 0.18, 0], ["c", 0.39, 0.06, 0.96, 0.24, 1.38, 0.48], ["c", 1.68, 0.93, 2.82, 3.24, 3.03, 6.12], ["c", 0.03, 0.24, 0.03, 0.45, 0.03, 0.45], ["c", 0, 0.03, 0.6, 0.03, 1.35, 0.03], ["c", 1.5, 0, 1.47, 0, 1.59, 0.18], ["c", 0.09, 0.12, 0.09, 0.3, 0, 0.42], ["c", -0.12, 0.18, -0.09, 0.18, -1.59, 0.18], ["c", -0.75, 0, -1.35, 0, -1.35, 0.03], ["c", 0, 0, 0, 0.21, -0.03, 0.42], ["c", -0.24, 3.15, -1.53, 5.58, -3.45, 6.36], ["c", -0.27, 0.12, -0.72, 0.24, -0.96, 0.27], ["l", -0.18, 0], ["l", 0, 1.38], ["c", 0, 1.32, 0, 1.41, -0.06, 1.5], ["c", -0.15, 0.24, -0.51, 0.24, -0.66, 0], ["c", -0.06, -0.09, -0.06, -0.18, -0.06, -1.5], ["l", 0, -1.38], ["l", -0.18, 0], ["c", -0.39, -0.06, -0.96, -0.24, -1.38, -0.48], ["c", -1.68, -0.93, -2.82, -3.24, -3.03, -6.15], ["c", -0.03, -0.21, -0.03, -0.42, -0.03, -0.42], ["c", 0, -0.03, -0.6, -0.03, -1.35, -0.03], ["c", -1.5, 0, -1.47, 0, -1.59, -0.18], ["c", -0.09, -0.12, -0.09, -0.3, 0, -0.42], ["c", 0.12, -0.18, 0.09, -0.18, 1.59, -0.18], ["c", 0.75, 0, 1.35, 0, 1.35, -0.03], ["c", 0, 0, 0, -0.21, 0.03, -0.45], ["c", 0.24, -3.12, 1.53, -5.55, 3.45, -6.33], ["c", 0.27, -0.12, 0.72, -0.24, 0.96, -0.27], ["l", 0.18, 0], ["l", 0, -1.38], ["c", 0, -1.53, 0, -1.5, 0.18, -1.62], ["z"], ["m", -0.18, 6.93], ["c", 0, -2.97, 0, -3.15, -0.06, -3.15], ["c", -0.09, 0, -0.51, 0.15, -0.66, 0.21], ["c", -0.87, 0.51, -1.38, 1.62, -1.56, 3.51], ["c", -0.06, 0.54, -0.12, 1.59, -0.12, 2.16], ["l", 0, 0.42], ["l", 1.2, 0], ["l", 1.2, 0], ["l", 0, -3.15], ["z"], ["m", 1.17, -3.06], ["c", -0.09, -0.03, -0.21, -0.06, -0.27, -0.09], ["l", -0.12, 0], ["l", 0, 3.15], ["l", 0, 3.15], ["l", 1.2, 0], ["l", 1.2, 0], ["l", 0, -0.81], ["c", -0.06, -2.4, -0.33, -3.69, -0.93, -4.59], ["c", -0.27, -0.39, -0.66, -0.69, -1.08, -0.81], ["z"], ["m", -1.17, 10.14], ["l", 0, -3.15], ["l", -1.2, 0], ["l", -1.2, 0], ["l", 0, 0.81], ["c", 0.03, 0.96, 0.06, 1.47, 0.15, 2.13], ["c", 0.24, 2.04, 0.96, 3.12, 2.13, 3.36], ["l", 0.12, 0], ["l", 0, -3.15], ["z"], ["m", 3.18, -2.34], ["l", 0, -0.81], ["l", -1.2, 0], ["l", -1.2, 0], ["l", 0, 3.15], ["l", 0, 3.15], ["l", 0.12, 0], ["c", 1.17, -0.24, 1.89, -1.32, 2.13, -3.36], ["c", 0.09, -0.66, 0.12, -1.17, 0.15, -2.13], ["z"]], w: 16.035, h: 21.062 },
      "scripts.comma": { d: [["M", 1.14, -4.62], ["c", 0.3, -0.12, 0.69, -0.03, 0.93, 0.15], ["c", 0.12, 0.12, 0.36, 0.45, 0.51, 0.78], ["c", 0.9, 1.77, 0.54, 4.05, -1.08, 6.75], ["c", -0.36, 0.63, -0.87, 1.38, -0.96, 1.44], ["c", -0.18, 0.12, -0.42, 0.06, -0.54, -0.12], ["c", -0.09, -0.18, -0.09, -0.3, 0.12, -0.6], ["c", 0.96, -1.44, 1.44, -2.97, 1.38, -4.35], ["c", -0.06, -0.93, -0.3, -1.68, -0.78, -2.46], ["c", -0.27, -0.39, -0.33, -0.63, -0.24, -0.96], ["c", 0.09, -0.27, 0.36, -0.54, 0.66, -0.63], ["z"]], w: 3.042, h: 9.237 },
      "scripts.roll": { d: [["M", 1.95, -6], ["c", 0.21, -0.09, 0.36, -0.09, 0.57, 0], ["c", 0.39, 0.15, 0.63, 0.39, 1.47, 1.35], ["c", 0.66, 0.75, 0.78, 0.87, 1.08, 1.05], ["c", 0.75, 0.45, 1.65, 0.42, 2.4, -0.06], ["c", 0.12, -0.09, 0.27, -0.27, 0.54, -0.6], ["c", 0.42, -0.54, 0.51, -0.63, 0.69, -0.63], ["c", 0.09, 0, 0.3, 0.12, 0.36, 0.21], ["c", 0.09, 0.12, 0.12, 0.3, 0.03, 0.42], ["c", -0.06, 0.12, -3.15, 3.9, -3.3, 4.08], ["c", -0.06, 0.06, -0.18, 0.12, -0.27, 0.18], ["c", -0.27, 0.12, -0.6, 0.06, -0.99, -0.27], ["c", -0.27, -0.21, -0.42, -0.39, -1.08, -1.14], ["c", -0.63, -0.72, -0.81, -0.9, -1.17, -1.08], ["c", -0.36, -0.18, -0.57, -0.21, -0.99, -0.21], ["c", -0.39, 0, -0.63, 0.03, -0.93, 0.18], ["c", -0.36, 0.15, -0.51, 0.27, -0.9, 0.81], ["c", -0.24, 0.27, -0.45, 0.51, -0.48, 0.54], ["c", -0.12, 0.09, -0.27, 0.06, -0.39, 0], ["c", -0.24, -0.15, -0.33, -0.39, -0.21, -0.6], ["c", 0.09, -0.12, 3.18, -3.87, 3.33, -4.02], ["c", 0.06, -0.06, 0.18, -0.15, 0.24, -0.21], ["z"]], w: 10.817, h: 6.125 },
      "scripts.prall": { d: [["M", -4.38, -3.69], ["c", 0.06, -0.03, 0.18, -0.06, 0.24, -0.06], ["c", 0.3, 0, 0.27, -0.03, 1.89, 1.95], ["l", 1.53, 1.83], ["c", 0.03, 0, 0.57, -0.84, 1.23, -1.83], ["c", 1.14, -1.68, 1.23, -1.83, 1.35, -1.89], ["c", 0.06, -0.03, 0.18, -0.06, 0.24, -0.06], ["c", 0.3, 0, 0.27, -0.03, 1.89, 1.95], ["l", 1.53, 1.83], ["l", 0.48, -0.69], ["c", 0.51, -0.78, 0.54, -0.84, 0.69, -0.9], ["c", 0.42, -0.18, 0.87, 0.15, 0.81, 0.6], ["c", -0.03, 0.12, -0.3, 0.51, -1.5, 2.37], ["c", -1.38, 2.07, -1.5, 2.22, -1.62, 2.28], ["c", -0.06, 0.03, -0.18, 0.06, -0.24, 0.06], ["c", -0.3, 0, -0.27, 0.03, -1.89, -1.95], ["l", -1.53, -1.83], ["c", -0.03, 0, -0.57, 0.84, -1.23, 1.83], ["c", -1.14, 1.68, -1.23, 1.83, -1.35, 1.89], ["c", -0.06, 0.03, -0.18, 0.06, -0.24, 0.06], ["c", -0.3, 0, -0.27, 0.03, -1.89, -1.95], ["l", -1.53, -1.83], ["l", -0.48, 0.69], ["c", -0.51, 0.78, -0.54, 0.84, -0.69, 0.9], ["c", -0.42, 0.18, -0.87, -0.15, -0.81, -0.6], ["c", 0.03, -0.12, 0.3, -0.51, 1.5, -2.37], ["c", 1.38, -2.07, 1.5, -2.22, 1.62, -2.28], ["z"]], w: 15.011, h: 7.5 },
      "scripts.arpeggio": { d: [["M", 1.5, 0], ["c", 1.5, 2, 1.5, 3, 1.5, 3], ["s", 0, 1, -2, 1.5], ["s", -0.5, 3, 1, 5.5], ["l", 1.5, 0], ["s", -1.75, -2, -1.9, -3.25], ["s", 2.15, -0.6, 2.95, -1.6], ["s", 0.45, -1, 0.5, -1.25], ["s", 0, -1, -2, -3.9], ["l", -1.5, 0], ["z"]], w: 5, h: 10 },
      "scripts.mordent": { d: [["M", -0.21, -4.95], ["c", 0.27, -0.15, 0.63, 0, 0.75, 0.27], ["c", 0.06, 0.12, 0.06, 0.24, 0.06, 1.44], ["l", 0, 1.29], ["l", 0.57, -0.84], ["c", 0.51, -0.75, 0.57, -0.84, 0.69, -0.9], ["c", 0.06, -0.03, 0.18, -0.06, 0.24, -0.06], ["c", 0.3, 0, 0.27, -0.03, 1.89, 1.95], ["l", 1.53, 1.83], ["l", 0.48, -0.69], ["c", 0.51, -0.78, 0.54, -0.84, 0.69, -0.9], ["c", 0.42, -0.18, 0.87, 0.15, 0.81, 0.6], ["c", -0.03, 0.12, -0.3, 0.51, -1.5, 2.37], ["c", -1.38, 2.07, -1.5, 2.22, -1.62, 2.28], ["c", -0.06, 0.03, -0.18, 0.06, -0.24, 0.06], ["c", -0.3, 0, -0.27, 0.03, -1.83, -1.89], ["c", -0.81, -0.99, -1.5, -1.8, -1.53, -1.86], ["c", -0.06, -0.03, -0.06, -0.03, -0.12, 0.03], ["c", -0.06, 0.06, -0.06, 0.15, -0.06, 2.28], ["c", 0, 1.95, 0, 2.25, -0.06, 2.34], ["c", -0.18, 0.45, -0.81, 0.48, -1.05, 0.03], ["c", -0.03, -0.06, -0.06, -0.24, -0.06, -1.41], ["l", 0, -1.35], ["l", -0.57, 0.84], ["c", -0.54, 0.78, -0.6, 0.87, -0.72, 0.93], ["c", -0.06, 0.03, -0.18, 0.06, -0.24, 0.06], ["c", -0.3, 0, -0.27, 0.03, -1.89, -1.95], ["l", -1.53, -1.83], ["l", -0.48, 0.69], ["c", -0.51, 0.78, -0.54, 0.84, -0.69, 0.9], ["c", -0.42, 0.18, -0.87, -0.15, -0.81, -0.6], ["c", 0.03, -0.12, 0.3, -0.51, 1.5, -2.37], ["c", 1.38, -2.07, 1.5, -2.22, 1.62, -2.28], ["c", 0.06, -0.03, 0.18, -0.06, 0.24, -0.06], ["c", 0.3, 0, 0.27, -0.03, 1.89, 1.95], ["l", 1.53, 1.83], ["c", 0.03, 0, 0.06, -0.06, 0.09, -0.09], ["c", 0.06, -0.12, 0.06, -0.15, 0.06, -2.28], ["c", 0, -1.92, 0, -2.22, 0.06, -2.31], ["c", 0.06, -0.15, 0.15, -0.24, 0.3, -0.3], ["z"]], w: 15.011, h: 10.012 },
      "flags.u8th": { d: [["M", -0.42, 3.75], ["l", 0, -3.75], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 0.18], ["c", 0, 0.3, 0.06, 0.84, 0.12, 1.23], ["c", 0.24, 1.53, 0.9, 3.12, 2.13, 5.16], ["l", 0.99, 1.59], ["c", 0.87, 1.44, 1.38, 2.34, 1.77, 3.09], ["c", 0.81, 1.68, 1.2, 3.06, 1.26, 4.53], ["c", 0.03, 1.53, -0.21, 3.27, -0.75, 5.01], ["c", -0.21, 0.69, -0.51, 1.5, -0.6, 1.59], ["c", -0.09, 0.12, -0.27, 0.21, -0.42, 0.21], ["c", -0.15, 0, -0.42, -0.12, -0.51, -0.21], ["c", -0.15, -0.18, -0.18, -0.42, -0.09, -0.66], ["c", 0.15, -0.33, 0.45, -1.2, 0.57, -1.62], ["c", 0.42, -1.38, 0.6, -2.58, 0.6, -3.9], ["c", 0, -0.66, 0, -0.81, -0.06, -1.11], ["c", -0.39, -2.07, -1.8, -4.26, -4.59, -7.14], ["l", -0.42, -0.45], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -3.75], ["z"]], w: 6.692, h: 22.59 },
      "flags.u16th": { d: [["M", -0.42, 7.5], ["l", 0, -7.5], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 0.39], ["c", 0.06, 1.08, 0.39, 2.19, 0.99, 3.39], ["c", 0.45, 0.9, 0.87, 1.59, 1.95, 3.12], ["c", 1.29, 1.86, 1.77, 2.64, 2.22, 3.57], ["c", 0.45, 0.93, 0.72, 1.8, 0.87, 2.64], ["c", 0.06, 0.51, 0.06, 1.5, 0, 1.92], ["c", -0.12, 0.6, -0.3, 1.2, -0.54, 1.71], ["l", -0.09, 0.24], ["l", 0.18, 0.45], ["c", 0.51, 1.2, 0.72, 2.22, 0.69, 3.42], ["c", -0.06, 1.53, -0.39, 3.03, -0.99, 4.53], ["c", -0.3, 0.75, -0.36, 0.81, -0.57, 0.9], ["c", -0.15, 0.09, -0.33, 0.06, -0.48, 0], ["c", -0.18, -0.09, -0.27, -0.18, -0.33, -0.33], ["c", -0.09, -0.18, -0.06, -0.3, 0.12, -0.75], ["c", 0.66, -1.41, 1.02, -2.88, 1.08, -4.32], ["c", 0, -0.6, -0.03, -1.05, -0.18, -1.59], ["c", -0.3, -1.2, -0.99, -2.4, -2.25, -3.87], ["c", -0.42, -0.48, -1.53, -1.62, -2.19, -2.22], ["l", -0.45, -0.42], ["l", -0.03, 1.11], ["l", 0, 1.11], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -7.5], ["z"], ["m", 1.65, 0.09], ["c", -0.3, -0.3, -0.69, -0.72, -0.9, -0.87], ["l", -0.33, -0.33], ["l", 0, 0.15], ["c", 0, 0.3, 0.06, 0.81, 0.15, 1.26], ["c", 0.27, 1.29, 0.87, 2.61, 2.04, 4.29], ["c", 0.15, 0.24, 0.6, 0.87, 0.96, 1.38], ["l", 1.08, 1.53], ["l", 0.42, 0.63], ["c", 0.03, 0, 0.12, -0.36, 0.21, -0.72], ["c", 0.06, -0.33, 0.06, -1.2, 0, -1.62], ["c", -0.33, -1.71, -1.44, -3.48, -3.63, -5.7], ["z"]], w: 6.693, h: 26.337 },
      "flags.u32nd": { d: [["M", -0.42, 11.25], ["l", 0, -11.25], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 0.36], ["c", 0.09, 1.68, 0.69, 3.27, 2.07, 5.46], ["l", 0.87, 1.35], ["c", 1.02, 1.62, 1.47, 2.37, 1.86, 3.18], ["c", 0.48, 1.02, 0.78, 1.92, 0.93, 2.88], ["c", 0.06, 0.48, 0.06, 1.5, 0, 1.89], ["c", -0.09, 0.42, -0.21, 0.87, -0.36, 1.26], ["l", -0.12, 0.3], ["l", 0.15, 0.39], ["c", 0.69, 1.56, 0.84, 2.88, 0.54, 4.38], ["c", -0.09, 0.45, -0.27, 1.08, -0.45, 1.47], ["l", -0.12, 0.24], ["l", 0.18, 0.36], ["c", 0.33, 0.72, 0.57, 1.56, 0.69, 2.34], ["c", 0.12, 1.02, -0.06, 2.52, -0.42, 3.84], ["c", -0.27, 0.93, -0.75, 2.13, -0.93, 2.31], ["c", -0.18, 0.15, -0.45, 0.18, -0.66, 0.09], ["c", -0.18, -0.09, -0.27, -0.18, -0.33, -0.33], ["c", -0.09, -0.18, -0.06, -0.3, 0.06, -0.6], ["c", 0.21, -0.36, 0.42, -0.9, 0.57, -1.38], ["c", 0.51, -1.41, 0.69, -3.06, 0.48, -4.08], ["c", -0.15, -0.81, -0.57, -1.68, -1.2, -2.55], ["c", -0.72, -0.99, -1.83, -2.13, -3.3, -3.33], ["l", -0.48, -0.42], ["l", -0.03, 1.53], ["l", 0, 1.56], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -11.25], ["z"], ["m", 1.26, -3.96], ["c", -0.27, -0.3, -0.54, -0.6, -0.66, -0.72], ["l", -0.18, -0.21], ["l", 0, 0.42], ["c", 0.06, 0.87, 0.24, 1.74, 0.66, 2.67], ["c", 0.36, 0.87, 0.96, 1.86, 1.92, 3.18], ["c", 0.21, 0.33, 0.63, 0.87, 0.87, 1.23], ["c", 0.27, 0.39, 0.6, 0.84, 0.75, 1.08], ["l", 0.27, 0.39], ["l", 0.03, -0.12], ["c", 0.12, -0.45, 0.15, -1.05, 0.09, -1.59], ["c", -0.27, -1.86, -1.38, -3.78, -3.75, -6.33], ["z"], ["m", -0.27, 6.09], ["c", -0.27, -0.21, -0.48, -0.42, -0.51, -0.45], ["c", -0.06, -0.03, -0.06, -0.03, -0.06, 0.21], ["c", 0, 0.9, 0.3, 2.04, 0.81, 3.09], ["c", 0.48, 1.02, 0.96, 1.77, 2.37, 3.63], ["c", 0.6, 0.78, 1.05, 1.44, 1.29, 1.77], ["c", 0.06, 0.12, 0.15, 0.21, 0.15, 0.18], ["c", 0.03, -0.03, 0.18, -0.57, 0.24, -0.87], ["c", 0.06, -0.45, 0.06, -1.32, -0.03, -1.74], ["c", -0.09, -0.48, -0.24, -0.9, -0.51, -1.44], ["c", -0.66, -1.35, -1.83, -2.7, -3.75, -4.38], ["z"]], w: 6.697, h: 32.145 },
      "flags.u64th": { d: [["M", -0.42, 15], ["l", 0, -15], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 0.36], ["c", 0.06, 1.2, 0.39, 2.37, 1.02, 3.66], ["c", 0.39, 0.81, 0.84, 1.56, 1.8, 3.09], ["c", 0.81, 1.26, 1.05, 1.68, 1.35, 2.22], ["c", 0.87, 1.5, 1.35, 2.79, 1.56, 4.08], ["c", 0.06, 0.54, 0.06, 1.56, -0.03, 2.04], ["c", -0.09, 0.48, -0.21, 0.99, -0.36, 1.35], ["l", -0.12, 0.27], ["l", 0.12, 0.27], ["c", 0.09, 0.15, 0.21, 0.45, 0.27, 0.66], ["c", 0.69, 1.89, 0.63, 3.66, -0.18, 5.46], ["l", -0.18, 0.39], ["l", 0.15, 0.33], ["c", 0.3, 0.66, 0.51, 1.44, 0.63, 2.1], ["c", 0.06, 0.48, 0.06, 1.35, 0, 1.71], ["c", -0.15, 0.57, -0.42, 1.2, -0.78, 1.68], ["l", -0.21, 0.27], ["l", 0.18, 0.33], ["c", 0.57, 1.05, 0.93, 2.13, 1.02, 3.18], ["c", 0.06, 0.72, 0, 1.83, -0.21, 2.79], ["c", -0.18, 1.02, -0.63, 2.34, -1.02, 3.09], ["c", -0.15, 0.33, -0.48, 0.45, -0.78, 0.3], ["c", -0.18, -0.09, -0.27, -0.18, -0.33, -0.33], ["c", -0.09, -0.18, -0.06, -0.3, 0.03, -0.54], ["c", 0.75, -1.5, 1.23, -3.45, 1.17, -4.89], ["c", -0.06, -1.02, -0.42, -2.01, -1.17, -3.15], ["c", -0.48, -0.72, -1.02, -1.35, -1.89, -2.22], ["c", -0.57, -0.57, -1.56, -1.5, -1.92, -1.77], ["l", -0.12, -0.09], ["l", 0, 1.68], ["l", 0, 1.68], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -15], ["z"], ["m", 0.93, -8.07], ["c", -0.27, -0.3, -0.48, -0.54, -0.51, -0.54], ["c", 0, 0, 0, 0.69, 0.03, 1.02], ["c", 0.15, 1.47, 0.75, 2.94, 2.04, 4.83], ["l", 1.08, 1.53], ["c", 0.39, 0.57, 0.84, 1.2, 0.99, 1.44], ["c", 0.15, 0.24, 0.3, 0.45, 0.3, 0.45], ["c", 0, 0, 0.03, -0.09, 0.06, -0.21], ["c", 0.36, -1.59, -0.15, -3.33, -1.47, -5.4], ["c", -0.63, -0.93, -1.35, -1.83, -2.52, -3.12], ["z"], ["m", 0.06, 6.72], ["c", -0.24, -0.21, -0.48, -0.42, -0.51, -0.45], ["l", -0.06, -0.06], ["l", 0, 0.33], ["c", 0, 1.2, 0.3, 2.34, 0.93, 3.6], ["c", 0.45, 0.9, 0.96, 1.68, 2.25, 3.51], ["c", 0.39, 0.54, 0.84, 1.17, 1.02, 1.44], ["c", 0.21, 0.33, 0.33, 0.51, 0.33, 0.48], ["c", 0.06, -0.09, 0.21, -0.63, 0.3, -0.99], ["c", 0.06, -0.33, 0.06, -0.45, 0.06, -0.96], ["c", 0, -0.6, -0.03, -0.84, -0.18, -1.35], ["c", -0.3, -1.08, -1.02, -2.28, -2.13, -3.57], ["c", -0.39, -0.45, -1.44, -1.47, -2.01, -1.98], ["z"], ["m", 0, 6.72], ["c", -0.24, -0.21, -0.48, -0.39, -0.51, -0.42], ["l", -0.06, -0.06], ["l", 0, 0.33], ["c", 0, 1.41, 0.45, 2.82, 1.38, 4.35], ["c", 0.42, 0.72, 0.72, 1.14, 1.86, 2.73], ["c", 0.36, 0.45, 0.75, 0.99, 0.87, 1.2], ["c", 0.15, 0.21, 0.3, 0.36, 0.3, 0.36], ["c", 0.06, 0, 0.3, -0.48, 0.39, -0.75], ["c", 0.09, -0.36, 0.12, -0.63, 0.12, -1.05], ["c", -0.06, -1.05, -0.45, -2.04, -1.2, -3.18], ["c", -0.57, -0.87, -1.11, -1.53, -2.07, -2.49], ["c", -0.36, -0.33, -0.84, -0.78, -1.08, -1.02], ["z"]], w: 6.682, h: 39.694 },
      "flags.d8th": { d: [["M", 5.67, -21.63], ["c", 0.24, -0.12, 0.54, -0.06, 0.69, 0.15], ["c", 0.06, 0.06, 0.21, 0.36, 0.39, 0.66], ["c", 0.84, 1.77, 1.26, 3.36, 1.32, 5.1], ["c", 0.03, 1.29, -0.21, 2.37, -0.81, 3.63], ["c", -0.6, 1.23, -1.26, 2.13, -3.21, 4.38], ["c", -1.35, 1.53, -1.86, 2.19, -2.4, 2.97], ["c", -0.63, 0.93, -1.11, 1.92, -1.38, 2.79], ["c", -0.15, 0.54, -0.27, 1.35, -0.27, 1.8], ["l", 0, 0.15], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -3.75], ["l", 0, -3.75], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0.48, -0.3], ["c", 1.83, -1.11, 3.12, -2.1, 4.17, -3.12], ["c", 0.78, -0.81, 1.32, -1.53, 1.71, -2.31], ["c", 0.45, -0.93, 0.6, -1.74, 0.51, -2.88], ["c", -0.12, -1.56, -0.63, -3.18, -1.47, -4.68], ["c", -0.12, -0.21, -0.15, -0.33, -0.06, -0.51], ["c", 0.06, -0.15, 0.15, -0.24, 0.33, -0.33], ["z"]], w: 8.492, h: 21.691 },
      "flags.ugrace": { d: [["M", 6.03, 6.93], ["c", 0.15, -0.09, 0.33, -0.06, 0.51, 0], ["c", 0.15, 0.09, 0.21, 0.15, 0.3, 0.33], ["c", 0.09, 0.18, 0.06, 0.39, -0.03, 0.54], ["c", -0.06, 0.15, -10.89, 8.88, -11.07, 8.97], ["c", -0.15, 0.09, -0.33, 0.06, -0.48, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.09, -0.18, -0.06, -0.39, 0.03, -0.54], ["c", 0.06, -0.15, 10.89, -8.88, 11.07, -8.97], ["z"]], w: 12.019, h: 9.954 },
      "flags.dgrace": { d: [["M", -6.06, -15.93], ["c", 0.18, -0.09, 0.33, -0.12, 0.48, -0.06], ["c", 0.18, 0.09, 14.01, 8.04, 14.1, 8.1], ["c", 0.12, 0.12, 0.18, 0.33, 0.18, 0.51], ["c", -0.03, 0.21, -0.15, 0.39, -0.36, 0.48], ["c", -0.18, 0.09, -0.33, 0.12, -0.48, 0.06], ["c", -0.18, -0.09, -14.01, -8.04, -14.1, -8.1], ["c", -0.12, -0.12, -0.18, -0.33, -0.18, -0.51], ["c", 0.03, -0.21, 0.15, -0.39, 0.36, -0.48], ["z"]], w: 15.12, h: 9.212 },
      "flags.d16th": { d: [["M", 6.84, -22.53], ["c", 0.27, -0.12, 0.57, -0.06, 0.72, 0.15], ["c", 0.15, 0.15, 0.33, 0.87, 0.45, 1.56], ["c", 0.06, 0.33, 0.06, 1.35, 0, 1.65], ["c", -0.06, 0.33, -0.15, 0.78, -0.27, 1.11], ["c", -0.12, 0.33, -0.45, 0.96, -0.66, 1.32], ["l", -0.18, 0.27], ["l", 0.09, 0.18], ["c", 0.48, 1.02, 0.72, 2.25, 0.69, 3.3], ["c", -0.06, 1.23, -0.42, 2.28, -1.26, 3.45], ["c", -0.57, 0.87, -0.99, 1.32, -3, 3.39], ["c", -1.56, 1.56, -2.22, 2.4, -2.76, 3.45], ["c", -0.42, 0.84, -0.66, 1.8, -0.66, 2.55], ["l", 0, 0.15], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -7.5], ["l", 0, -7.5], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 1.14], ["l", 0, 1.11], ["l", 0.27, -0.15], ["c", 1.11, -0.57, 1.77, -0.99, 2.52, -1.47], ["c", 2.37, -1.56, 3.69, -3.15, 4.05, -4.83], ["c", 0.03, -0.18, 0.03, -0.39, 0.03, -0.78], ["c", 0, -0.6, -0.03, -0.93, -0.24, -1.5], ["c", -0.06, -0.18, -0.12, -0.39, -0.15, -0.45], ["c", -0.03, -0.24, 0.12, -0.48, 0.36, -0.6], ["z"], ["m", -0.63, 7.5], ["c", -0.06, -0.18, -0.15, -0.36, -0.15, -0.36], ["c", -0.03, 0, -0.03, 0.03, -0.06, 0.06], ["c", -0.06, 0.12, -0.96, 1.02, -1.95, 1.98], ["c", -0.63, 0.57, -1.26, 1.17, -1.44, 1.35], ["c", -1.53, 1.62, -2.28, 2.85, -2.55, 4.32], ["c", -0.03, 0.18, -0.03, 0.54, -0.06, 0.99], ["l", 0, 0.69], ["l", 0.18, -0.09], ["c", 0.93, -0.54, 2.1, -1.29, 2.82, -1.83], ["c", 0.69, -0.51, 1.02, -0.81, 1.53, -1.29], ["c", 1.86, -1.89, 2.37, -3.66, 1.68, -5.82], ["z"]], w: 8.475, h: 22.591 },
      "flags.d32nd": { d: [["M", 6.84, -29.13], ["c", 0.27, -0.12, 0.57, -0.06, 0.72, 0.15], ["c", 0.12, 0.12, 0.27, 0.63, 0.36, 1.11], ["c", 0.33, 1.59, 0.06, 3.06, -0.81, 4.47], ["l", -0.18, 0.27], ["l", 0.09, 0.15], ["c", 0.12, 0.24, 0.33, 0.69, 0.45, 1.05], ["c", 0.63, 1.83, 0.45, 3.57, -0.57, 5.22], ["l", -0.18, 0.3], ["l", 0.15, 0.27], ["c", 0.42, 0.87, 0.6, 1.71, 0.57, 2.61], ["c", -0.06, 1.29, -0.48, 2.46, -1.35, 3.78], ["c", -0.54, 0.81, -0.93, 1.29, -2.46, 3], ["c", -0.51, 0.54, -1.05, 1.17, -1.26, 1.41], ["c", -1.56, 1.86, -2.25, 3.36, -2.37, 5.01], ["l", 0, 0.33], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -11.25], ["l", 0, -11.25], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 1.35], ["l", 0.03, 1.35], ["l", 0.78, -0.39], ["c", 1.38, -0.69, 2.34, -1.26, 3.24, -1.92], ["c", 1.38, -1.02, 2.28, -2.13, 2.64, -3.21], ["c", 0.15, -0.48, 0.18, -0.72, 0.18, -1.29], ["c", 0, -0.57, -0.06, -0.9, -0.24, -1.47], ["c", -0.06, -0.18, -0.12, -0.39, -0.15, -0.45], ["c", -0.03, -0.24, 0.12, -0.48, 0.36, -0.6], ["z"], ["m", -0.63, 7.2], ["c", -0.09, -0.18, -0.12, -0.21, -0.12, -0.15], ["c", -0.03, 0.09, -1.02, 1.08, -2.04, 2.04], ["c", -1.17, 1.08, -1.65, 1.56, -2.07, 2.04], ["c", -0.84, 0.96, -1.38, 1.86, -1.68, 2.76], ["c", -0.21, 0.57, -0.27, 0.99, -0.3, 1.65], ["l", 0, 0.54], ["l", 0.66, -0.33], ["c", 3.57, -1.86, 5.49, -3.69, 5.94, -5.7], ["c", 0.06, -0.39, 0.06, -1.2, -0.03, -1.65], ["c", -0.06, -0.39, -0.24, -0.9, -0.36, -1.2], ["z"], ["m", -0.06, 7.2], ["c", -0.06, -0.15, -0.12, -0.33, -0.15, -0.45], ["l", -0.06, -0.18], ["l", -0.18, 0.21], ["l", -1.83, 1.83], ["c", -0.87, 0.9, -1.77, 1.8, -1.95, 2.01], ["c", -1.08, 1.29, -1.62, 2.31, -1.89, 3.51], ["c", -0.06, 0.3, -0.06, 0.51, -0.09, 0.93], ["l", 0, 0.57], ["l", 0.09, -0.06], ["c", 0.75, -0.45, 1.89, -1.26, 2.52, -1.74], ["c", 0.81, -0.66, 1.74, -1.53, 2.22, -2.16], ["c", 1.26, -1.53, 1.68, -3.06, 1.32, -4.47], ["z"]], w: 8.385, h: 29.191 },
      "flags.d64th": { d: [["M", 7.08, -32.88], ["c", 0.3, -0.12, 0.66, -0.03, 0.78, 0.24], ["c", 0.18, 0.33, 0.27, 2.1, 0.15, 2.64], ["c", -0.09, 0.39, -0.21, 0.78, -0.39, 1.08], ["l", -0.15, 0.3], ["l", 0.09, 0.27], ["c", 0.03, 0.12, 0.09, 0.45, 0.12, 0.69], ["c", 0.27, 1.44, 0.18, 2.55, -0.3, 3.6], ["l", -0.12, 0.33], ["l", 0.06, 0.42], ["c", 0.27, 1.35, 0.33, 2.82, 0.21, 3.63], ["c", -0.12, 0.6, -0.3, 1.23, -0.57, 1.8], ["l", -0.15, 0.27], ["l", 0.03, 0.42], ["c", 0.06, 1.02, 0.06, 2.7, 0.03, 3.06], ["c", -0.15, 1.47, -0.66, 2.76, -1.74, 4.41], ["c", -0.45, 0.69, -0.75, 1.11, -1.74, 2.37], ["c", -1.05, 1.38, -1.5, 1.98, -1.95, 2.73], ["c", -0.93, 1.5, -1.38, 2.82, -1.44, 4.2], ["l", 0, 0.42], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -15], ["l", 0, -15], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 1.86], ["l", 0, 1.89], ["c", 0, 0, 0.21, -0.03, 0.45, -0.09], ["c", 2.22, -0.39, 4.08, -1.11, 5.19, -2.01], ["c", 0.63, -0.54, 1.02, -1.14, 1.2, -1.8], ["c", 0.06, -0.3, 0.06, -1.14, -0.03, -1.65], ["c", -0.03, -0.18, -0.06, -0.39, -0.09, -0.48], ["c", -0.03, -0.24, 0.12, -0.48, 0.36, -0.6], ["z"], ["m", -0.45, 6.15], ["c", -0.03, -0.18, -0.06, -0.42, -0.06, -0.54], ["l", -0.03, -0.18], ["l", -0.33, 0.3], ["c", -0.42, 0.36, -0.87, 0.72, -1.68, 1.29], ["c", -1.98, 1.38, -2.25, 1.59, -2.85, 2.16], ["c", -0.75, 0.69, -1.23, 1.44, -1.47, 2.19], ["c", -0.15, 0.45, -0.18, 0.63, -0.21, 1.35], ["l", 0, 0.66], ["l", 0.39, -0.18], ["c", 1.83, -0.9, 3.45, -1.95, 4.47, -2.91], ["c", 0.93, -0.9, 1.53, -1.83, 1.74, -2.82], ["c", 0.06, -0.33, 0.06, -0.87, 0.03, -1.32], ["z"], ["m", -0.27, 4.86], ["c", -0.03, -0.21, -0.06, -0.36, -0.06, -0.36], ["c", 0, -0.03, -0.12, 0.09, -0.24, 0.24], ["c", -0.39, 0.48, -0.99, 1.08, -2.16, 2.19], ["c", -1.47, 1.38, -1.92, 1.83, -2.46, 2.49], ["c", -0.66, 0.87, -1.08, 1.74, -1.29, 2.58], ["c", -0.09, 0.42, -0.15, 0.87, -0.15, 1.44], ["l", 0, 0.54], ["l", 0.48, -0.33], ["c", 1.5, -1.02, 2.58, -1.89, 3.51, -2.82], ["c", 1.47, -1.47, 2.25, -2.85, 2.4, -4.26], ["c", 0.03, -0.39, 0.03, -1.17, -0.03, -1.71], ["z"], ["m", -0.66, 7.68], ["c", 0.03, -0.15, 0.03, -0.6, 0.03, -0.99], ["l", 0, -0.72], ["l", -0.27, 0.33], ["l", -1.74, 1.98], ["c", -1.77, 1.92, -2.43, 2.76, -2.97, 3.9], ["c", -0.51, 1.02, -0.72, 1.77, -0.75, 2.91], ["c", 0, 0.63, 0, 0.63, 0.06, 0.6], ["c", 0.03, -0.03, 0.3, -0.27, 0.63, -0.54], ["c", 0.66, -0.6, 1.86, -1.8, 2.31, -2.31], ["c", 1.65, -1.89, 2.52, -3.54, 2.7, -5.16], ["z"]], w: 8.485, h: 32.932 },
      "clefs.C": { d: [["M", 0.06, -14.94], ["l", 0.09, -0.06], ["l", 1.92, 0], ["l", 1.92, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 14.85], ["l", 0, 14.82], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -1.92, 0], ["l", -1.92, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -14.82], ["l", 0, -14.85], ["z"], ["m", 5.37, 0], ["c", 0.09, -0.06, 0.09, -0.06, 0.57, -0.06], ["c", 0.45, 0, 0.45, 0, 0.54, 0.06], ["l", 0.06, 0.09], ["l", 0, 7.14], ["l", 0, 7.11], ["l", 0.09, -0.06], ["c", 0.18, -0.18, 0.72, -0.84, 0.96, -1.2], ["c", 0.3, -0.45, 0.66, -1.17, 0.84, -1.65], ["c", 0.36, -0.9, 0.57, -1.83, 0.6, -2.79], ["c", 0.03, -0.48, 0.03, -0.54, 0.09, -0.63], ["c", 0.12, -0.18, 0.36, -0.21, 0.54, -0.12], ["c", 0.18, 0.09, 0.21, 0.15, 0.24, 0.66], ["c", 0.06, 0.87, 0.21, 1.56, 0.57, 2.22], ["c", 0.51, 1.02, 1.26, 1.68, 2.22, 1.92], ["c", 0.21, 0.06, 0.33, 0.06, 0.78, 0.06], ["c", 0.45, 0, 0.57, 0, 0.84, -0.06], ["c", 0.45, -0.12, 0.81, -0.33, 1.08, -0.6], ["c", 0.57, -0.57, 0.87, -1.41, 0.99, -2.88], ["c", 0.06, -0.54, 0.06, -3, 0, -3.57], ["c", -0.21, -2.58, -0.84, -3.87, -2.16, -4.5], ["c", -0.48, -0.21, -1.17, -0.36, -1.77, -0.36], ["c", -0.69, 0, -1.29, 0.27, -1.5, 0.72], ["c", -0.06, 0.15, -0.06, 0.21, -0.06, 0.42], ["c", 0, 0.24, 0, 0.3, 0.06, 0.45], ["c", 0.12, 0.24, 0.24, 0.39, 0.63, 0.66], ["c", 0.42, 0.3, 0.57, 0.48, 0.69, 0.72], ["c", 0.06, 0.15, 0.06, 0.21, 0.06, 0.48], ["c", 0, 0.39, -0.03, 0.63, -0.21, 0.96], ["c", -0.3, 0.6, -0.87, 1.08, -1.5, 1.26], ["c", -0.27, 0.06, -0.87, 0.06, -1.14, 0], ["c", -0.78, -0.24, -1.44, -0.87, -1.65, -1.68], ["c", -0.12, -0.42, -0.09, -1.17, 0.09, -1.71], ["c", 0.51, -1.65, 1.98, -2.82, 3.81, -3.09], ["c", 0.84, -0.09, 2.46, 0.03, 3.51, 0.27], ["c", 2.22, 0.57, 3.69, 1.8, 4.44, 3.75], ["c", 0.36, 0.93, 0.57, 2.13, 0.57, 3.36], ["c", 0, 1.44, -0.48, 2.73, -1.38, 3.81], ["c", -1.26, 1.5, -3.27, 2.43, -5.28, 2.43], ["c", -0.48, 0, -0.51, 0, -0.75, -0.09], ["c", -0.15, -0.03, -0.48, -0.21, -0.78, -0.36], ["c", -0.69, -0.36, -0.87, -0.42, -1.26, -0.42], ["c", -0.27, 0, -0.3, 0, -0.51, 0.09], ["c", -0.57, 0.3, -0.81, 0.9, -0.81, 2.1], ["c", 0, 1.23, 0.24, 1.83, 0.81, 2.13], ["c", 0.21, 0.09, 0.24, 0.09, 0.51, 0.09], ["c", 0.39, 0, 0.57, -0.06, 1.26, -0.42], ["c", 0.3, -0.15, 0.63, -0.33, 0.78, -0.36], ["c", 0.24, -0.09, 0.27, -0.09, 0.75, -0.09], ["c", 2.01, 0, 4.02, 0.93, 5.28, 2.4], ["c", 0.9, 1.11, 1.38, 2.4, 1.38, 3.84], ["c", 0, 1.5, -0.3, 2.88, -0.84, 3.96], ["c", -0.78, 1.59, -2.19, 2.64, -4.17, 3.15], ["c", -1.05, 0.24, -2.67, 0.36, -3.51, 0.27], ["c", -1.83, -0.27, -3.3, -1.44, -3.81, -3.09], ["c", -0.18, -0.54, -0.21, -1.29, -0.09, -1.74], ["c", 0.15, -0.6, 0.63, -1.2, 1.23, -1.47], ["c", 0.36, -0.18, 0.57, -0.21, 0.99, -0.21], ["c", 0.42, 0, 0.63, 0.03, 1.02, 0.21], ["c", 0.42, 0.21, 0.84, 0.63, 1.05, 1.05], ["c", 0.18, 0.36, 0.21, 0.6, 0.21, 0.96], ["c", 0, 0.3, 0, 0.36, -0.06, 0.51], ["c", -0.12, 0.24, -0.27, 0.42, -0.69, 0.72], ["c", -0.57, 0.42, -0.69, 0.63, -0.69, 1.08], ["c", 0, 0.24, 0, 0.3, 0.06, 0.45], ["c", 0.12, 0.21, 0.3, 0.39, 0.57, 0.54], ["c", 0.42, 0.18, 0.87, 0.21, 1.53, 0.15], ["c", 1.08, -0.15, 1.8, -0.57, 2.34, -1.32], ["c", 0.54, -0.75, 0.84, -1.83, 0.99, -3.51], ["c", 0.06, -0.57, 0.06, -3.03, 0, -3.57], ["c", -0.12, -1.47, -0.42, -2.31, -0.99, -2.88], ["c", -0.27, -0.27, -0.63, -0.48, -1.08, -0.6], ["c", -0.27, -0.06, -0.39, -0.06, -0.84, -0.06], ["c", -0.45, 0, -0.57, 0, -0.78, 0.06], ["c", -1.14, 0.27, -2.01, 1.17, -2.46, 2.49], ["c", -0.21, 0.57, -0.3, 0.99, -0.33, 1.65], ["c", -0.03, 0.51, -0.06, 0.57, -0.24, 0.66], ["c", -0.12, 0.06, -0.27, 0.06, -0.39, 0], ["c", -0.21, -0.09, -0.21, -0.15, -0.24, -0.75], ["c", -0.09, -1.92, -0.78, -3.72, -2.01, -5.19], ["c", -0.18, -0.21, -0.36, -0.42, -0.39, -0.45], ["l", -0.09, -0.06], ["l", 0, 7.11], ["l", 0, 7.14], ["l", -0.06, 0.09], ["c", -0.09, 0.06, -0.09, 0.06, -0.54, 0.06], ["c", -0.48, 0, -0.48, 0, -0.57, -0.06], ["l", -0.06, -0.09], ["l", 0, -14.82], ["l", 0, -14.85], ["z"]], w: 20.31, h: 29.97 },
      "clefs.F": { d: [["M", 6.3, -7.8], ["c", 0.36, -0.03, 1.65, 0, 2.13, 0.03], ["c", 3.6, 0.42, 6.03, 2.1, 6.93, 4.86], ["c", 0.27, 0.84, 0.36, 1.5, 0.36, 2.58], ["c", 0, 0.9, -0.03, 1.35, -0.18, 2.16], ["c", -0.78, 3.78, -3.54, 7.08, -8.37, 9.96], ["c", -1.74, 1.05, -3.87, 2.13, -6.18, 3.12], ["c", -0.39, 0.18, -0.75, 0.33, -0.81, 0.36], ["c", -0.06, 0.03, -0.15, 0.06, -0.18, 0.06], ["c", -0.15, 0, -0.33, -0.18, -0.33, -0.33], ["c", 0, -0.15, 0.06, -0.21, 0.51, -0.48], ["c", 3, -1.77, 5.13, -3.21, 6.84, -4.74], ["c", 0.51, -0.45, 1.59, -1.5, 1.95, -1.95], ["c", 1.89, -2.19, 2.88, -4.32, 3.15, -6.78], ["c", 0.06, -0.42, 0.06, -1.77, 0, -2.19], ["c", -0.24, -2.01, -0.93, -3.63, -2.04, -4.71], ["c", -0.63, -0.63, -1.29, -1.02, -2.07, -1.2], ["c", -1.62, -0.39, -3.36, 0.15, -4.56, 1.44], ["c", -0.54, 0.6, -1.05, 1.47, -1.32, 2.22], ["l", -0.09, 0.21], ["l", 0.24, -0.12], ["c", 0.39, -0.21, 0.63, -0.24, 1.11, -0.24], ["c", 0.3, 0, 0.45, 0, 0.66, 0.06], ["c", 1.92, 0.48, 2.85, 2.55, 1.95, 4.38], ["c", -0.45, 0.99, -1.41, 1.62, -2.46, 1.71], ["c", -1.47, 0.09, -2.91, -0.87, -3.39, -2.25], ["c", -0.18, -0.57, -0.21, -1.32, -0.03, -2.28], ["c", 0.39, -2.25, 1.83, -4.2, 3.81, -5.19], ["c", 0.69, -0.36, 1.59, -0.6, 2.37, -0.69], ["z"], ["m", 11.58, 2.52], ["c", 0.84, -0.21, 1.71, 0.3, 1.89, 1.14], ["c", 0.3, 1.17, -0.72, 2.19, -1.89, 1.89], ["c", -0.99, -0.21, -1.5, -1.32, -1.02, -2.25], ["c", 0.18, -0.39, 0.6, -0.69, 1.02, -0.78], ["z"], ["m", 0, 7.5], ["c", 0.84, -0.21, 1.71, 0.3, 1.89, 1.14], ["c", 0.21, 0.87, -0.3, 1.71, -1.14, 1.89], ["c", -0.87, 0.21, -1.71, -0.3, -1.89, -1.14], ["c", -0.21, -0.84, 0.3, -1.71, 1.14, -1.89], ["z"]], w: 20.153, h: 23.142 },
      "clefs.G": { d: [["M", 9.69, -37.41], ["c", 0.09, -0.09, 0.24, -0.06, 0.36, 0], ["c", 0.12, 0.09, 0.57, 0.6, 0.96, 1.11], ["c", 1.77, 2.34, 3.21, 5.85, 3.57, 8.73], ["c", 0.21, 1.56, 0.03, 3.27, -0.45, 4.86], ["c", -0.69, 2.31, -1.92, 4.47, -4.23, 7.44], ["c", -0.3, 0.39, -0.57, 0.72, -0.6, 0.75], ["c", -0.03, 0.06, 0, 0.15, 0.18, 0.78], ["c", 0.54, 1.68, 1.38, 4.44, 1.68, 5.49], ["l", 0.09, 0.42], ["l", 0.39, 0], ["c", 1.47, 0.09, 2.76, 0.51, 3.96, 1.29], ["c", 1.83, 1.23, 3.06, 3.21, 3.39, 5.52], ["c", 0.09, 0.45, 0.12, 1.29, 0.06, 1.74], ["c", -0.09, 1.02, -0.33, 1.83, -0.75, 2.73], ["c", -0.84, 1.71, -2.28, 3.06, -4.02, 3.72], ["l", -0.33, 0.12], ["l", 0.03, 1.26], ["c", 0, 1.74, -0.06, 3.63, -0.21, 4.62], ["c", -0.45, 3.06, -2.19, 5.49, -4.47, 6.21], ["c", -0.57, 0.18, -0.9, 0.21, -1.59, 0.21], ["c", -0.69, 0, -1.02, -0.03, -1.65, -0.21], ["c", -1.14, -0.27, -2.13, -0.84, -2.94, -1.65], ["c", -0.99, -0.99, -1.56, -2.16, -1.71, -3.54], ["c", -0.09, -0.81, 0.06, -1.53, 0.45, -2.13], ["c", 0.63, -0.99, 1.83, -1.56, 3, -1.53], ["c", 1.5, 0.09, 2.64, 1.32, 2.73, 2.94], ["c", 0.06, 1.47, -0.93, 2.7, -2.37, 2.97], ["c", -0.45, 0.06, -0.84, 0.03, -1.29, -0.09], ["l", -0.21, -0.09], ["l", 0.09, 0.12], ["c", 0.39, 0.54, 0.78, 0.93, 1.32, 1.26], ["c", 1.35, 0.87, 3.06, 1.02, 4.35, 0.36], ["c", 1.44, -0.72, 2.52, -2.28, 2.97, -4.35], ["c", 0.15, -0.66, 0.24, -1.5, 0.3, -3.03], ["c", 0.03, -0.84, 0.03, -2.94, 0, -3], ["c", -0.03, 0, -0.18, 0, -0.36, 0.03], ["c", -0.66, 0.12, -0.99, 0.12, -1.83, 0.12], ["c", -1.05, 0, -1.71, -0.06, -2.61, -0.3], ["c", -4.02, -0.99, -7.11, -4.35, -7.8, -8.46], ["c", -0.12, -0.66, -0.12, -0.99, -0.12, -1.83], ["c", 0, -0.84, 0, -1.14, 0.15, -1.92], ["c", 0.36, -2.28, 1.41, -4.62, 3.3, -7.29], ["l", 2.79, -3.6], ["c", 0.54, -0.66, 0.96, -1.2, 0.96, -1.23], ["c", 0, -0.03, -0.09, -0.33, -0.18, -0.69], ["c", -0.96, -3.21, -1.41, -5.28, -1.59, -7.68], ["c", -0.12, -1.38, -0.15, -3.09, -0.06, -3.96], ["c", 0.33, -2.67, 1.38, -5.07, 3.12, -7.08], ["c", 0.36, -0.42, 0.99, -1.05, 1.17, -1.14], ["z"], ["m", 2.01, 4.71], ["c", -0.15, -0.3, -0.3, -0.54, -0.3, -0.54], ["c", -0.03, 0, -0.18, 0.09, -0.3, 0.21], ["c", -2.4, 1.74, -3.87, 4.2, -4.26, 7.11], ["c", -0.06, 0.54, -0.06, 1.41, -0.03, 1.89], ["c", 0.09, 1.29, 0.48, 3.12, 1.08, 5.22], ["c", 0.15, 0.42, 0.24, 0.78, 0.24, 0.81], ["c", 0, 0.03, 0.84, -1.11, 1.23, -1.68], ["c", 1.89, -2.73, 2.88, -5.07, 3.15, -7.53], ["c", 0.09, -0.57, 0.12, -1.74, 0.06, -2.37], ["c", -0.09, -1.23, -0.27, -1.92, -0.87, -3.12], ["z"], ["m", -2.94, 20.7], ["c", -0.21, -0.72, -0.39, -1.32, -0.42, -1.32], ["c", 0, 0, -1.2, 1.47, -1.86, 2.37], ["c", -2.79, 3.63, -4.02, 6.3, -4.35, 9.3], ["c", -0.03, 0.21, -0.03, 0.69, -0.03, 1.08], ["c", 0, 0.69, 0, 0.75, 0.06, 1.11], ["c", 0.12, 0.54, 0.27, 0.99, 0.51, 1.47], ["c", 0.69, 1.38, 1.83, 2.55, 3.42, 3.42], ["c", 0.96, 0.54, 2.07, 0.9, 3.21, 1.08], ["c", 0.78, 0.12, 2.04, 0.12, 2.94, -0.03], ["c", 0.51, -0.06, 0.45, -0.03, 0.42, -0.3], ["c", -0.24, -3.33, -0.72, -6.33, -1.62, -10.08], ["c", -0.09, -0.39, -0.18, -0.75, -0.18, -0.78], ["c", -0.03, -0.03, -0.42, 0, -0.81, 0.09], ["c", -0.9, 0.18, -1.65, 0.57, -2.22, 1.14], ["c", -0.72, 0.72, -1.08, 1.65, -1.05, 2.64], ["c", 0.06, 0.96, 0.48, 1.83, 1.23, 2.58], ["c", 0.36, 0.36, 0.72, 0.63, 1.17, 0.9], ["c", 0.33, 0.18, 0.36, 0.21, 0.42, 0.33], ["c", 0.18, 0.42, -0.18, 0.9, -0.6, 0.87], ["c", -0.18, -0.03, -0.84, -0.36, -1.26, -0.63], ["c", -0.78, -0.51, -1.38, -1.11, -1.86, -1.83], ["c", -1.77, -2.7, -0.99, -6.42, 1.71, -8.19], ["c", 0.3, -0.21, 0.81, -0.48, 1.17, -0.63], ["c", 0.3, -0.09, 1.02, -0.3, 1.14, -0.3], ["c", 0.06, 0, 0.09, 0, 0.09, -0.03], ["c", 0.03, -0.03, -0.51, -1.92, -1.23, -4.26], ["z"], ["m", 3.78, 7.41], ["c", -0.18, -0.03, -0.36, -0.06, -0.39, -0.06], ["c", -0.03, 0, 0, 0.21, 0.18, 1.02], ["c", 0.75, 3.18, 1.26, 6.3, 1.5, 9.09], ["c", 0.06, 0.72, 0, 0.69, 0.51, 0.42], ["c", 0.78, -0.36, 1.44, -0.96, 1.98, -1.77], ["c", 1.08, -1.62, 1.2, -3.69, 0.3, -5.55], ["c", -0.81, -1.62, -2.31, -2.79, -4.08, -3.15], ["z"]], w: 19.051, h: 57.057 },
      "clefs.perc": { d: [["M", 5.07, -7.44], ["l", 0.09, -0.06], ["l", 1.53, 0], ["l", 1.53, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 7.35], ["l", 0, 7.32], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -1.53, 0], ["l", -1.53, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -7.32], ["l", 0, -7.35], ["z"], ["m", 6.63, 0], ["l", 0.09, -0.06], ["l", 1.53, 0], ["l", 1.53, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 7.35], ["l", 0, 7.32], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -1.53, 0], ["l", -1.53, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -7.32], ["l", 0, -7.35], ["z"]], w: 21, h: 14.97 },
      "tab.big": { d: [["M", 20.16, -21.66], ["c", 0.24, -0.09, 0.66, 0.09, 0.78, 0.36], ["c", 0.09, 0.21, 0.09, 0.24, -0.18, 0.54], ["c", -0.78, 0.81, -1.86, 1.44, -2.94, 1.71], ["c", -0.87, 0.24, -1.71, 0.24, -2.55, 0.03], ["l", -0.06, -0.03], ["l", -0.18, 0.99], ["c", -0.33, 1.98, -0.75, 4.26, -0.96, 5.04], ["c", -0.42, 1.65, -1.26, 3.18, -2.28, 4.14], ["c", -0.57, 0.57, -1.17, 0.9, -1.86, 1.08], ["c", -0.18, 0.06, -0.33, 0.06, -0.66, 0.06], ["c", -0.54, 0, -0.78, -0.03, -1.23, -0.27], ["c", -0.39, -0.18, -0.66, -0.39, -1.38, -0.99], ["c", -0.3, -0.24, -0.66, -0.51, -0.75, -0.57], ["c", -0.21, -0.15, -0.27, -0.24, -0.24, -0.45], ["c", 0.06, -0.27, 0.36, -0.6, 0.6, -0.66], ["c", 0.18, -0.03, 0.33, 0.06, 0.9, 0.57], ["c", 0.48, 0.42, 0.72, 0.57, 0.93, 0.69], ["c", 0.66, 0.33, 1.38, 0.21, 1.95, -0.36], ["c", 0.63, -0.6, 1.05, -1.62, 1.23, -3], ["c", 0.03, -0.18, 0.09, -0.66, 0.09, -1.11], ["c", 0.09, -1.56, 0.33, -3.81, 0.57, -5.49], ["c", 0.06, -0.33, 0.09, -0.63, 0.09, -0.63], ["c", -0.03, -0.03, -0.81, -0.12, -1.02, -0.12], ["c", -0.57, 0, -1.32, 0.12, -1.8, 0.33], ["c", -0.87, 0.3, -1.35, 0.78, -1.5, 1.41], ["c", -0.18, 0.63, 0.09, 1.26, 0.66, 1.65], ["c", 0.12, 0.06, 0.15, 0.12, 0.18, 0.24], ["c", 0.09, 0.27, 0.06, 0.57, -0.09, 0.75], ["c", -0.03, 0.06, -0.12, 0.09, -0.27, 0.15], ["c", -0.72, 0.21, -1.44, 0.15, -2.1, -0.18], ["c", -0.54, -0.27, -0.96, -0.66, -1.2, -1.14], ["c", -0.39, -0.75, -0.33, -1.74, 0.15, -2.52], ["c", 0.27, -0.42, 0.84, -0.93, 1.41, -1.23], ["c", 1.17, -0.57, 2.88, -0.9, 4.8, -0.9], ["c", 0.69, 0, 0.78, 0, 1.08, 0.06], ["c", 0.45, 0.09, 1.11, 0.3, 2.07, 0.6], ["c", 1.47, 0.48, 1.83, 0.57, 2.55, 0.54], ["c", 1.02, -0.06, 2.04, -0.45, 2.94, -1.11], ["c", 0.12, -0.09, 0.24, -0.18, 0.27, -0.18], ["z"], ["m", -5.88, 13.05], ["c", 0.21, -0.03, 0.81, 0, 1.08, 0.06], ["c", 0.48, 0.12, 0.9, 0.42, 0.99, 0.69], ["c", 0.03, 0.09, 0.03, 0.15, 0, 0.27], ["c", 0, 0.09, -0.03, 0.57, -0.06, 1.08], ["c", -0.09, 2.19, -0.24, 5.76, -0.39, 8.28], ["c", -0.06, 1.53, -0.06, 1.77, 0.03, 2.01], ["c", 0.09, 0.18, 0.15, 0.24, 0.3, 0.3], ["c", 0.24, 0.12, 0.54, 0.06, 1.23, -0.27], ["c", 0.57, -0.27, 0.66, -0.3, 0.75, -0.24], ["c", 0.09, 0.06, 0.18, 0.3, 0.18, 0.45], ["c", 0, 0.33, -0.15, 0.51, -0.45, 0.63], ["c", -0.12, 0.03, -0.39, 0.15, -0.6, 0.27], ["c", -1.17, 0.6, -1.38, 0.69, -1.8, 0.72], ["c", -0.45, 0.03, -0.78, -0.09, -1.08, -0.39], ["c", -0.39, -0.42, -0.66, -1.2, -1.02, -3.12], ["c", -0.24, -1.23, -0.36, -2.07, -0.54, -3.75], ["l", 0, -0.18], ["l", -0.36, 0.45], ["c", -0.6, 0.75, -1.32, 1.59, -1.95, 2.25], ["c", -0.15, 0.18, -0.27, 0.3, -0.27, 0.33], ["c", 0, 0, 0.06, 0.09, 0.15, 0.18], ["c", 0.24, 0.33, 0.6, 0.57, 1.05, 0.69], ["c", 0.18, 0.06, 0.3, 0.06, 0.69, 0.06], ["l", 0.48, 0.03], ["l", 0.06, 0.12], ["c", 0.15, 0.27, 0.03, 0.72, -0.21, 0.9], ["c", -0.18, 0.12, -0.93, 0.27, -1.41, 0.27], ["c", -0.84, 0, -1.59, -0.3, -1.98, -0.84], ["l", -0.12, -0.15], ["l", -0.45, 0.42], ["c", -0.99, 0.87, -1.53, 1.32, -2.16, 1.74], ["c", -0.78, 0.51, -1.5, 0.84, -2.1, 0.93], ["c", -0.69, 0.12, -1.2, 0.03, -1.95, -0.42], ["c", -0.21, -0.12, -0.51, -0.27, -0.66, -0.36], ["c", -0.24, -0.12, -0.3, -0.18, -0.33, -0.24], ["c", -0.12, -0.27, 0.15, -0.78, 0.45, -0.93], ["c", 0.24, -0.12, 0.33, -0.09, 0.9, 0.18], ["c", 0.6, 0.3, 0.84, 0.39, 1.2, 0.36], ["c", 0.87, -0.09, 1.77, -0.69, 3.24, -2.31], ["c", 2.67, -2.85, 4.59, -5.94, 5.7, -9.15], ["c", 0.15, -0.45, 0.24, -0.63, 0.42, -0.81], ["c", 0.21, -0.24, 0.6, -0.45, 0.99, -0.51], ["z"], ["m", -3.99, 16.05], ["c", 0.18, 0, 0.69, -0.03, 1.17, 0], ["c", 3.27, 0.03, 5.37, 0.75, 6, 2.07], ["c", 0.45, 0.99, 0.12, 2.4, -0.81, 3.42], ["c", -0.24, 0.27, -0.57, 0.57, -0.84, 0.75], ["c", -0.09, 0.06, -0.18, 0.09, -0.18, 0.12], ["c", 0, 0, 0.18, 0.03, 0.42, 0.09], ["c", 1.23, 0.3, 2.01, 0.81, 2.37, 1.59], ["c", 0.27, 0.54, 0.3, 1.32, 0.09, 2.1], ["c", -0.12, 0.36, -0.45, 1.05, -0.69, 1.35], ["c", -0.87, 1.17, -2.1, 1.92, -3.54, 2.25], ["c", -0.36, 0.06, -0.48, 0.06, -0.96, 0.06], ["c", -0.45, 0, -0.66, 0, -0.84, -0.03], ["c", -0.84, -0.18, -1.47, -0.51, -2.07, -1.11], ["c", -0.33, -0.33, -0.45, -0.51, -0.45, -0.63], ["c", 0, -0.06, 0.03, -0.15, 0.06, -0.24], ["c", 0.18, -0.33, 0.69, -0.6, 0.93, -0.48], ["c", 0.03, 0.03, 0.15, 0.12, 0.27, 0.24], ["c", 0.39, 0.42, 0.99, 0.57, 1.62, 0.45], ["c", 1.05, -0.21, 1.98, -1.02, 2.31, -2.01], ["c", 0.48, -1.53, -0.48, -2.55, -2.58, -2.67], ["c", -0.21, 0, -0.36, -0.03, -0.42, -0.06], ["c", -0.15, -0.09, -0.21, -0.51, -0.06, -0.78], ["c", 0.12, -0.27, 0.24, -0.33, 0.6, -0.36], ["c", 0.57, -0.06, 1.11, -0.42, 1.5, -0.99], ["c", 0.48, -0.72, 0.54, -1.59, 0.18, -2.31], ["c", -0.12, -0.21, -0.45, -0.54, -0.69, -0.69], ["c", -0.33, -0.21, -0.93, -0.45, -1.35, -0.51], ["l", -0.12, -0.03], ["l", -0.06, 0.48], ["c", -0.54, 2.94, -1.14, 6.24, -1.29, 6.75], ["c", -0.33, 1.35, -0.93, 2.61, -1.65, 3.6], ["c", -0.3, 0.36, -0.81, 0.9, -1.14, 1.14], ["c", -0.3, 0.24, -0.84, 0.48, -1.14, 0.57], ["c", -0.33, 0.09, -0.96, 0.09, -1.26, 0.03], ["c", -0.45, -0.12, -0.87, -0.39, -1.53, -0.96], ["c", -0.24, -0.15, -0.51, -0.39, -0.63, -0.48], ["c", -0.3, -0.21, -0.33, -0.33, -0.21, -0.63], ["c", 0.12, -0.18, 0.27, -0.36, 0.42, -0.45], ["c", 0.27, -0.12, 0.36, -0.09, 0.87, 0.33], ["c", 0.78, 0.6, 1.08, 0.75, 1.65, 0.72], ["c", 0.45, -0.03, 0.81, -0.21, 1.17, -0.54], ["c", 0.87, -0.9, 1.38, -2.85, 1.38, -5.37], ["c", 0, -0.6, 0.03, -1.11, 0.12, -2.04], ["c", 0.06, -0.69, 0.24, -2.01, 0.33, -2.58], ["c", 0.06, -0.24, 0.06, -0.42, 0.06, -0.42], ["c", 0, 0, -0.12, 0.03, -0.21, 0.09], ["c", -1.44, 0.57, -2.16, 1.65, -1.74, 2.55], ["c", 0.09, 0.15, 0.18, 0.24, 0.27, 0.33], ["c", 0.24, 0.21, 0.3, 0.27, 0.33, 0.39], ["c", 0.06, 0.24, 0, 0.63, -0.15, 0.78], ["c", -0.09, 0.12, -0.54, 0.21, -0.96, 0.24], ["c", -1.02, 0.03, -2.01, -0.48, -2.43, -1.32], ["c", -0.21, -0.45, -0.27, -0.9, -0.15, -1.44], ["c", 0.06, -0.27, 0.21, -0.66, 0.39, -0.93], ["c", 0.87, -1.29, 3, -2.22, 5.64, -2.43], ["z"]], w: 19.643, h: 43.325 },
      "tab.tiny": { d: [["M", 16.02, -17.25], ["c", 0.12, -0.09, 0.15, -0.09, 0.27, -0.09], ["c", 0.21, 0.03, 0.51, 0.3, 0.51, 0.45], ["c", 0, 0.06, -0.12, 0.18, -0.3, 0.36], ["c", -1.11, 1.08, -2.55, 1.59, -3.84, 1.41], ["c", -0.15, -0.03, -0.33, -0.06, -0.39, -0.09], ["c", -0.06, -0.03, -0.09, -0.03, -0.12, -0.03], ["c", 0, 0, -0.06, 0.42, -0.15, 0.93], ["c", -0.33, 2.01, -0.66, 3.69, -0.84, 4.26], ["c", -0.42, 1.41, -1.23, 2.67, -2.16, 3.33], ["c", -0.27, 0.18, -0.75, 0.42, -0.99, 0.48], ["c", -0.3, 0.09, -0.72, 0.09, -1.02, 0.06], ["c", -0.45, -0.09, -0.84, -0.33, -1.53, -0.9], ["c", -0.21, -0.18, -0.51, -0.39, -0.63, -0.48], ["c", -0.27, -0.21, -0.3, -0.24, -0.3, -0.36], ["c", 0, -0.12, 0.09, -0.36, 0.18, -0.45], ["c", 0.09, -0.09, 0.27, -0.18, 0.36, -0.18], ["c", 0.12, 0, 0.3, 0.12, 0.66, 0.45], ["c", 0.57, 0.51, 0.87, 0.69, 1.23, 0.72], ["c", 0.93, 0.06, 1.68, -0.78, 1.98, -2.37], ["c", 0.09, -0.39, 0.15, -0.75, 0.18, -1.53], ["c", 0.06, -0.99, 0.24, -2.79, 0.42, -4.05], ["c", 0.03, -0.3, 0.06, -0.57, 0.06, -0.6], ["c", 0, -0.06, -0.03, -0.09, -0.15, -0.12], ["c", -0.9, -0.18, -2.13, 0.06, -2.76, 0.57], ["c", -0.36, 0.3, -0.51, 0.6, -0.51, 1.02], ["c", 0, 0.45, 0.15, 0.75, 0.48, 0.99], ["c", 0.06, 0.06, 0.15, 0.18, 0.18, 0.24], ["c", 0.12, 0.24, 0.03, 0.63, -0.15, 0.69], ["c", -0.24, 0.12, -0.6, 0.15, -0.9, 0.15], ["c", -0.36, -0.03, -0.57, -0.09, -0.87, -0.24], ["c", -0.78, -0.36, -1.23, -1.11, -1.2, -1.92], ["c", 0.12, -1.53, 1.74, -2.49, 4.62, -2.7], ["c", 1.2, -0.09, 1.47, -0.03, 3.33, 0.57], ["c", 0.9, 0.3, 1.14, 0.36, 1.56, 0.39], ["c", 0.45, 0, 0.93, -0.06, 1.38, -0.21], ["c", 0.51, -0.18, 0.81, -0.33, 1.41, -0.75], ["z"], ["m", -4.68, 10.38], ["c", 0.39, -0.06, 0.84, 0, 1.2, 0.15], ["c", 0.24, 0.12, 0.36, 0.21, 0.45, 0.36], ["l", 0.09, 0.09], ["l", -0.06, 1.41], ["c", -0.09, 2.19, -0.18, 3.96, -0.27, 5.49], ["c", -0.03, 0.78, -0.06, 1.59, -0.06, 1.86], ["c", 0, 0.42, 0, 0.48, 0.06, 0.57], ["c", 0.06, 0.18, 0.18, 0.24, 0.36, 0.27], ["c", 0.18, 0, 0.39, -0.06, 0.84, -0.27], ["c", 0.45, -0.21, 0.54, -0.24, 0.63, -0.18], ["c", 0.12, 0.12, 0.15, 0.54, 0.03, 0.69], ["c", -0.03, 0.03, -0.15, 0.12, -0.27, 0.18], ["c", -0.15, 0.03, -0.3, 0.12, -0.36, 0.15], ["c", -0.87, 0.45, -1.02, 0.51, -1.26, 0.57], ["c", -0.33, 0.09, -0.6, 0.06, -0.84, -0.06], ["c", -0.42, -0.18, -0.63, -0.6, -0.87, -1.44], ["c", -0.3, -1.23, -0.57, -2.97, -0.66, -4.08], ["c", 0, -0.18, -0.03, -0.3, -0.03, -0.33], ["l", -0.06, 0.06], ["c", -0.18, 0.27, -1.11, 1.38, -1.68, 2.01], ["l", -0.33, 0.33], ["l", 0.06, 0.09], ["c", 0.06, 0.15, 0.27, 0.33, 0.48, 0.42], ["c", 0.27, 0.18, 0.51, 0.24, 0.96, 0.27], ["l", 0.39, 0], ["l", 0.03, 0.12], ["c", 0.12, 0.21, 0.03, 0.57, -0.15, 0.69], ["c", -0.03, 0.03, -0.21, 0.09, -0.36, 0.15], ["c", -0.27, 0.06, -0.39, 0.06, -0.75, 0.06], ["c", -0.48, 0, -0.75, -0.03, -1.08, -0.21], ["c", -0.21, -0.12, -0.51, -0.36, -0.57, -0.48], ["l", -0.03, -0.09], ["l", -0.39, 0.36], ["c", -1.47, 1.35, -2.49, 1.98, -3.42, 2.13], ["c", -0.54, 0.09, -0.96, -0.03, -1.62, -0.39], ["c", -0.21, -0.15, -0.45, -0.27, -0.54, -0.3], ["c", -0.18, -0.09, -0.21, -0.21, -0.12, -0.45], ["c", 0.06, -0.27, 0.33, -0.48, 0.54, -0.48], ["c", 0.03, 0, 0.27, 0.09, 0.48, 0.21], ["c", 0.48, 0.24, 0.69, 0.27, 0.99, 0.27], ["c", 0.6, -0.06, 1.17, -0.42, 2.1, -1.35], ["c", 2.22, -2.22, 4.02, -4.98, 4.95, -7.59], ["c", 0.21, -0.57, 0.3, -0.78, 0.48, -0.93], ["c", 0.15, -0.15, 0.42, -0.27, 0.66, -0.33], ["z"], ["m", -3.06, 12.84], ["c", 0.27, -0.03, 1.68, 0, 2.01, 0.03], ["c", 1.92, 0.18, 3.15, 0.69, 3.63, 1.5], ["c", 0.18, 0.33, 0.24, 0.51, 0.21, 0.93], ["c", 0, 0.45, -0.06, 0.72, -0.24, 1.11], ["c", -0.24, 0.51, -0.69, 1.02, -1.17, 1.35], ["c", -0.21, 0.15, -0.21, 0.15, -0.12, 0.18], ["c", 0.72, 0.15, 1.11, 0.3, 1.5, 0.57], ["c", 0.39, 0.24, 0.63, 0.57, 0.75, 0.96], ["c", 0.09, 0.3, 0.09, 0.96, 0, 1.29], ["c", -0.15, 0.57, -0.39, 1.05, -0.78, 1.5], ["c", -0.66, 0.75, -1.62, 1.32, -2.61, 1.53], ["c", -0.27, 0.06, -0.42, 0.06, -0.84, 0.06], ["c", -0.48, 0, -0.57, 0, -0.81, -0.06], ["c", -0.6, -0.18, -1.05, -0.42, -1.47, -0.81], ["c", -0.36, -0.39, -0.42, -0.51, -0.3, -0.75], ["c", 0.12, -0.21, 0.39, -0.39, 0.6, -0.39], ["c", 0.09, 0, 0.15, 0.03, 0.33, 0.18], ["c", 0.12, 0.12, 0.27, 0.24, 0.36, 0.27], ["c", 0.96, 0.48, 2.46, -0.33, 2.82, -1.5], ["c", 0.24, -0.81, -0.03, -1.44, -0.69, -1.77], ["c", -0.39, -0.21, -1.02, -0.33, -1.53, -0.33], ["c", -0.18, 0, -0.21, 0, -0.27, -0.09], ["c", -0.06, -0.09, -0.06, -0.3, -0.03, -0.48], ["c", 0.06, -0.18, 0.18, -0.36, 0.33, -0.36], ["c", 0.39, -0.06, 0.51, -0.09, 0.72, -0.18], ["c", 0.69, -0.36, 1.11, -1.23, 0.99, -2.01], ["c", -0.09, -0.51, -0.42, -0.9, -0.93, -1.17], ["c", -0.24, -0.12, -0.6, -0.27, -0.87, -0.3], ["c", -0.09, -0.03, -0.09, -0.03, -0.12, 0.12], ["c", 0, 0.09, -0.21, 1.11, -0.42, 2.25], ["c", -0.66, 3.75, -0.72, 3.99, -1.26, 5.07], ["c", -0.9, 1.89, -2.25, 2.85, -3.48, 2.61], ["c", -0.39, -0.09, -0.69, -0.27, -1.38, -0.84], ["c", -0.63, -0.51, -0.63, -0.48, -0.63, -0.6], ["c", 0, -0.18, 0.18, -0.48, 0.39, -0.57], ["c", 0.21, -0.12, 0.3, -0.09, 0.81, 0.33], ["c", 0.15, 0.15, 0.39, 0.3, 0.54, 0.36], ["c", 0.18, 0.12, 0.27, 0.12, 0.48, 0.15], ["c", 0.99, 0.06, 1.71, -0.78, 2.04, -2.46], ["c", 0.12, -0.66, 0.18, -1.14, 0.21, -2.22], ["c", 0.03, -1.23, 0.12, -2.25, 0.36, -3.63], ["c", 0.03, -0.24, 0.06, -0.45, 0.06, -0.48], ["c", -0.06, -0.03, -0.66, 0.27, -0.9, 0.42], ["c", -0.06, 0.06, -0.21, 0.18, -0.33, 0.3], ["c", -0.57, 0.57, -0.6, 1.35, -0.06, 1.74], ["c", 0.18, 0.12, 0.24, 0.24, 0.21, 0.51], ["c", -0.03, 0.3, -0.15, 0.42, -0.57, 0.48], ["c", -1.11, 0.24, -2.22, -0.42, -2.43, -1.38], ["c", -0.09, -0.45, 0.03, -1.02, 0.3, -1.47], ["c", 0.18, -0.24, 0.6, -0.63, 0.9, -0.84], ["c", 0.9, -0.6, 2.28, -1.02, 3.69, -1.11], ["z"]], w: 15.709, h: 34.656 },
      "timesig.common": { d: [["M", 6.66, -7.83], ["c", 0.72, -0.06, 1.41, -0.03, 1.98, 0.09], ["c", 1.2, 0.27, 2.34, 0.96, 3.09, 1.92], ["c", 0.63, 0.81, 1.08, 1.86, 1.14, 2.73], ["c", 0.06, 1.02, -0.51, 1.92, -1.44, 2.22], ["c", -0.24, 0.09, -0.3, 0.09, -0.63, 0.09], ["c", -0.33, 0, -0.42, 0, -0.63, -0.06], ["c", -0.66, -0.24, -1.14, -0.63, -1.41, -1.2], ["c", -0.15, -0.3, -0.21, -0.51, -0.24, -0.9], ["c", -0.06, -1.08, 0.57, -2.04, 1.56, -2.37], ["c", 0.18, -0.06, 0.27, -0.06, 0.63, -0.06], ["l", 0.45, 0], ["c", 0.06, 0.03, 0.09, 0.03, 0.09, 0], ["c", 0, 0, -0.09, -0.12, -0.24, -0.27], ["c", -1.02, -1.11, -2.55, -1.68, -4.08, -1.5], ["c", -1.29, 0.15, -2.04, 0.69, -2.4, 1.74], ["c", -0.36, 0.93, -0.42, 1.89, -0.42, 5.37], ["c", 0, 2.97, 0.06, 3.96, 0.24, 4.77], ["c", 0.24, 1.08, 0.63, 1.68, 1.41, 2.07], ["c", 0.81, 0.39, 2.16, 0.45, 3.18, 0.09], ["c", 1.29, -0.45, 2.37, -1.53, 3.03, -2.97], ["c", 0.15, -0.33, 0.33, -0.87, 0.39, -1.17], ["c", 0.09, -0.24, 0.15, -0.36, 0.3, -0.39], ["c", 0.21, -0.03, 0.42, 0.15, 0.39, 0.36], ["c", -0.06, 0.39, -0.42, 1.38, -0.69, 1.89], ["c", -0.96, 1.8, -2.49, 2.94, -4.23, 3.18], ["c", -0.99, 0.12, -2.58, -0.06, -3.63, -0.45], ["c", -0.96, -0.36, -1.71, -0.84, -2.4, -1.5], ["c", -1.11, -1.11, -1.8, -2.61, -2.04, -4.56], ["c", -0.06, -0.6, -0.06, -2.01, 0, -2.61], ["c", 0.24, -1.95, 0.9, -3.45, 2.01, -4.56], ["c", 0.69, -0.66, 1.44, -1.11, 2.37, -1.47], ["c", 0.63, -0.24, 1.47, -0.42, 2.22, -0.48], ["z"]], w: 13.038, h: 15.689 },
      "timesig.cut": { d: [["M", 6.24, -10.44], ["c", 0.09, -0.06, 0.09, -0.06, 0.48, -0.06], ["c", 0.36, 0, 0.36, 0, 0.45, 0.06], ["l", 0.06, 0.09], ["l", 0, 1.23], ["l", 0, 1.26], ["l", 0.27, 0], ["c", 1.26, 0, 2.49, 0.45, 3.48, 1.29], ["c", 1.05, 0.87, 1.8, 2.28, 1.89, 3.48], ["c", 0.06, 1.02, -0.51, 1.92, -1.44, 2.22], ["c", -0.24, 0.09, -0.3, 0.09, -0.63, 0.09], ["c", -0.33, 0, -0.42, 0, -0.63, -0.06], ["c", -0.66, -0.24, -1.14, -0.63, -1.41, -1.2], ["c", -0.15, -0.3, -0.21, -0.51, -0.24, -0.9], ["c", -0.06, -1.08, 0.57, -2.04, 1.56, -2.37], ["c", 0.18, -0.06, 0.27, -0.06, 0.63, -0.06], ["l", 0.45, 0], ["c", 0.06, 0.03, 0.09, 0.03, 0.09, 0], ["c", 0, -0.03, -0.45, -0.51, -0.66, -0.69], ["c", -0.87, -0.69, -1.83, -1.05, -2.94, -1.11], ["l", -0.42, 0], ["l", 0, 7.17], ["l", 0, 7.14], ["l", 0.42, 0], ["c", 0.69, -0.03, 1.23, -0.18, 1.86, -0.51], ["c", 1.05, -0.51, 1.89, -1.47, 2.46, -2.7], ["c", 0.15, -0.33, 0.33, -0.87, 0.39, -1.17], ["c", 0.09, -0.24, 0.15, -0.36, 0.3, -0.39], ["c", 0.21, -0.03, 0.42, 0.15, 0.39, 0.36], ["c", -0.03, 0.24, -0.21, 0.78, -0.39, 1.2], ["c", -0.96, 2.37, -2.94, 3.9, -5.13, 3.9], ["l", -0.3, 0], ["l", 0, 1.26], ["l", 0, 1.23], ["l", -0.06, 0.09], ["c", -0.09, 0.06, -0.09, 0.06, -0.45, 0.06], ["c", -0.39, 0, -0.39, 0, -0.48, -0.06], ["l", -0.06, -0.09], ["l", 0, -1.29], ["l", 0, -1.29], ["l", -0.21, -0.03], ["c", -1.23, -0.21, -2.31, -0.63, -3.21, -1.29], ["c", -0.15, -0.09, -0.45, -0.36, -0.66, -0.57], ["c", -1.11, -1.11, -1.8, -2.61, -2.04, -4.56], ["c", -0.06, -0.6, -0.06, -2.01, 0, -2.61], ["c", 0.24, -1.95, 0.93, -3.45, 2.04, -4.59], ["c", 0.42, -0.39, 0.78, -0.66, 1.26, -0.93], ["c", 0.75, -0.45, 1.65, -0.75, 2.61, -0.9], ["l", 0.21, -0.03], ["l", 0, -1.29], ["l", 0, -1.29], ["z"], ["m", -0.06, 10.44], ["c", 0, -5.58, 0, -6.99, -0.03, -6.99], ["c", -0.15, 0, -0.63, 0.27, -0.87, 0.45], ["c", -0.45, 0.36, -0.75, 0.93, -0.93, 1.77], ["c", -0.18, 0.81, -0.24, 1.8, -0.24, 4.74], ["c", 0, 2.97, 0.06, 3.96, 0.24, 4.77], ["c", 0.24, 1.08, 0.66, 1.68, 1.41, 2.07], ["c", 0.12, 0.06, 0.3, 0.12, 0.33, 0.15], ["l", 0.09, 0], ["l", 0, -6.96], ["z"]], w: 13.038, h: 20.97 },
      "timesig.imperfectum": { d: [["M", 13, -5], ["a", 8, 8, 0, 1, 0, 0, 10]], w: 13.038, h: 20.97 },
      "timesig.imperfectum2": { d: [["M", 13, -5], ["a", 8, 8, 0, 1, 0, 0, 10]], w: 13.038, h: 20.97 },
      "timesig.perfectum": { d: [["M", 13, -5], ["a", 8, 8, 0, 1, 0, 0, 10]], w: 13.038, h: 20.97 },
      "timesig.perfectum2": { d: [["M", 13, -5], ["a", 8, 8, 0, 1, 0, 0, 10]], w: 13.038, h: 20.97 },
      "f": { d: [["M", 9.93, -14.28], ["c", 1.53, -0.18, 2.88, 0.45, 3.12, 1.5], ["c", 0.12, 0.51, 0, 1.32, -0.27, 1.86], ["c", -0.15, 0.3, -0.42, 0.57, -0.63, 0.69], ["c", -0.69, 0.36, -1.56, 0.03, -1.83, -0.69], ["c", -0.09, -0.24, -0.09, -0.69, 0, -0.87], ["c", 0.06, -0.12, 0.21, -0.24, 0.45, -0.42], ["c", 0.42, -0.24, 0.57, -0.45, 0.6, -0.72], ["c", 0.03, -0.33, -0.09, -0.39, -0.63, -0.42], ["c", -0.3, 0, -0.45, 0, -0.6, 0.03], ["c", -0.81, 0.21, -1.35, 0.93, -1.74, 2.46], ["c", -0.06, 0.27, -0.48, 2.25, -0.48, 2.31], ["c", 0, 0.03, 0.39, 0.03, 0.9, 0.03], ["c", 0.72, 0, 0.9, 0, 0.99, 0.06], ["c", 0.42, 0.15, 0.45, 0.72, 0.03, 0.9], ["c", -0.12, 0.06, -0.24, 0.06, -1.17, 0.06], ["l", -1.05, 0], ["l", -0.78, 2.55], ["c", -0.45, 1.41, -0.87, 2.79, -0.96, 3.06], ["c", -0.87, 2.37, -2.37, 4.74, -3.78, 5.91], ["c", -1.05, 0.9, -2.04, 1.23, -3.09, 1.08], ["c", -1.11, -0.18, -1.89, -0.78, -2.04, -1.59], ["c", -0.12, -0.66, 0.15, -1.71, 0.54, -2.19], ["c", 0.69, -0.75, 1.86, -0.54, 2.22, 0.39], ["c", 0.06, 0.15, 0.09, 0.27, 0.09, 0.48], ["c", 0, 0.24, -0.03, 0.27, -0.12, 0.42], ["c", -0.03, 0.09, -0.15, 0.18, -0.27, 0.27], ["c", -0.09, 0.06, -0.27, 0.21, -0.36, 0.27], ["c", -0.24, 0.18, -0.36, 0.36, -0.39, 0.6], ["c", -0.03, 0.33, 0.09, 0.39, 0.63, 0.42], ["c", 0.42, 0, 0.63, -0.03, 0.9, -0.15], ["c", 0.6, -0.3, 0.96, -0.96, 1.38, -2.64], ["c", 0.09, -0.42, 0.63, -2.55, 1.17, -4.77], ["l", 1.02, -4.08], ["c", 0, -0.03, -0.36, -0.03, -0.81, -0.03], ["c", -0.72, 0, -0.81, 0, -0.93, -0.06], ["c", -0.42, -0.18, -0.39, -0.75, 0.03, -0.9], ["c", 0.09, -0.06, 0.27, -0.06, 1.05, -0.06], ["l", 0.96, 0], ["l", 0, -0.09], ["c", 0.06, -0.18, 0.3, -0.72, 0.51, -1.17], ["c", 1.2, -2.46, 3.3, -4.23, 5.34, -4.5], ["z"]], w: 16.155, h: 19.445 },
      "m": { d: [["M", 2.79, -8.91], ["c", 0.09, 0, 0.3, -0.03, 0.45, -0.03], ["c", 0.24, 0.03, 0.3, 0.03, 0.45, 0.12], ["c", 0.36, 0.15, 0.63, 0.54, 0.75, 1.02], ["l", 0.03, 0.21], ["l", 0.33, -0.3], ["c", 0.69, -0.69, 1.38, -1.02, 2.07, -1.02], ["c", 0.27, 0, 0.33, 0, 0.48, 0.06], ["c", 0.21, 0.09, 0.48, 0.36, 0.63, 0.6], ["c", 0.03, 0.09, 0.12, 0.27, 0.18, 0.42], ["c", 0.03, 0.15, 0.09, 0.27, 0.12, 0.27], ["c", 0, 0, 0.09, -0.09, 0.18, -0.21], ["c", 0.33, -0.39, 0.87, -0.81, 1.29, -0.99], ["c", 0.78, -0.33, 1.47, -0.21, 2.01, 0.33], ["c", 0.3, 0.33, 0.48, 0.69, 0.6, 1.14], ["c", 0.09, 0.42, 0.06, 0.54, -0.54, 3.06], ["c", -0.33, 1.29, -0.57, 2.4, -0.57, 2.43], ["c", 0, 0.12, 0.09, 0.21, 0.21, 0.21], ["c", 0.24, 0, 0.75, -0.3, 1.2, -0.72], ["c", 0.45, -0.39, 0.6, -0.45, 0.78, -0.27], ["c", 0.18, 0.18, 0.09, 0.36, -0.45, 0.87], ["c", -1.05, 0.96, -1.83, 1.47, -2.58, 1.71], ["c", -0.93, 0.33, -1.53, 0.21, -1.8, -0.33], ["c", -0.06, -0.15, -0.06, -0.21, -0.06, -0.45], ["c", 0, -0.24, 0.03, -0.48, 0.6, -2.82], ["c", 0.42, -1.71, 0.6, -2.64, 0.63, -2.79], ["c", 0.03, -0.57, -0.3, -0.75, -0.84, -0.48], ["c", -0.24, 0.12, -0.54, 0.39, -0.66, 0.63], ["c", -0.03, 0.09, -0.42, 1.38, -0.9, 3], ["c", -0.9, 3.15, -0.84, 3, -1.14, 3.15], ["l", -0.15, 0.09], ["l", -0.78, 0], ["c", -0.6, 0, -0.78, 0, -0.84, -0.06], ["c", -0.09, -0.03, -0.18, -0.18, -0.18, -0.27], ["c", 0, -0.03, 0.36, -1.38, 0.84, -2.97], ["c", 0.57, -2.04, 0.81, -2.97, 0.84, -3.12], ["c", 0.03, -0.54, -0.3, -0.72, -0.84, -0.45], ["c", -0.24, 0.12, -0.57, 0.42, -0.66, 0.63], ["c", -0.06, 0.09, -0.51, 1.44, -1.05, 2.97], ["c", -0.51, 1.56, -0.99, 2.85, -0.99, 2.91], ["c", -0.06, 0.12, -0.21, 0.24, -0.36, 0.3], ["c", -0.12, 0.06, -0.21, 0.06, -0.9, 0.06], ["c", -0.6, 0, -0.78, 0, -0.84, -0.06], ["c", -0.09, -0.03, -0.18, -0.18, -0.18, -0.27], ["c", 0, -0.03, 0.45, -1.38, 0.99, -2.97], ["c", 1.05, -3.18, 1.05, -3.18, 0.93, -3.45], ["c", -0.12, -0.27, -0.39, -0.3, -0.72, -0.15], ["c", -0.54, 0.27, -1.14, 1.17, -1.56, 2.4], ["c", -0.06, 0.15, -0.15, 0.3, -0.18, 0.36], ["c", -0.21, 0.21, -0.57, 0.27, -0.72, 0.09], ["c", -0.09, -0.09, -0.06, -0.21, 0.06, -0.63], ["c", 0.48, -1.26, 1.26, -2.46, 2.01, -3.21], ["c", 0.57, -0.54, 1.2, -0.87, 1.83, -1.02], ["z"]], w: 14.687, h: 9.126 },
      "p": { d: [["M", 1.92, -8.7], ["c", 0.27, -0.09, 0.81, -0.06, 1.11, 0.03], ["c", 0.54, 0.18, 0.93, 0.51, 1.17, 0.99], ["c", 0.09, 0.15, 0.15, 0.33, 0.18, 0.36], ["l", 0, 0.12], ["l", 0.3, -0.27], ["c", 0.66, -0.6, 1.35, -1.02, 2.13, -1.2], ["c", 0.21, -0.06, 0.33, -0.06, 0.78, -0.06], ["c", 0.45, 0, 0.51, 0, 0.84, 0.09], ["c", 1.29, 0.33, 2.07, 1.32, 2.25, 2.79], ["c", 0.09, 0.81, -0.09, 2.01, -0.45, 2.79], ["c", -0.54, 1.26, -1.86, 2.55, -3.18, 3.03], ["c", -0.45, 0.18, -0.81, 0.24, -1.29, 0.24], ["c", -0.69, -0.03, -1.35, -0.18, -1.86, -0.45], ["c", -0.3, -0.15, -0.51, -0.18, -0.69, -0.09], ["c", -0.09, 0.03, -0.18, 0.09, -0.18, 0.12], ["c", -0.09, 0.12, -1.05, 2.94, -1.05, 3.06], ["c", 0, 0.24, 0.18, 0.48, 0.51, 0.63], ["c", 0.18, 0.06, 0.54, 0.15, 0.75, 0.15], ["c", 0.21, 0, 0.36, 0.06, 0.42, 0.18], ["c", 0.12, 0.18, 0.06, 0.42, -0.12, 0.54], ["c", -0.09, 0.03, -0.15, 0.03, -0.78, 0], ["c", -1.98, -0.15, -3.81, -0.15, -5.79, 0], ["c", -0.63, 0.03, -0.69, 0.03, -0.78, 0], ["c", -0.24, -0.15, -0.24, -0.57, 0.03, -0.66], ["c", 0.06, -0.03, 0.48, -0.09, 0.99, -0.12], ["c", 0.87, -0.06, 1.11, -0.09, 1.35, -0.21], ["c", 0.18, -0.06, 0.33, -0.18, 0.39, -0.3], ["c", 0.06, -0.12, 3.24, -9.42, 3.27, -9.6], ["c", 0.06, -0.33, 0.03, -0.57, -0.15, -0.69], ["c", -0.09, -0.06, -0.12, -0.06, -0.3, -0.06], ["c", -0.69, 0.06, -1.53, 1.02, -2.28, 2.61], ["c", -0.09, 0.21, -0.21, 0.45, -0.27, 0.51], ["c", -0.09, 0.12, -0.33, 0.24, -0.48, 0.24], ["c", -0.18, 0, -0.36, -0.15, -0.36, -0.3], ["c", 0, -0.24, 0.78, -1.83, 1.26, -2.55], ["c", 0.72, -1.11, 1.47, -1.74, 2.28, -1.92], ["z"], ["m", 5.37, 1.47], ["c", -0.27, -0.12, -0.75, -0.03, -1.14, 0.21], ["c", -0.75, 0.48, -1.47, 1.68, -1.89, 3.15], ["c", -0.45, 1.47, -0.42, 2.34, 0, 2.7], ["c", 0.45, 0.39, 1.26, 0.21, 1.83, -0.36], ["c", 0.51, -0.51, 0.99, -1.68, 1.38, -3.27], ["c", 0.3, -1.17, 0.33, -1.74, 0.15, -2.13], ["c", -0.09, -0.15, -0.15, -0.21, -0.33, -0.3], ["z"]], w: 14.689, h: 13.127 },
      "r": { d: [["M", 6.33, -9.12], ["c", 0.27, -0.03, 0.93, 0, 1.2, 0.06], ["c", 0.84, 0.21, 1.23, 0.81, 1.02, 1.53], ["c", -0.24, 0.75, -0.9, 1.17, -1.56, 0.96], ["c", -0.33, -0.09, -0.51, -0.3, -0.66, -0.75], ["c", -0.03, -0.12, -0.09, -0.24, -0.12, -0.3], ["c", -0.09, -0.15, -0.3, -0.24, -0.48, -0.24], ["c", -0.57, 0, -1.38, 0.54, -1.65, 1.08], ["c", -0.06, 0.15, -0.33, 1.17, -0.9, 3.27], ["c", -0.57, 2.31, -0.81, 3.12, -0.87, 3.21], ["c", -0.03, 0.06, -0.12, 0.15, -0.18, 0.21], ["l", -0.12, 0.06], ["l", -0.81, 0.03], ["c", -0.69, 0, -0.81, 0, -0.9, -0.03], ["c", -0.09, -0.06, -0.18, -0.21, -0.18, -0.3], ["c", 0, -0.06, 0.39, -1.62, 0.9, -3.51], ["c", 0.84, -3.24, 0.87, -3.45, 0.87, -3.72], ["c", 0, -0.21, 0, -0.27, -0.03, -0.36], ["c", -0.12, -0.15, -0.21, -0.24, -0.42, -0.24], ["c", -0.24, 0, -0.45, 0.15, -0.78, 0.42], ["c", -0.33, 0.36, -0.45, 0.54, -0.72, 1.14], ["c", -0.03, 0.12, -0.21, 0.24, -0.36, 0.27], ["c", -0.12, 0, -0.15, 0, -0.24, -0.06], ["c", -0.18, -0.12, -0.18, -0.21, -0.06, -0.54], ["c", 0.21, -0.57, 0.42, -0.93, 0.78, -1.32], ["c", 0.54, -0.51, 1.2, -0.81, 1.95, -0.87], ["c", 0.81, -0.03, 1.53, 0.3, 1.92, 0.87], ["l", 0.12, 0.18], ["l", 0.09, -0.09], ["c", 0.57, -0.45, 1.41, -0.84, 2.19, -0.96], ["z"]], w: 9.41, h: 9.132 },
      "s": { d: [["M", 4.47, -8.73], ["c", 0.09, 0, 0.36, -0.03, 0.57, -0.03], ["c", 0.75, 0.03, 1.29, 0.24, 1.71, 0.63], ["c", 0.51, 0.54, 0.66, 1.26, 0.36, 1.83], ["c", -0.24, 0.42, -0.63, 0.57, -1.11, 0.42], ["c", -0.33, -0.09, -0.6, -0.36, -0.6, -0.57], ["c", 0, -0.03, 0.06, -0.21, 0.15, -0.39], ["c", 0.12, -0.21, 0.15, -0.33, 0.18, -0.48], ["c", 0, -0.24, -0.06, -0.48, -0.15, -0.6], ["c", -0.15, -0.21, -0.42, -0.24, -0.75, -0.15], ["c", -0.27, 0.06, -0.48, 0.18, -0.69, 0.36], ["c", -0.39, 0.39, -0.51, 0.96, -0.33, 1.38], ["c", 0.09, 0.21, 0.42, 0.51, 0.78, 0.72], ["c", 1.11, 0.69, 1.59, 1.11, 1.89, 1.68], ["c", 0.21, 0.39, 0.24, 0.78, 0.15, 1.29], ["c", -0.18, 1.2, -1.17, 2.16, -2.52, 2.52], ["c", -1.02, 0.24, -1.95, 0.12, -2.7, -0.42], ["c", -0.72, -0.51, -0.99, -1.47, -0.6, -2.19], ["c", 0.24, -0.48, 0.72, -0.63, 1.17, -0.42], ["c", 0.33, 0.18, 0.54, 0.45, 0.57, 0.81], ["c", 0, 0.21, -0.03, 0.3, -0.33, 0.51], ["c", -0.33, 0.24, -0.39, 0.42, -0.27, 0.69], ["c", 0.06, 0.15, 0.21, 0.27, 0.45, 0.33], ["c", 0.3, 0.09, 0.87, 0.09, 1.2, 0], ["c", 0.75, -0.21, 1.23, -0.72, 1.29, -1.35], ["c", 0.03, -0.42, -0.15, -0.81, -0.54, -1.2], ["c", -0.24, -0.24, -0.48, -0.42, -1.41, -1.02], ["c", -0.69, -0.42, -1.05, -0.93, -1.05, -1.47], ["c", 0, -0.39, 0.12, -0.87, 0.3, -1.23], ["c", 0.27, -0.57, 0.78, -1.05, 1.38, -1.35], ["c", 0.24, -0.12, 0.63, -0.27, 0.9, -0.3], ["z"]], w: 6.632, h: 8.758 },
      "z": { d: [["M", 2.64, -7.95], ["c", 0.36, -0.09, 0.81, -0.03, 1.71, 0.27], ["c", 0.78, 0.21, 0.96, 0.27, 1.74, 0.3], ["c", 0.87, 0.06, 1.02, 0.03, 1.38, -0.21], ["c", 0.21, -0.15, 0.33, -0.15, 0.48, -0.06], ["c", 0.15, 0.09, 0.21, 0.3, 0.15, 0.45], ["c", -0.03, 0.06, -1.26, 1.26, -2.76, 2.67], ["l", -2.73, 2.55], ["l", 0.54, 0.03], ["c", 0.54, 0.03, 0.72, 0.03, 2.01, 0.15], ["c", 0.36, 0.03, 0.9, 0.06, 1.2, 0.09], ["c", 0.66, 0, 0.81, -0.03, 1.02, -0.24], ["c", 0.3, -0.3, 0.39, -0.72, 0.27, -1.23], ["c", -0.06, -0.27, -0.06, -0.27, -0.03, -0.39], ["c", 0.15, -0.3, 0.54, -0.27, 0.69, 0.03], ["c", 0.15, 0.33, 0.27, 1.02, 0.27, 1.5], ["c", 0, 1.47, -1.11, 2.7, -2.52, 2.79], ["c", -0.57, 0.03, -1.02, -0.09, -2.01, -0.51], ["c", -1.02, -0.42, -1.23, -0.48, -2.13, -0.54], ["c", -0.81, -0.06, -0.96, -0.03, -1.26, 0.18], ["c", -0.12, 0.06, -0.24, 0.12, -0.27, 0.12], ["c", -0.27, 0, -0.45, -0.3, -0.36, -0.51], ["c", 0.03, -0.06, 1.32, -1.32, 2.91, -2.79], ["l", 2.88, -2.73], ["c", -0.03, 0, -0.21, 0.03, -0.42, 0.06], ["c", -0.21, 0.03, -0.78, 0.09, -1.23, 0.12], ["c", -1.11, 0.12, -1.23, 0.15, -1.95, 0.27], ["c", -0.72, 0.15, -1.17, 0.18, -1.29, 0.09], ["c", -0.27, -0.18, -0.21, -0.75, 0.12, -1.26], ["c", 0.39, -0.6, 0.93, -1.02, 1.59, -1.2], ["z"]], w: 8.573, h: 8.743 },
      "+": { d: [["M", 3.48, -9.3], ["c", 0.18, -0.09, 0.36, -0.09, 0.54, 0], ["c", 0.18, 0.09, 0.24, 0.15, 0.33, 0.3], ["l", 0.06, 0.15], ["l", 0, 1.29], ["l", 0, 1.29], ["l", 1.29, 0], ["c", 1.23, 0, 1.29, 0, 1.41, 0.06], ["c", 0.06, 0.03, 0.15, 0.09, 0.18, 0.12], ["c", 0.12, 0.09, 0.21, 0.33, 0.21, 0.48], ["c", 0, 0.15, -0.09, 0.39, -0.21, 0.48], ["c", -0.03, 0.03, -0.12, 0.09, -0.18, 0.12], ["c", -0.12, 0.06, -0.18, 0.06, -1.41, 0.06], ["l", -1.29, 0], ["l", 0, 1.29], ["c", 0, 1.23, 0, 1.29, -0.06, 1.41], ["c", -0.09, 0.18, -0.15, 0.24, -0.3, 0.33], ["c", -0.21, 0.09, -0.39, 0.09, -0.57, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.06, -0.12, -0.06, -0.18, -0.06, -1.41], ["l", 0, -1.29], ["l", -1.29, 0], ["c", -1.23, 0, -1.29, 0, -1.41, -0.06], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.09, -0.18, -0.09, -0.36, 0, -0.54], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["l", 0.15, -0.06], ["l", 1.26, 0], ["l", 1.29, 0], ["l", 0, -1.29], ["c", 0, -1.23, 0, -1.29, 0.06, -1.41], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["z"]], w: 7.507, h: 7.515 },
      ",": { d: [["M", 1.85, -3.36], ["c", 0.57, -0.15, 1.17, 0.03, 1.59, 0.45], ["c", 0.45, 0.45, 0.6, 0.96, 0.51, 1.89], ["c", -0.09, 1.23, -0.42, 2.46, -0.99, 3.93], ["c", -0.3, 0.72, -0.72, 1.62, -0.78, 1.68], ["c", -0.18, 0.21, -0.51, 0.18, -0.66, -0.06], ["c", -0.03, -0.06, -0.06, -0.15, -0.06, -0.18], ["c", 0, -0.06, 0.12, -0.33, 0.24, -0.63], ["c", 0.84, -1.8, 1.02, -2.61, 0.69, -3.24], ["c", -0.12, -0.24, -0.27, -0.36, -0.75, -0.6], ["c", -0.36, -0.15, -0.42, -0.21, -0.6, -0.39], ["c", -0.69, -0.69, -0.69, -1.71, 0, -2.4], ["c", 0.21, -0.21, 0.51, -0.39, 0.81, -0.45], ["z"]], w: 3.452, h: 8.143 },
      "-": { d: [["M", 0.18, -5.34], ["c", 0.09, -0.06, 0.15, -0.06, 2.31, -0.06], ["c", 2.46, 0, 2.37, 0, 2.46, 0.21], ["c", 0.12, 0.21, 0.03, 0.42, -0.15, 0.54], ["c", -0.09, 0.06, -0.15, 0.06, -2.28, 0.06], ["c", -2.16, 0, -2.22, 0, -2.31, -0.06], ["c", -0.27, -0.15, -0.27, -0.54, -0.03, -0.69], ["z"]], w: 5.001, h: 0.81 },
      ".": { d: [["M", 1.32, -3.36], ["c", 1.05, -0.27, 2.1, 0.57, 2.1, 1.65], ["c", 0, 1.08, -1.05, 1.92, -2.1, 1.65], ["c", -0.9, -0.21, -1.5, -1.14, -1.26, -2.04], ["c", 0.12, -0.63, 0.63, -1.11, 1.26, -1.26], ["z"]], w: 3.413, h: 3.402 },
      "scripts.wedge": { d: [["M", -3.66, -7.44], ["c", 0.06, -0.09, 0, -0.09, 0.81, 0.03], ["c", 1.86, 0.3, 3.84, 0.3, 5.73, 0], ["c", 0.78, -0.12, 0.72, -0.12, 0.78, -0.03], ["c", 0.15, 0.15, 0.12, 0.24, -0.24, 0.6], ["c", -0.93, 0.93, -1.98, 2.76, -2.67, 4.62], ["c", -0.3, 0.78, -0.51, 1.71, -0.51, 2.13], ["c", 0, 0.15, 0, 0.18, -0.06, 0.27], ["c", -0.12, 0.09, -0.24, 0.09, -0.36, 0], ["c", -0.06, -0.09, -0.06, -0.12, -0.06, -0.27], ["c", 0, -0.42, -0.21, -1.35, -0.51, -2.13], ["c", -0.69, -1.86, -1.74, -3.69, -2.67, -4.62], ["c", -0.36, -0.36, -0.39, -0.45, -0.24, -0.6], ["z"]], w: 7.49, h: 7.752 },
      "scripts.thumb": { d: [["M", -0.54, -3.69], ["c", 0.15, -0.03, 0.36, -0.06, 0.51, -0.06], ["c", 1.44, 0, 2.58, 1.11, 2.94, 2.85], ["c", 0.09, 0.48, 0.09, 1.32, 0, 1.8], ["c", -0.27, 1.41, -1.08, 2.43, -2.16, 2.73], ["l", -0.18, 0.06], ["l", 0, 0.12], ["c", 0.03, 0.06, 0.06, 0.45, 0.09, 0.87], ["c", 0.03, 0.57, 0.03, 0.78, 0, 0.84], ["c", -0.09, 0.27, -0.39, 0.48, -0.66, 0.48], ["c", -0.27, 0, -0.57, -0.21, -0.66, -0.48], ["c", -0.03, -0.06, -0.03, -0.27, 0, -0.84], ["c", 0.03, -0.42, 0.06, -0.81, 0.09, -0.87], ["l", 0, -0.12], ["l", -0.18, -0.06], ["c", -1.08, -0.3, -1.89, -1.32, -2.16, -2.73], ["c", -0.09, -0.48, -0.09, -1.32, 0, -1.8], ["c", 0.15, -0.84, 0.51, -1.53, 1.02, -2.04], ["c", 0.39, -0.39, 0.84, -0.63, 1.35, -0.75], ["z"], ["m", 1.05, 0.9], ["c", -0.15, -0.09, -0.21, -0.09, -0.45, -0.12], ["c", -0.15, 0, -0.3, 0.03, -0.39, 0.03], ["c", -0.57, 0.18, -0.9, 0.72, -1.08, 1.74], ["c", -0.06, 0.48, -0.06, 1.8, 0, 2.28], ["c", 0.15, 0.9, 0.42, 1.44, 0.9, 1.65], ["c", 0.18, 0.09, 0.21, 0.09, 0.51, 0.09], ["c", 0.3, 0, 0.33, 0, 0.51, -0.09], ["c", 0.48, -0.21, 0.75, -0.75, 0.9, -1.65], ["c", 0.03, -0.27, 0.03, -0.54, 0.03, -1.14], ["c", 0, -0.6, 0, -0.87, -0.03, -1.14], ["c", -0.15, -0.9, -0.45, -1.44, -0.9, -1.65], ["z"]], w: 5.955, h: 9.75 },
      "scripts.open": { d: [["M", -0.54, -3.69], ["c", 0.15, -0.03, 0.36, -0.06, 0.51, -0.06], ["c", 1.44, 0, 2.58, 1.11, 2.94, 2.85], ["c", 0.09, 0.48, 0.09, 1.32, 0, 1.8], ["c", -0.33, 1.74, -1.47, 2.85, -2.91, 2.85], ["c", -1.44, 0, -2.58, -1.11, -2.91, -2.85], ["c", -0.09, -0.48, -0.09, -1.32, 0, -1.8], ["c", 0.15, -0.84, 0.51, -1.53, 1.02, -2.04], ["c", 0.39, -0.39, 0.84, -0.63, 1.35, -0.75], ["z"], ["m", 1.11, 0.9], ["c", -0.21, -0.09, -0.27, -0.09, -0.51, -0.12], ["c", -0.3, 0, -0.42, 0.03, -0.66, 0.15], ["c", -0.24, 0.12, -0.51, 0.39, -0.66, 0.63], ["c", -0.54, 0.93, -0.63, 2.64, -0.21, 3.81], ["c", 0.21, 0.54, 0.51, 0.9, 0.93, 1.11], ["c", 0.21, 0.09, 0.24, 0.09, 0.54, 0.09], ["c", 0.3, 0, 0.33, 0, 0.54, -0.09], ["c", 0.42, -0.21, 0.72, -0.57, 0.93, -1.11], ["c", 0.36, -0.99, 0.36, -2.37, 0, -3.36], ["c", -0.21, -0.54, -0.51, -0.9, -0.9, -1.11], ["z"]], w: 5.955, h: 7.5 },
      "scripts.longphrase": { d: [["M", 1.47, -15.09], ["c", 0.36, -0.09, 0.66, -0.18, 0.69, -0.18], ["c", 0.06, 0, 0.06, 0.54, 0.06, 11.25], ["l", 0, 11.25], ["l", -0.63, 0.15], ["c", -0.66, 0.18, -1.44, 0.39, -1.5, 0.39], ["c", -0.03, 0, -0.03, -3.39, -0.03, -11.25], ["l", 0, -11.25], ["l", 0.36, -0.09], ["c", 0.21, -0.06, 0.66, -0.18, 1.05, -0.27], ["z"]], w: 2.16, h: 23.04 },
      "scripts.mediumphrase": { d: [["M", 1.47, -7.59], ["c", 0.36, -0.09, 0.66, -0.18, 0.69, -0.18], ["c", 0.06, 0, 0.06, 0.39, 0.06, 7.5], ["l", 0, 7.5], ["l", -0.63, 0.15], ["c", -0.66, 0.18, -1.44, 0.39, -1.5, 0.39], ["c", -0.03, 0, -0.03, -2.28, -0.03, -7.5], ["l", 0, -7.5], ["l", 0.36, -0.09], ["c", 0.21, -0.06, 0.66, -0.18, 1.05, -0.27], ["z"]], w: 2.16, h: 15.54 },
      "scripts.shortphrase": { d: [["M", 1.47, -7.59], ["c", 0.36, -0.09, 0.66, -0.18, 0.69, -0.18], ["c", 0.06, 0, 0.06, 0.21, 0.06, 3.75], ["l", 0, 3.75], ["l", -0.42, 0.09], ["c", -0.57, 0.18, -1.65, 0.45, -1.71, 0.45], ["c", -0.03, 0, -0.03, -0.72, -0.03, -3.75], ["l", 0, -3.75], ["l", 0.36, -0.09], ["c", 0.21, -0.06, 0.66, -0.18, 1.05, -0.27], ["z"]], w: 2.16, h: 8.04 },
      "scripts.snap": { d: [["M", 4.5, -3.39], ["c", 0.36, -0.03, 0.96, -0.03, 1.35, 0], ["c", 1.56, 0.15, 3.15, 0.9, 4.2, 2.01], ["c", 0.24, 0.27, 0.33, 0.42, 0.33, 0.6], ["c", 0, 0.27, 0.03, 0.24, -2.46, 2.22], ["c", -1.29, 1.02, -2.4, 1.86, -2.49, 1.92], ["c", -0.18, 0.09, -0.3, 0.09, -0.48, 0], ["c", -0.09, -0.06, -1.2, -0.9, -2.49, -1.92], ["c", -2.49, -1.98, -2.46, -1.95, -2.46, -2.22], ["c", 0, -0.18, 0.09, -0.33, 0.33, -0.6], ["c", 1.05, -1.08, 2.64, -1.86, 4.17, -2.01], ["z"], ["m", 1.29, 1.17], ["c", -1.47, -0.15, -2.97, 0.3, -4.14, 1.2], ["l", -0.18, 0.15], ["l", 0.06, 0.09], ["c", 0.15, 0.12, 3.63, 2.85, 3.66, 2.85], ["c", 0.03, 0, 3.51, -2.73, 3.66, -2.85], ["l", 0.06, -0.09], ["l", -0.18, -0.15], ["c", -0.84, -0.66, -1.89, -1.08, -2.94, -1.2], ["z"]], w: 10.38, h: 6.84 }
    };
    glyphs["noteheads.slash.whole"] = { d: [["M", 5, -5], ["l", 1, 1], ["l", -5, 5], ["l", -1, -1], ["z"], ["m", 4, 6], ["l", -5, -5], ["l", 2, -2], ["l", 5, 5], ["z"], ["m", 0, -2], ["l", 1, 1], ["l", -5, 5], ["l", -1, -1], ["z"], ["m", -4, 6], ["l", -5, -5], ["l", 2, -2], ["l", 5, 5], ["z"]], w: 10.81, h: 15.63 };
    glyphs["noteheads.slash.quarter"] = { d: [["M", 9, -6], ["l", 0, 4], ["l", -9, 9], ["l", 0, -4], ["z"]], w: 9, h: 9 };
    glyphs["noteheads.harmonic.quarter"] = { d: [["M", 3.63, -4.02], ["c", 0.09, -0.06, 0.18, -0.09, 0.24, -0.03], ["c", 0.03, 0.03, 0.87, 0.93, 1.83, 2.01], ["c", 1.5, 1.65, 1.8, 1.98, 1.8, 2.04], ["c", 0, 0.06, -0.3, 0.39, -1.8, 2.04], ["c", -0.96, 1.08, -1.8, 1.98, -1.83, 2.01], ["c", -0.06, 0.06, -0.15, 0.03, -0.24, -0.03], ["c", -0.12, -0.09, -3.54, -3.84, -3.6, -3.93], ["c", -0.03, -0.03, -0.03, -0.09, -0.03, -0.15], ["c", 0.03, -0.06, 3.45, -3.84, 3.63, -3.96], ["z"]], w: 7.5, h: 8.165 };
    glyphs["noteheads.triangle.quarter"] = { d: [["M", 0, 4], ["l", 9, 0], ["l", -4.5, -9], ["z"]], w: 9, h: 9 };
    var pathClone = function(pathArray) {
      var res = [];
      for (var i2 = 0, ii = pathArray.length; i2 < ii; i2++) {
        res[i2] = [];
        for (var j = 0, jj = pathArray[i2].length; j < jj; j++) {
          res[i2][j] = pathArray[i2][j];
        }
      }
      return res;
    };
    var pathScale = function(pathArray, kx, ky) {
      for (var i2 = 0, ii = pathArray.length; i2 < ii; i2++) {
        var p = pathArray[i2];
        var j, jj;
        for (j = 1, jj = p.length; j < jj; j++) {
          p[j] *= j % 2 ? kx : ky;
        }
      }
    };
    var Glyphs = {
      printSymbol: function(x, y, symb, paper, attrs) {
        if (!glyphs[symb]) return null;
        var pathArray = pathClone(glyphs[symb].d);
        pathArray[0][1] += x;
        pathArray[0][2] += y;
        var path = "";
        for (var i2 = 0; i2 < pathArray.length; i2++)
          path += pathArray[i2].join(" ");
        attrs.path = path;
        return paper.path(attrs);
      },
      getPathForSymbol: function(x, y, symb, scalex, scaley) {
        scalex = scalex || 1;
        scaley = scaley || 1;
        if (!glyphs[symb]) return null;
        var pathArray = pathClone(glyphs[symb].d);
        if (scalex !== 1 || scaley !== 1) pathScale(pathArray, scalex, scaley);
        pathArray[0][1] += x;
        pathArray[0][2] += y;
        return pathArray;
      },
      getSymbolWidth: function(symbol) {
        if (glyphs[symbol]) return glyphs[symbol].w;
        return 0;
      },
      symbolHeightInPitches: function(symbol) {
        var height = glyphs[symbol] ? glyphs[symbol].h : 0;
        return height / spacing.STEP;
      },
      getSymbolAlign: function(symbol) {
        if (symbol.substring(0, 7) === "scripts" && symbol !== "scripts.roll") {
          return "center";
        }
        return "left";
      },
      getYCorr: function(symbol) {
        switch (symbol) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
          case "+":
            return -2;
          case "timesig.common":
          case "timesig.cut":
            return 0;
          case "flags.d32nd":
            return -1;
          case "flags.d64th":
            return -2;
          case "flags.u32nd":
            return 1;
          case "flags.u64th":
            return 3;
          case "rests.whole":
            return 1;
          case "rests.half":
            return -1;
          case "rests.8th":
            return -1;
          case "rests.quarter":
            return -1;
          case "rests.16th":
            return -1;
          case "rests.32nd":
            return -1;
          case "rests.64th":
            return -1;
          case "f":
          case "m":
          case "p":
          case "s":
          case "z":
            return -4;
          case "scripts.trill":
          case "scripts.upbow":
          case "scripts.downbow":
            return -2;
          case "scripts.ufermata":
          case "scripts.wedge":
          case "scripts.roll":
          case "scripts.shortphrase":
          case "scripts.longphrase":
            return -1;
          case "scripts.dfermata":
            return 1;
          default:
            return 0;
        }
      },
      setSymbol: function(name, path) {
        glyphs[name] = path;
      }
    };
    module.exports = Glyphs;
  }
});

// node_modules/abcjs/src/write/creation/create-clef.js
var require_create_clef = __commonJS({
  "node_modules/abcjs/src/write/creation/create-clef.js"(exports, module) {
    var AbsoluteElement = require_absolute_element();
    var glyphs = require_glyphs();
    var RelativeElement = require_relative_element();
    var createClef = function(elem, tuneNumber) {
      var clef;
      var octave = 0;
      elem.el_type = "clef";
      var abselem = new AbsoluteElement(elem, 0, 10, "staff-extra clef", tuneNumber);
      abselem.isClef = true;
      switch (elem.type) {
        case "treble":
          clef = "clefs.G";
          break;
        case "tenor":
          clef = "clefs.C";
          break;
        case "alto":
          clef = "clefs.C";
          break;
        case "bass":
          clef = "clefs.F";
          break;
        case "treble+8":
          clef = "clefs.G";
          octave = 1;
          break;
        case "tenor+8":
          clef = "clefs.C";
          octave = 1;
          break;
        case "bass+8":
          clef = "clefs.F";
          octave = 1;
          break;
        case "alto+8":
          clef = "clefs.C";
          octave = 1;
          break;
        case "treble-8":
          clef = "clefs.G";
          octave = -1;
          break;
        case "tenor-8":
          clef = "clefs.C";
          octave = -1;
          break;
        case "bass-8":
          clef = "clefs.F";
          octave = -1;
          break;
        case "alto-8":
          clef = "clefs.C";
          octave = -1;
          break;
        case "none":
          return null;
        case "perc":
          clef = "clefs.perc";
          break;
        default:
          abselem.addFixed(new RelativeElement("clef=" + elem.type, 0, 0, void 0, { type: "debug" }));
      }
      var dx = 5;
      if (clef) {
        var height = glyphs.symbolHeightInPitches(clef);
        var ofs = clefOffsets(clef);
        abselem.addRight(new RelativeElement(clef, dx, glyphs.getSymbolWidth(clef), elem.clefPos, { top: height + elem.clefPos + ofs, bottom: elem.clefPos + ofs }));
        if (octave !== 0) {
          var scale = 2 / 3;
          var adjustspacing = (glyphs.getSymbolWidth(clef) - glyphs.getSymbolWidth("8") * scale) / 2;
          var pitch = octave > 0 ? abselem.top + 3 : abselem.bottom - 1;
          var top = octave > 0 ? abselem.top + 3 : abselem.bottom - 3;
          var bottom = top - 2;
          if (elem.type === "bass-8") {
            pitch = 3;
            adjustspacing = 0;
          }
          abselem.addRight(new RelativeElement("8", dx + adjustspacing, glyphs.getSymbolWidth("8") * scale, pitch, {
            scalex: scale,
            scaley: scale,
            top,
            bottom
          }));
        }
      }
      return abselem;
    };
    function clefOffsets(clef) {
      switch (clef) {
        case "clefs.G":
          return -5;
        case "clefs.C":
          return -4;
        case "clefs.F":
          return -4;
        case "clefs.perc":
          return -2;
        default:
          return 0;
      }
    }
    module.exports = createClef;
  }
});

// node_modules/abcjs/src/write/creation/create-key-signature.js
var require_create_key_signature = __commonJS({
  "node_modules/abcjs/src/write/creation/create-key-signature.js"(exports, module) {
    var AbsoluteElement = require_absolute_element();
    var glyphs = require_glyphs();
    var RelativeElement = require_relative_element();
    var createKeySignature = function(elem, tuneNumber) {
      elem.el_type = "keySignature";
      if (!elem.accidentals || elem.accidentals.length === 0)
        return null;
      var abselem = new AbsoluteElement(elem, 0, 10, "staff-extra key-signature", tuneNumber);
      abselem.isKeySig = true;
      var dx = 0;
      elem.accidentals.forEach(function(acc) {
        var symbol;
        var fudge = 0;
        switch (acc.acc) {
          case "sharp":
            symbol = "accidentals.sharp";
            fudge = -3;
            break;
          case "natural":
            symbol = "accidentals.nat";
            break;
          case "flat":
            symbol = "accidentals.flat";
            fudge = -1.2;
            break;
          case "quartersharp":
            symbol = "accidentals.halfsharp";
            fudge = -2.5;
            break;
          case "quarterflat":
            symbol = "accidentals.halfflat";
            fudge = -1.2;
            break;
          default:
            symbol = "accidentals.flat";
        }
        abselem.addRight(new RelativeElement(symbol, dx, glyphs.getSymbolWidth(symbol), acc.verticalPos, { thickness: glyphs.symbolHeightInPitches(symbol), top: acc.verticalPos + glyphs.symbolHeightInPitches(symbol) + fudge, bottom: acc.verticalPos + fudge }));
        dx += glyphs.getSymbolWidth(symbol) + 2;
      }, this);
      return abselem;
    };
    module.exports = createKeySignature;
  }
});

// node_modules/abcjs/src/write/creation/create-note-head.js
var require_create_note_head = __commonJS({
  "node_modules/abcjs/src/write/creation/create-note-head.js"(exports, module) {
    var glyphs = require_glyphs();
    var RelativeElement = require_relative_element();
    var createNoteHead = function(abselem, c, pitchelem, options) {
      if (!options) options = {};
      var dir = options.dir !== void 0 ? options.dir : null;
      var headx = options.headx !== void 0 ? options.headx : 0;
      var extrax = options.extrax !== void 0 ? options.extrax : 0;
      var flag = options.flag !== void 0 ? options.flag : null;
      var dot = options.dot !== void 0 ? options.dot : 0;
      var dotshiftx = options.dotshiftx !== void 0 ? options.dotshiftx : 0;
      var scale = options.scale !== void 0 ? options.scale : 1;
      var accidentalSlot = options.accidentalSlot !== void 0 ? options.accidentalSlot : [];
      var shouldExtendStem = options.shouldExtendStem !== void 0 ? options.shouldExtendStem : false;
      var printAccidentals = options.printAccidentals !== void 0 ? options.printAccidentals : true;
      var pitch = pitchelem.verticalPos;
      var notehead;
      var accidentalshiftx = 0;
      var newDotShiftX = 0;
      var extraLeft = 0;
      if (c === void 0)
        abselem.addFixed(new RelativeElement("pitch is undefined", 0, 0, 0, { type: "debug" }));
      else if (c === "") {
        notehead = new RelativeElement(null, 0, 0, pitch);
      } else {
        var shiftheadx = headx;
        if (pitchelem.printer_shift) {
          var adjust = pitchelem.printer_shift === "same" ? 1 : 0;
          shiftheadx = dir === "down" ? -glyphs.getSymbolWidth(c) * scale + adjust : glyphs.getSymbolWidth(c) * scale - adjust;
        }
        var opts = { scalex: scale, scaley: scale, thickness: glyphs.symbolHeightInPitches(c) * scale, name: pitchelem.name };
        notehead = new RelativeElement(c, shiftheadx, glyphs.getSymbolWidth(c) * scale, pitch, opts);
        notehead.stemDir = dir;
        if (flag) {
          var pos = pitch + (dir === "down" ? -7 : 7) * scale;
          if (shouldExtendStem) {
            if (dir === "down" && pos > 6)
              pos = 6;
            if (dir === "up" && pos < 6)
              pos = 6;
          }
          var xdelta = dir === "down" ? headx : headx + notehead.w - 0.6;
          abselem.addRight(new RelativeElement(flag, xdelta, glyphs.getSymbolWidth(flag) * scale, pos, { scalex: scale, scaley: scale }));
        }
        newDotShiftX = notehead.w + dotshiftx - 2 + 5 * dot;
        for (; dot > 0; dot--) {
          var dotadjusty = 1 - Math.abs(pitch) % 2;
          abselem.addRight(new RelativeElement("dots.dot", notehead.w + dotshiftx - 2 + 5 * dot, glyphs.getSymbolWidth("dots.dot"), pitch + dotadjusty));
        }
      }
      if (notehead)
        notehead.highestVert = pitchelem.highestVert;
      if (printAccidentals && pitchelem.accidental) {
        var symb;
        switch (pitchelem.accidental) {
          case "quartersharp":
            symb = "accidentals.halfsharp";
            break;
          case "dblsharp":
            symb = "accidentals.dblsharp";
            break;
          case "sharp":
            symb = "accidentals.sharp";
            break;
          case "quarterflat":
            symb = "accidentals.halfflat";
            break;
          case "flat":
            symb = "accidentals.flat";
            break;
          case "dblflat":
            symb = "accidentals.dblflat";
            break;
          case "natural":
            symb = "accidentals.nat";
        }
        var accSlotFound = false;
        var accPlace = extrax;
        for (var j = 0; j < accidentalSlot.length; j++) {
          if (pitch - accidentalSlot[j][0] >= 6) {
            accidentalSlot[j][0] = pitch;
            accPlace = accidentalSlot[j][1];
            accSlotFound = true;
            break;
          }
        }
        if (accSlotFound === false) {
          accPlace -= glyphs.getSymbolWidth(symb) * scale + 2;
          accidentalSlot.push([pitch, accPlace]);
          accidentalshiftx = glyphs.getSymbolWidth(symb) * scale + 2;
        }
        var h = glyphs.symbolHeightInPitches(symb);
        abselem.addExtra(new RelativeElement(symb, accPlace, glyphs.getSymbolWidth(symb), pitch, { scalex: scale, scaley: scale, top: pitch + h / 2, bottom: pitch - h / 2 }));
        extraLeft = glyphs.getSymbolWidth(symb) / 2;
      }
      return { notehead, accidentalshiftx, dotshiftx: newDotShiftX, extraLeft };
    };
    module.exports = createNoteHead;
  }
});

// node_modules/abcjs/src/write/creation/create-time-signature.js
var require_create_time_signature = __commonJS({
  "node_modules/abcjs/src/write/creation/create-time-signature.js"(exports, module) {
    var AbsoluteElement = require_absolute_element();
    var glyphs = require_glyphs();
    var RelativeElement = require_relative_element();
    var createTimeSignature = function(elem, tuneNumber) {
      elem.el_type = "timeSignature";
      var abselem = new AbsoluteElement(elem, 0, 10, "staff-extra time-signature", tuneNumber);
      if (elem.type === "specified") {
        var x = 0;
        for (var i2 = 0; i2 < elem.value.length; i2++) {
          if (i2 !== 0) {
            abselem.addRight(new RelativeElement("+", x + 1, glyphs.getSymbolWidth("+"), 6, { thickness: glyphs.symbolHeightInPitches("+") }));
            x += glyphs.getSymbolWidth("+") + 2;
          }
          if (elem.value[i2].den) {
            var numWidth = 0;
            for (var i22 = 0; i22 < elem.value[i2].num.length; i22++)
              numWidth += glyphs.getSymbolWidth(elem.value[i2].num[i22]);
            var denWidth = 0;
            for (i22 = 0; i22 < elem.value[i2].num.length; i22++)
              denWidth += glyphs.getSymbolWidth(elem.value[i2].den[i22]);
            var maxWidth = Math.max(numWidth, denWidth);
            abselem.addRight(new RelativeElement(elem.value[i2].num, x + (maxWidth - numWidth) / 2, numWidth, 8, { thickness: glyphs.symbolHeightInPitches(elem.value[i2].num[0]) }));
            abselem.addRight(new RelativeElement(elem.value[i2].den, x + (maxWidth - denWidth) / 2, denWidth, 4, { thickness: glyphs.symbolHeightInPitches(elem.value[i2].den[0]) }));
            x += maxWidth;
          } else {
            var thisWidth = 0;
            for (var i3 = 0; i3 < elem.value[i2].num.length; i3++)
              thisWidth += glyphs.getSymbolWidth(elem.value[i2].num[i3]);
            abselem.addRight(new RelativeElement(elem.value[i2].num, x, thisWidth, 6, { thickness: glyphs.symbolHeightInPitches(elem.value[i2].num[0]) }));
            x += thisWidth;
          }
        }
      } else if (elem.type === "common_time") {
        abselem.addRight(new RelativeElement("timesig.common", 0, glyphs.getSymbolWidth("timesig.common"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.common") }));
      } else if (elem.type === "cut_time") {
        abselem.addRight(new RelativeElement("timesig.cut", 0, glyphs.getSymbolWidth("timesig.cut"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.cut") }));
      } else if (elem.type === "tempus_imperfectum") {
        abselem.addRight(new RelativeElement("timesig.imperfectum", 0, glyphs.getSymbolWidth("timesig.imperfectum"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.imperfectum") }));
      } else if (elem.type === "tempus_imperfectum_prolatio") {
        abselem.addRight(new RelativeElement("timesig.imperfectum2", 0, glyphs.getSymbolWidth("timesig.imperfectum2"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.imperfectum2") }));
      } else if (elem.type === "tempus_perfectum") {
        abselem.addRight(new RelativeElement("timesig.perfectum", 0, glyphs.getSymbolWidth("timesig.perfectum"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.perfectum") }));
      } else if (elem.type === "tempus_perfectum_prolatio") {
        abselem.addRight(new RelativeElement("timesig.perfectum2", 0, glyphs.getSymbolWidth("timesig.perfectum2"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.perfectum2") }));
      } else {
        console.log("time signature:", elem);
      }
      return abselem;
    };
    module.exports = createTimeSignature;
  }
});

// node_modules/abcjs/src/write/creation/elements/dynamic-decoration.js
var require_dynamic_decoration = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/dynamic-decoration.js"(exports, module) {
    var DynamicDecoration = function DynamicDecoration2(anchor, dec, position) {
      this.type = "DynamicDecoration";
      this.anchor = anchor;
      this.dec = dec;
      if (position === "below")
        this.volumeHeightBelow = 6;
      else
        this.volumeHeightAbove = 6;
      this.pitch = void 0;
    };
    module.exports = DynamicDecoration;
  }
});

// node_modules/abcjs/src/write/creation/elements/crescendo-element.js
var require_crescendo_element = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/crescendo-element.js"(exports, module) {
    var CrescendoElem = function CrescendoElem2(anchor1, anchor2, dir, positioning) {
      this.type = "CrescendoElem";
      this.anchor1 = anchor1;
      this.anchor2 = anchor2;
      this.dir = dir;
      if (positioning === "above")
        this.dynamicHeightAbove = 6;
      else
        this.dynamicHeightBelow = 6;
      this.pitch = void 0;
    };
    module.exports = CrescendoElem;
  }
});

// node_modules/abcjs/src/write/creation/elements/glissando-element.js
var require_glissando_element = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/glissando-element.js"(exports, module) {
    var GlissandoElem = function GlissandoElem2(anchor1, anchor2) {
      this.type = "GlissandoElem";
      this.anchor1 = anchor1;
      this.anchor2 = anchor2;
    };
    module.exports = GlissandoElem;
  }
});

// node_modules/abcjs/src/write/creation/elements/tie-element.js
var require_tie_element = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/tie-element.js"(exports, module) {
    var TieElem = function TieElem2(options) {
      this.type = "TieElem";
      this.anchor1 = options.anchor1;
      this.anchor2 = options.anchor2;
      if (options.isGrace)
        this.isGrace = true;
      if (options.fixedY)
        this.fixedY = true;
      if (options.stemDir)
        this.stemDir = options.stemDir;
      if (options.voiceNumber !== void 0)
        this.voiceNumber = options.voiceNumber;
      if (options.style !== void 0)
        this.dotted = true;
      this.internalNotes = [];
    };
    TieElem.prototype.addInternalNote = function(note) {
      this.internalNotes.push(note);
    };
    TieElem.prototype.setEndAnchor = function(anchor2) {
      this.anchor2 = anchor2;
      if (this.anchor1) {
        this.top = Math.max(this.anchor1.pitch, this.anchor2.pitch) + 4;
        this.bottom = Math.min(this.anchor1.pitch, this.anchor2.pitch) - 4;
      } else {
        this.top = this.anchor2.pitch + 4;
        this.bottom = this.anchor2.pitch - 4;
      }
    };
    TieElem.prototype.setStartX = function(startLimitElem) {
      this.startLimitX = startLimitElem;
    };
    TieElem.prototype.setEndX = function(endLimitElem) {
      this.endLimitX = endLimitElem;
    };
    TieElem.prototype.setHint = function() {
      this.hint = true;
    };
    TieElem.prototype.calcTieDirection = function() {
      if (this.isGrace)
        this.above = false;
      else if (this.voiceNumber === 0)
        this.above = true;
      else if (this.voiceNumber > 0)
        this.above = false;
      else {
        var referencePitch;
        if (this.anchor1)
          referencePitch = this.anchor1.pitch;
        else if (this.anchor2)
          referencePitch = this.anchor2.pitch;
        else
          referencePitch = 14;
        if (this.anchor1 && this.anchor1.stemDir === "down" && (this.anchor2 && this.anchor2.stemDir === "down"))
          this.above = true;
        else if (this.anchor1 && this.anchor1.stemDir === "up" && (this.anchor2 && this.anchor2.stemDir === "up"))
          this.above = false;
        else if (this.anchor1 && this.anchor2)
          this.above = referencePitch >= 6;
        else if (this.anchor1)
          this.above = this.anchor1.stemDir === "down";
        else if (this.anchor2)
          this.above = this.anchor2.stemDir === "down";
        else
          this.above = referencePitch >= 6;
      }
    };
    TieElem.prototype.calcSlurDirection = function() {
      if (this.isGrace)
        this.above = false;
      else if (this.voiceNumber === 0)
        this.above = true;
      else if (this.voiceNumber > 0)
        this.above = false;
      else {
        var hasDownStem = false;
        if (this.anchor1 && this.anchor1.stemDir === "down")
          hasDownStem = true;
        if (this.anchor2 && this.anchor2.stemDir === "down")
          hasDownStem = true;
        for (var i2 = 0; i2 < this.internalNotes.length; i2++) {
          var n = this.internalNotes[i2];
          if (n.stemDir === "down")
            hasDownStem = true;
        }
        this.above = hasDownStem;
      }
    };
    TieElem.prototype.calcX = function(lineStartX, lineEndX) {
      if (this.anchor1) {
        this.startX = this.anchor1.x;
        if (this.anchor1.scalex < 1)
          this.startX -= 3;
      } else if (this.startLimitX)
        this.startX = this.startLimitX.x + this.startLimitX.w;
      else {
        if (this.anchor2)
          this.startX = this.anchor2.x - 20;
        else
          this.startX = lineStartX;
      }
      if (!this.anchor1 && this.dotted)
        this.startX -= 3;
      if (this.anchor2)
        this.endX = this.anchor2.x;
      else if (this.endLimitX)
        this.endX = this.endLimitX.x;
      else
        this.endX = lineEndX;
    };
    TieElem.prototype.calcTieY = function() {
      if (this.anchor1)
        this.startY = this.anchor1.pitch;
      else if (this.anchor2)
        this.startY = this.anchor2.pitch;
      else
        this.startY = this.above ? 14 : 0;
      if (this.anchor2)
        this.endY = this.anchor2.pitch;
      else if (this.anchor1)
        this.endY = this.anchor1.pitch;
      else
        this.endY = this.above ? 14 : 0;
    };
    TieElem.prototype.calcSlurY = function() {
      if (this.anchor1 && this.anchor2) {
        if (this.above && this.anchor1.stemDir === "up" && !this.fixedY) {
          this.startY = (this.anchor1.highestVert + this.anchor1.pitch) / 2;
          this.startX += this.anchor1.w / 2;
        } else
          this.startY = this.anchor1.pitch;
        var beamInterferes = this.anchor2.parent.beam && this.anchor2.parent.beam.stemsUp && this.anchor2.parent.beam.elems[0] !== this.anchor2.parent;
        var midPoint = (this.anchor2.highestVert + this.anchor2.pitch) / 2;
        if (this.above && this.anchor2.stemDir === "up" && !this.fixedY && !beamInterferes && midPoint < this.startY) {
          this.endY = midPoint;
          this.endX += Math.round(this.anchor2.w / 2);
        } else
          this.endY = this.above && beamInterferes ? this.anchor2.highestVert : this.anchor2.pitch;
        if (this.anchor1.scalex === 1) {
          var hasBeam1 = !!this.anchor1.parent.beam;
          var hasBeam2 = !!this.anchor2.parent.beam;
          if (hasBeam1) {
            var isLastInBeam = this.anchor1.parent === this.anchor1.parent.beam.elems[this.anchor1.parent.beam.elems.length - 1];
            if (!isLastInBeam) {
              if (this.above)
                this.startY = this.anchor1.parent.fixed.t;
              else
                this.startY = this.anchor1.parent.fixed.b;
            }
          }
          if (hasBeam2) {
            var isFirstInBeam = this.anchor2.parent === this.anchor2.parent.beam.elems[0];
            if (!isFirstInBeam) {
              if (this.above)
                this.endY = this.anchor2.parent.fixed.t;
              else
                this.endY = this.anchor2.parent.fixed.b;
            }
          }
        }
      } else if (this.anchor1) {
        this.startY = this.endY = this.anchor1.pitch;
      } else if (this.anchor2) {
        this.startY = this.endY = this.anchor2.pitch;
      } else {
        this.startY = this.above ? 14 : 0;
        this.endY = this.above ? 14 : 0;
      }
    };
    TieElem.prototype.avoidCollisionAbove = function() {
      if (this.above) {
        var maxInnerHeight = -50;
        for (var i2 = 0; i2 < this.internalNotes.length; i2++) {
          if (this.internalNotes[i2].highestVert > maxInnerHeight)
            maxInnerHeight = this.internalNotes[i2].highestVert;
        }
        if (maxInnerHeight > this.startY && maxInnerHeight > this.endY)
          this.startY = this.endY = maxInnerHeight - 1;
      }
    };
    TieElem.prototype.getYBounds = function() {
      var lineStartX = 10;
      var lineEndX = 1e3;
      if (this.isTie) {
        this.calcTieDirection();
        this.calcX(lineStartX, lineEndX);
        this.calcTieY();
      } else {
        this.calcSlurDirection();
        this.calcX(lineStartX, lineEndX);
        this.calcSlurY();
      }
      var top;
      var bottom;
      if (this.above) {
        bottom = Math.min(this.startY, this.endY);
        top = bottom + 3;
      } else {
        top = Math.min(this.startY, this.endY);
        bottom = top - 3;
      }
      return [top, bottom];
    };
    module.exports = TieElem;
  }
});

// node_modules/abcjs/src/write/creation/decoration.js
var require_decoration = __commonJS({
  "node_modules/abcjs/src/write/creation/decoration.js"(exports, module) {
    var DynamicDecoration = require_dynamic_decoration();
    var CrescendoElem = require_crescendo_element();
    var GlissandoElem = require_glissando_element();
    var glyphs = require_glyphs();
    var RelativeElement = require_relative_element();
    var TieElem = require_tie_element();
    var Decoration = function Decoration2() {
      this.startDiminuendoX = void 0;
      this.startCrescendoX = void 0;
      this.minTop = 12;
      this.minBottom = 0;
    };
    var closeDecoration = function(voice, decoration, pitch, width, abselem, roomtaken, dir, minPitch, accentAbove) {
      var yPos;
      for (var i2 = 0; i2 < decoration.length; i2++) {
        if (decoration[i2] === "staccato" || decoration[i2] === "tenuto" || decoration[i2] === "accent" && !accentAbove) {
          var symbol = "scripts." + decoration[i2];
          if (decoration[i2] === "accent") symbol = "scripts.sforzato";
          if (yPos === void 0)
            yPos = dir === "down" ? pitch + 2 : minPitch - 2;
          else
            yPos = dir === "down" ? yPos + 2 : yPos - 2;
          if (decoration[i2] === "accent") {
            if (dir === "up") yPos--;
            else yPos++;
          } else {
            switch (yPos) {
              case 2:
              case 4:
              case 6:
              case 8:
              case 10:
                if (dir === "up") yPos--;
                else yPos++;
                break;
            }
          }
          if (pitch > 9) yPos++;
          var deltaX = width / 2;
          if (glyphs.getSymbolAlign(symbol) !== "center") {
            deltaX -= glyphs.getSymbolWidth(symbol) / 2;
          }
          abselem.addFixedX(new RelativeElement(symbol, deltaX, glyphs.getSymbolWidth(symbol), yPos));
        }
        if (decoration[i2] === "slide" && abselem.heads[0]) {
          var yPos2 = abselem.heads[0].pitch;
          yPos2 -= 2;
          var blank1 = new RelativeElement("", -roomtaken - 15, 0, yPos2 - 1);
          var blank2 = new RelativeElement("", -roomtaken - 5, 0, yPos2 + 1);
          abselem.addFixedX(blank1);
          abselem.addFixedX(blank2);
          voice.addOther(new TieElem({ anchor1: blank1, anchor2: blank2, fixedY: true }));
        }
      }
      if (yPos === void 0)
        yPos = pitch;
      return { above: yPos, below: abselem.bottom };
    };
    var volumeDecoration = function(voice, decoration, abselem, positioning) {
      for (var i2 = 0; i2 < decoration.length; i2++) {
        switch (decoration[i2]) {
          case "p":
          case "mp":
          case "pp":
          case "ppp":
          case "pppp":
          case "f":
          case "ff":
          case "fff":
          case "ffff":
          case "sfz":
          case "mf":
            var elem = new DynamicDecoration(abselem, decoration[i2], positioning);
            voice.addOther(elem);
        }
      }
    };
    var compoundDecoration = function(decoration, pitch, width, abselem, dir) {
      function highestPitch() {
        if (abselem.heads.length === 0)
          return 10;
        var pitch2 = abselem.heads[0].pitch;
        for (var i3 = 1; i3 < abselem.heads.length; i3++)
          pitch2 = Math.max(pitch2, abselem.heads[i3].pitch);
        return pitch2;
      }
      function lowestPitch() {
        if (abselem.heads.length === 0)
          return 2;
        var pitch2 = abselem.heads[0].pitch;
        for (var i3 = 1; i3 < abselem.heads.length; i3++)
          pitch2 = Math.min(pitch2, abselem.heads[i3].pitch);
        return pitch2;
      }
      function compoundDecoration2(symbol, count) {
        var placement = dir === "down" ? lowestPitch() + 1 : highestPitch() + 9;
        if (dir !== "down" && count === 1)
          placement--;
        var deltaX = width / 2;
        deltaX += dir === "down" ? -5 : 3;
        for (var i3 = 0; i3 < count; i3++) {
          placement -= 1;
          abselem.addFixedX(new RelativeElement(symbol, deltaX, glyphs.getSymbolWidth(symbol), placement));
        }
      }
      for (var i2 = 0; i2 < decoration.length; i2++) {
        switch (decoration[i2]) {
          case "/":
            compoundDecoration2("flags.ugrace", 1);
            break;
          case "//":
            compoundDecoration2("flags.ugrace", 2);
            break;
          case "///":
            compoundDecoration2("flags.ugrace", 3);
            break;
          case "////":
            compoundDecoration2("flags.ugrace", 4);
            break;
        }
      }
    };
    var stackedDecoration = function(decoration, width, abselem, yPos, positioning, minTop, minBottom, accentAbove) {
      function incrementPlacement(placement, height) {
        if (placement === "above")
          yPos.above += height;
        else
          yPos.below -= height;
      }
      function getPlacement(placement) {
        var y;
        if (placement === "above") {
          y = yPos.above;
          if (y < minTop)
            y = minTop;
        } else {
          y = yPos.below;
          if (y > minBottom)
            y = minBottom;
        }
        return y;
      }
      function textDecoration(text, placement, anchor) {
        var y = getPlacement(placement);
        var textFudge = 2;
        var textHeight = 5;
        abselem.addFixedX(new RelativeElement(text, width / 2, 0, y + textFudge, { type: "decoration", klass: "ornament", thickness: 3, anchor }));
        incrementPlacement(placement, textHeight);
      }
      function symbolDecoration(symbol, placement) {
        var deltaX = width / 2;
        if (glyphs.getSymbolAlign(symbol) !== "center") {
          deltaX -= glyphs.getSymbolWidth(symbol) / 2;
        }
        var height = glyphs.symbolHeightInPitches(symbol) + 1;
        var y = getPlacement(placement);
        y = placement === "above" ? y + height / 2 : y - height / 2;
        abselem.addFixedX(new RelativeElement(symbol, deltaX, glyphs.getSymbolWidth(symbol), y, { klass: "ornament", thickness: glyphs.symbolHeightInPitches(symbol), position: placement }));
        incrementPlacement(placement, height);
      }
      var symbolList = {
        "+": "scripts.stopped",
        "open": "scripts.open",
        "snap": "scripts.snap",
        "wedge": "scripts.wedge",
        "thumb": "scripts.thumb",
        "shortphrase": "scripts.shortphrase",
        "mediumphrase": "scripts.mediumphrase",
        "longphrase": "scripts.longphrase",
        "trill": "scripts.trill",
        "roll": "scripts.roll",
        "irishroll": "scripts.roll",
        "marcato": "scripts.umarcato",
        "dmarcato": "scripts.dmarcato",
        "umarcato": "scripts.umarcato",
        "turn": "scripts.turn",
        "uppermordent": "scripts.prall",
        "pralltriller": "scripts.prall",
        "mordent": "scripts.mordent",
        "lowermordent": "scripts.mordent",
        "downbow": "scripts.downbow",
        "upbow": "scripts.upbow",
        "fermata": "scripts.ufermata",
        "invertedfermata": "scripts.dfermata",
        "breath": ",",
        "coda": "scripts.coda",
        "segno": "scripts.segno"
      };
      var hasOne = false;
      for (var i2 = 0; i2 < decoration.length; i2++) {
        switch (decoration[i2]) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "D.C.":
          case "D.S.":
            textDecoration(decoration[i2], positioning, "middle");
            hasOne = true;
            break;
          case "D.C.alcoda":
            textDecoration("D.C. al coda", positioning, "end");
            hasOne = true;
            break;
          case "D.C.alfine":
            textDecoration("D.C. al fine", positioning, "end");
            hasOne = true;
            break;
          case "D.S.alcoda":
            textDecoration("D.S. al coda", positioning, "end");
            hasOne = true;
            break;
          case "D.S.alfine":
            textDecoration("D.S. al fine", positioning, "end");
            hasOne = true;
            break;
          case "fine":
            textDecoration("FINE", positioning, "middle");
            hasOne = true;
            break;
          case "+":
          case "open":
          case "snap":
          case "wedge":
          case "thumb":
          case "shortphrase":
          case "mediumphrase":
          case "longphrase":
          case "trill":
          case "roll":
          case "irishroll":
          case "marcato":
          case "dmarcato":
          case "turn":
          case "uppermordent":
          case "pralltriller":
          case "mordent":
          case "lowermordent":
          case "downbow":
          case "upbow":
          case "fermata":
          case "breath":
          case "umarcato":
          case "coda":
          case "segno":
            symbolDecoration(symbolList[decoration[i2]], positioning);
            hasOne = true;
            break;
          case "invertedfermata":
            symbolDecoration(symbolList[decoration[i2]], "below");
            hasOne = true;
            break;
          case "mark":
            abselem.klass = "mark";
            break;
          case "accent":
            if (accentAbove) {
              symbolDecoration("scripts.sforzato", positioning);
              hasOne = true;
            }
            break;
        }
      }
      return hasOne;
    };
    function leftDecoration(decoration, abselem, roomtaken) {
      for (var i2 = 0; i2 < decoration.length; i2++) {
        switch (decoration[i2]) {
          case "arpeggio":
            for (var j = abselem.abcelem.minpitch - 1; j <= abselem.abcelem.maxpitch; j += 2) {
              abselem.addExtra(
                new RelativeElement(
                  "scripts.arpeggio",
                  -glyphs.getSymbolWidth("scripts.arpeggio") * 2 - roomtaken,
                  0,
                  j + 2,
                  { klass: "ornament", thickness: glyphs.symbolHeightInPitches("scripts.arpeggio") }
                )
              );
            }
            break;
        }
      }
    }
    Decoration.prototype.dynamicDecoration = function(voice, decoration, abselem, positioning) {
      var diminuendo;
      var crescendo;
      var glissando;
      for (var i2 = 0; i2 < decoration.length; i2++) {
        switch (decoration[i2]) {
          case "diminuendo(":
            this.startDiminuendoX = abselem;
            diminuendo = void 0;
            break;
          case "diminuendo)":
            diminuendo = { start: this.startDiminuendoX, stop: abselem };
            this.startDiminuendoX = void 0;
            break;
          case "crescendo(":
            this.startCrescendoX = abselem;
            crescendo = void 0;
            break;
          case "crescendo)":
            crescendo = { start: this.startCrescendoX, stop: abselem };
            this.startCrescendoX = void 0;
            break;
          case "~(":
          case "glissando(":
            this.startGlissandoX = abselem;
            glissando = void 0;
            break;
          case "~)":
          case "glissando)":
            glissando = { start: this.startGlissandoX, stop: abselem };
            this.startGlissandoX = void 0;
            break;
        }
      }
      if (diminuendo) {
        voice.addOther(new CrescendoElem(diminuendo.start, diminuendo.stop, ">", positioning));
      }
      if (crescendo) {
        voice.addOther(new CrescendoElem(crescendo.start, crescendo.stop, "<", positioning));
      }
      if (glissando) {
        voice.addOther(new GlissandoElem(glissando.start, glissando.stop));
      }
    };
    Decoration.prototype.createDecoration = function(voice, decoration, pitch, width, abselem, roomtaken, dir, minPitch, positioning, hasVocals, accentAbove) {
      if (!positioning)
        positioning = { ornamentPosition: "above", volumePosition: hasVocals ? "above" : "below", dynamicPosition: hasVocals ? "above" : "below" };
      volumeDecoration(voice, decoration, abselem, positioning.volumePosition);
      this.dynamicDecoration(voice, decoration, abselem, positioning.dynamicPosition);
      compoundDecoration(decoration, pitch, width, abselem, dir);
      var yPos = closeDecoration(voice, decoration, pitch, width, abselem, roomtaken, dir, minPitch, accentAbove);
      yPos.above = Math.max(yPos.above, this.minTop);
      yPos.below = Math.min(yPos.below, minPitch);
      var hasOne = stackedDecoration(decoration, width, abselem, yPos, positioning.ornamentPosition, this.minTop, minPitch, accentAbove);
      leftDecoration(decoration, abselem, roomtaken);
    };
    module.exports = Decoration;
  }
});

// node_modules/abcjs/src/write/creation/elements/ending-element.js
var require_ending_element = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/ending-element.js"(exports, module) {
    var EndingElem = function EndingElem2(text, anchor1, anchor2) {
      this.type = "EndingElem";
      this.text = text;
      this.anchor1 = anchor1;
      this.anchor2 = anchor2;
      this.endingHeightAbove = 5;
      this.pitch = void 0;
    };
    module.exports = EndingElem;
  }
});

// node_modules/abcjs/src/write/creation/calc-height.js
var require_calc_height = __commonJS({
  "node_modules/abcjs/src/write/creation/calc-height.js"(exports, module) {
    var calcHeight = function(staffGroup) {
      var height = 0;
      for (var i2 = 0; i2 < staffGroup.voices.length; i2++) {
        var staff = staffGroup.voices[i2].staff;
        if (!staffGroup.voices[i2].duplicate) {
          height += staff.top;
          height += -staff.bottom;
        }
      }
      return height;
    };
    module.exports = calcHeight;
  }
});

// node_modules/abcjs/src/write/creation/elements/staff-group-element.js
var require_staff_group_element = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/staff-group-element.js"(exports, module) {
    var calcHeight = require_calc_height();
    var StaffGroupElement = function(getTextSize) {
      this.getTextSize = getTextSize;
      this.voices = [];
      this.staffs = [];
      this.brace = void 0;
      this.bracket = void 0;
    };
    StaffGroupElement.prototype.setLimit = function(member, voice) {
      if (!voice.specialY[member]) return;
      if (!voice.staff.specialY[member])
        voice.staff.specialY[member] = voice.specialY[member];
      else
        voice.staff.specialY[member] = Math.max(voice.staff.specialY[member], voice.specialY[member]);
    };
    StaffGroupElement.prototype.addVoice = function(voice, staffnumber, stafflines) {
      var voiceNum = this.voices.length;
      this.voices[voiceNum] = voice;
      if (this.staffs[staffnumber])
        this.staffs[staffnumber].voices.push(voiceNum);
      else {
        this.staffs[this.staffs.length] = {
          top: 10,
          bottom: 2,
          lines: stafflines,
          voices: [voiceNum],
          specialY: {
            tempoHeightAbove: 0,
            partHeightAbove: 0,
            volumeHeightAbove: 0,
            dynamicHeightAbove: 0,
            endingHeightAbove: 0,
            chordHeightAbove: 0,
            lyricHeightAbove: 0,
            lyricHeightBelow: 0,
            chordHeightBelow: 0,
            volumeHeightBelow: 0,
            dynamicHeightBelow: 0
          }
        };
      }
      voice.staff = this.staffs[staffnumber];
    };
    StaffGroupElement.prototype.setHeight = function() {
      this.height = calcHeight(this);
    };
    StaffGroupElement.prototype.setWidth = function(width) {
      this.w = width;
      for (var i2 = 0; i2 < this.voices.length; i2++) {
        this.voices[i2].setWidth(width);
      }
    };
    StaffGroupElement.prototype.setStaffLimits = function(voice) {
      voice.staff.top = Math.max(voice.staff.top, voice.top);
      voice.staff.bottom = Math.min(voice.staff.bottom, voice.bottom);
      this.setLimit("tempoHeightAbove", voice);
      this.setLimit("partHeightAbove", voice);
      this.setLimit("volumeHeightAbove", voice);
      this.setLimit("dynamicHeightAbove", voice);
      this.setLimit("endingHeightAbove", voice);
      this.setLimit("chordHeightAbove", voice);
      this.setLimit("lyricHeightAbove", voice);
      this.setLimit("lyricHeightBelow", voice);
      this.setLimit("chordHeightBelow", voice);
      this.setLimit("volumeHeightBelow", voice);
      this.setLimit("dynamicHeightBelow", voice);
    };
    module.exports = StaffGroupElement;
  }
});

// node_modules/abcjs/src/write/creation/elements/tempo-element.js
var require_tempo_element = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/tempo-element.js"(exports, module) {
    var AbsoluteElement = require_absolute_element();
    var RelativeElement = require_relative_element();
    var TempoElement = function TempoElement2(tempo, tuneNumber, createNoteHead) {
      this.type = "TempoElement";
      this.tempo = tempo;
      this.tempo.type = "tempo";
      this.tuneNumber = tuneNumber;
      this.totalHeightInPitches = 6;
      this.tempoHeightAbove = this.totalHeightInPitches;
      this.pitch = void 0;
      if (this.tempo.duration && !this.tempo.suppressBpm) {
        this.note = this.createNote(createNoteHead, tempo, tuneNumber);
      }
    };
    TempoElement.prototype.setX = function(x) {
      this.x = x;
    };
    TempoElement.prototype.createNote = function(createNoteHead, tempo, tuneNumber) {
      var temposcale = 0.75;
      var duration = tempo.duration[0];
      var absElem = new AbsoluteElement(tempo, duration, 1, "tempo", tuneNumber);
      var dot;
      var flag;
      var note;
      if (duration <= 1 / 32) {
        note = "noteheads.quarter";
        flag = "flags.u32nd";
        dot = 0;
      } else if (duration <= 1 / 16) {
        note = "noteheads.quarter";
        flag = "flags.u16th";
        dot = 0;
      } else if (duration <= 3 / 32) {
        note = "noteheads.quarter";
        flag = "flags.u16nd";
        dot = 1;
      } else if (duration <= 1 / 8) {
        note = "noteheads.quarter";
        flag = "flags.u8th";
        dot = 0;
      } else if (duration <= 3 / 16) {
        note = "noteheads.quarter";
        flag = "flags.u8th";
        dot = 1;
      } else if (duration <= 1 / 4) {
        note = "noteheads.quarter";
        dot = 0;
      } else if (duration <= 3 / 8) {
        note = "noteheads.quarter";
        dot = 1;
      } else if (duration <= 1 / 2) {
        note = "noteheads.half";
        dot = 0;
      } else if (duration <= 3 / 4) {
        note = "noteheads.half";
        dot = 1;
      } else if (duration <= 1) {
        note = "noteheads.whole";
        dot = 0;
      } else if (duration <= 1.5) {
        note = "noteheads.whole";
        dot = 1;
      } else if (duration <= 2) {
        note = "noteheads.dbl";
        dot = 0;
      } else {
        note = "noteheads.dbl";
        dot = 1;
      }
      var ret = createNoteHead(
        absElem,
        note,
        { verticalPos: 0 },
        // This is just temporary: we'll offset the vertical positioning when we get the actual vertical spot.
        { dir: "up", flag, dot, scale: temposcale }
      );
      var tempoNote = ret.notehead;
      absElem.addHead(tempoNote);
      var stem;
      if (note !== "noteheads.whole" && note !== "noteheads.dbl") {
        var p1 = 1 / 3 * temposcale;
        var p2 = 5 * temposcale;
        var dx = tempoNote.dx + tempoNote.w;
        var width = -0.6;
        stem = new RelativeElement(null, dx, 0, p1, { "type": "stem", "pitch2": p2, linewidth: width });
        absElem.addRight(stem);
      }
      return absElem;
    };
    module.exports = TempoElement;
  }
});

// node_modules/abcjs/src/write/creation/elements/triplet-element.js
var require_triplet_element = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/triplet-element.js"(exports, module) {
    var TripletElem = function TripletElem2(number, anchor1, options) {
      this.type = "TripletElem";
      this.anchor1 = anchor1;
      this.number = number;
      this.durationClass = ("d" + Math.round(anchor1.parent.durationClass * 1e3) / 1e3).replace(/\./, "-");
      this.middleElems = [];
      this.flatBeams = options.flatBeams;
    };
    TripletElem.prototype.isClosed = function() {
      return !!this.anchor2;
    };
    TripletElem.prototype.middleNote = function(elem) {
      this.middleElems.push(elem);
    };
    TripletElem.prototype.setCloseAnchor = function(anchor2) {
      this.anchor2 = anchor2;
      if (!this.anchor1.parent.beam || this.anchor1.stemDir === "up")
        this.endingHeightAbove = 4;
    };
    module.exports = TripletElem;
  }
});

// node_modules/abcjs/src/write/creation/translate-chord.js
var require_translate_chord = __commonJS({
  "node_modules/abcjs/src/write/creation/translate-chord.js"(exports, module) {
    function germanNote(note) {
      switch (note) {
        case "B#":
          return "H#";
        case "B♯":
          return "H♯";
        case "B":
          return "H";
        case "Bb":
          return "B";
        case "B♭":
          return "B";
      }
      return note;
    }
    function translateChord(chordString, jazzchords, germanAlphabet) {
      var lines = chordString.split("\n");
      for (let i2 = 0; i2 < lines.length; i2++) {
        let chord = lines[i2];
        let reg = chord.match(/^([ABCDEFG][♯♭]?)?([^\/]+)?(\/([ABCDEFG][#b♯♭]?))?/);
        if (!reg) {
          continue;
        }
        let baseChord = reg[1] || "";
        let modifier = reg[2] || "";
        let bassNote = reg[4] || "";
        if (germanAlphabet) {
          baseChord = germanNote(baseChord);
          bassNote = germanNote(bassNote);
        }
        const marker = jazzchords ? "" : "";
        const bass = bassNote ? "/" + bassNote : "";
        lines[i2] = [baseChord, modifier, bass].join(marker);
      }
      return lines.join("\n");
    }
    module.exports = translateChord;
  }
});

// node_modules/abcjs/src/write/creation/add-chord.js
var require_add_chord = __commonJS({
  "node_modules/abcjs/src/write/creation/add-chord.js"(exports, module) {
    var RelativeElement = require_relative_element();
    var spacing = require_spacing();
    var translateChord = require_translate_chord();
    var addChord = function(getTextSize, abselem, elem, roomTaken, roomTakenRight, noteheadWidth, jazzchords, germanAlphabet) {
      for (var i2 = 0; i2 < elem.chord.length; i2++) {
        var pos = elem.chord[i2].position;
        var rel_position = elem.chord[i2].rel_position;
        var isAnnotation = pos === "left" || pos === "right" || pos === "below" || pos === "above" || !!rel_position;
        var font;
        var klass;
        if (isAnnotation) {
          font = "annotationfont";
          klass = "abcjs-annotation";
        } else {
          font = "gchordfont";
          klass = "abcjs-chord";
        }
        var attr = getTextSize.attr(font, klass);
        var name = elem.chord[i2].name;
        var ret;
        if (typeof name === "string") {
          ret = chordString(name, pos, rel_position, isAnnotation, font, klass, attr, getTextSize, abselem, elem, roomTaken, roomTakenRight, noteheadWidth, jazzchords, germanAlphabet);
          roomTaken = ret.roomTaken;
          roomTakenRight = ret.roomTakenRight;
        } else {
          for (var j = 0; j < name.length; j++) {
            ret = chordString(name[j].text, pos, rel_position, isAnnotation, font, klass, attr, getTextSize, abselem, elem, roomTaken, roomTakenRight, noteheadWidth, jazzchords, germanAlphabet);
            roomTaken = ret.roomTaken;
            roomTakenRight = ret.roomTakenRight;
          }
        }
      }
      return { roomTaken, roomTakenRight };
    };
    function chordString(chordString2, pos, rel_position, isAnnotation, font, klass, attr, getTextSize, abselem, elem, roomTaken, roomTakenRight, noteheadWidth, jazzchords, germanAlphabet) {
      var chords = chordString2.split("\n");
      for (var j = chords.length - 1; j >= 0; j--) {
        var chord = chords[j];
        var x = 0;
        var y;
        if (!isAnnotation)
          chord = translateChord(chord, jazzchords, germanAlphabet);
        var dim = getTextSize.calc(chord, font, klass);
        var chordWidth = dim.width;
        var chordHeight = dim.height / spacing.STEP;
        switch (pos) {
          case "left":
            roomTaken += chordWidth + 7;
            x = -roomTaken;
            y = elem.averagepitch;
            abselem.addExtra(new RelativeElement(chord, x, chordWidth + 4, y, {
              type: "text",
              height: chordHeight,
              dim: attr,
              position: "left"
            }));
            break;
          case "right":
            roomTakenRight += 4;
            x = roomTakenRight;
            y = elem.averagepitch;
            abselem.addRight(new RelativeElement(chord, x, chordWidth + 4, y, {
              type: "text",
              height: chordHeight,
              dim: attr,
              position: "right"
            }));
            break;
          case "below":
            abselem.addRight(new RelativeElement(chord, 0, 0, void 0, {
              type: "text",
              position: "below",
              height: chordHeight,
              dim: attr,
              realWidth: chordWidth
            }));
            break;
          case "above":
            abselem.addRight(new RelativeElement(chord, 0, 0, void 0, {
              type: "text",
              position: "above",
              height: chordHeight,
              dim: attr,
              realWidth: chordWidth
            }));
            break;
          default:
            if (rel_position) {
              var relPositionY = rel_position.y + 3 * spacing.STEP;
              abselem.addRight(new RelativeElement(chord, x + rel_position.x, 0, elem.minpitch + relPositionY / spacing.STEP, {
                position: "relative",
                type: "text",
                height: chordHeight,
                dim: attr
              }));
            } else {
              var pos2 = "above";
              if (elem.positioning && elem.positioning.chordPosition)
                pos2 = elem.positioning.chordPosition;
              if (pos2 !== "hidden") {
                abselem.addCentered(new RelativeElement(chord, noteheadWidth / 2, chordWidth, void 0, {
                  type: "chord",
                  position: pos2,
                  height: chordHeight,
                  dim: attr,
                  realWidth: chordWidth
                }));
              }
            }
        }
      }
      return { roomTaken, roomTakenRight };
    }
    module.exports = addChord;
  }
});

// node_modules/abcjs/src/write/creation/abstract-engraver.js
var require_abstract_engraver = __commonJS({
  "node_modules/abcjs/src/write/creation/abstract-engraver.js"(exports, module) {
    var AbsoluteElement = require_absolute_element();
    var BeamElem = require_beam_element();
    var BraceElem = require_brace_element();
    var createClef = require_create_clef();
    var createKeySignature = require_create_key_signature();
    var createNoteHead = require_create_note_head();
    var createTimeSignature = require_create_time_signature();
    var Decoration = require_decoration();
    var EndingElem = require_ending_element();
    var glyphs = require_glyphs();
    var RelativeElement = require_relative_element();
    var spacing = require_spacing();
    var StaffGroupElement = require_staff_group_element();
    var TempoElement = require_tempo_element();
    var TieElem = require_tie_element();
    var TripletElem = require_triplet_element();
    var VoiceElement = require_voice_element();
    var addChord = require_add_chord();
    var pitchesToPerc = require_pitches_to_perc();
    var parseCommon = require_abc_common();
    var getDuration = function(elem) {
      var d = 0;
      if (elem.duration) {
        d = elem.duration;
      }
      return d;
    };
    var hint = false;
    var chartable = {
      rest: { 0: "rests.whole", 1: "rests.half", 2: "rests.quarter", 3: "rests.8th", 4: "rests.16th", 5: "rests.32nd", 6: "rests.64th", 7: "rests.128th", "multi": "rests.multimeasure" },
      note: { "-1": "noteheads.dbl", 0: "noteheads.whole", 1: "noteheads.half", 2: "noteheads.quarter", 3: "noteheads.quarter", 4: "noteheads.quarter", 5: "noteheads.quarter", 6: "noteheads.quarter", 7: "noteheads.quarter", "nostem": "noteheads.quarter" },
      rhythm: { "-1": "noteheads.slash.whole", 0: "noteheads.slash.whole", 1: "noteheads.slash.whole", 2: "noteheads.slash.quarter", 3: "noteheads.slash.quarter", 4: "noteheads.slash.quarter", 5: "noteheads.slash.quarter", 6: "noteheads.slash.quarter", 7: "noteheads.slash.quarter", nostem: "noteheads.slash.nostem" },
      x: { "-1": "noteheads.indeterminate", 0: "noteheads.indeterminate", 1: "noteheads.indeterminate", 2: "noteheads.indeterminate", 3: "noteheads.indeterminate", 4: "noteheads.indeterminate", 5: "noteheads.indeterminate", 6: "noteheads.indeterminate", 7: "noteheads.indeterminate", nostem: "noteheads.indeterminate" },
      harmonic: { "-1": "noteheads.harmonic.quarter", 0: "noteheads.harmonic.quarter", 1: "noteheads.harmonic.quarter", 2: "noteheads.harmonic.quarter", 3: "noteheads.harmonic.quarter", 4: "noteheads.harmonic.quarter", 5: "noteheads.harmonic.quarter", 6: "noteheads.harmonic.quarter", 7: "noteheads.harmonic.quarter", nostem: "noteheads.harmonic.quarter" },
      triangle: { "-1": "noteheads.triangle.quarter", 0: "noteheads.triangle.quarter", 1: "noteheads.triangle.quarter", 2: "noteheads.triangle.quarter", 3: "noteheads.triangle.quarter", 4: "noteheads.triangle.quarter", 5: "noteheads.triangle.quarter", 6: "noteheads.triangle.quarter", 7: "noteheads.triangle.quarter", nostem: "noteheads.triangle.quarter" },
      uflags: { 3: "flags.u8th", 4: "flags.u16th", 5: "flags.u32nd", 6: "flags.u64th" },
      dflags: { 3: "flags.d8th", 4: "flags.d16th", 5: "flags.d32nd", 6: "flags.d64th" }
    };
    var AbstractEngraver = function(getTextSize, tuneNumber, options) {
      this.decoration = new Decoration();
      this.getTextSize = getTextSize;
      this.tuneNumber = tuneNumber;
      this.isBagpipes = options.bagpipes;
      this.flatBeams = options.flatbeams;
      this.graceSlurs = options.graceSlurs;
      this.percmap = options.percmap;
      this.initialClef = options.initialClef;
      this.jazzchords = !!options.jazzchords;
      this.accentAbove = !!options.accentAbove;
      this.germanAlphabet = !!options.germanAlphabet;
      this.reset();
    };
    AbstractEngraver.prototype.reset = function() {
      this.slurs = {};
      this.ties = [];
      this.voiceScale = 1;
      this.voiceColor = void 0;
      this.slursbyvoice = {};
      this.tiesbyvoice = {};
      this.endingsbyvoice = {};
      this.scaleByVoice = {};
      this.colorByVoice = {};
      this.tripletmultiplier = 1;
      this.abcline = void 0;
      this.accidentalSlot = void 0;
      this.accidentalshiftx = void 0;
      this.dotshiftx = void 0;
      this.hasVocals = false;
      this.minY = void 0;
      this.partstartelem = void 0;
      this.startlimitelem = void 0;
      this.stemdir = void 0;
    };
    AbstractEngraver.prototype.setStemHeight = function(heightInPixels) {
      this.stemHeight = Math.round(heightInPixels * 10 / spacing.STEP) / 10;
    };
    AbstractEngraver.prototype.getCurrentVoiceId = function(s2, v2) {
      return "s" + s2 + "v" + v2;
    };
    AbstractEngraver.prototype.pushCrossLineElems = function(s2, v2) {
      this.slursbyvoice[this.getCurrentVoiceId(s2, v2)] = this.slurs;
      this.tiesbyvoice[this.getCurrentVoiceId(s2, v2)] = this.ties;
      this.endingsbyvoice[this.getCurrentVoiceId(s2, v2)] = this.partstartelem;
      this.scaleByVoice[this.getCurrentVoiceId(s2, v2)] = this.voiceScale;
      if (this.voiceColor)
        this.colorByVoice[this.getCurrentVoiceId(s2, v2)] = this.voiceColor;
    };
    AbstractEngraver.prototype.popCrossLineElems = function(s2, v2) {
      this.slurs = this.slursbyvoice[this.getCurrentVoiceId(s2, v2)] || {};
      this.ties = this.tiesbyvoice[this.getCurrentVoiceId(s2, v2)] || [];
      this.partstartelem = this.endingsbyvoice[this.getCurrentVoiceId(s2, v2)];
      this.voiceScale = this.scaleByVoice[this.getCurrentVoiceId(s2, v2)];
      if (this.voiceScale === void 0) this.voiceScale = 1;
      this.voiceColor = this.colorByVoice[this.getCurrentVoiceId(s2, v2)];
    };
    AbstractEngraver.prototype.containsLyrics = function(staves) {
      for (var i2 = 0; i2 < staves.length; i2++) {
        for (var j = 0; j < staves[i2].voices.length; j++) {
          for (var k = 0; k < staves[i2].voices[j].length; k++) {
            var el = staves[i2].voices[j][k];
            if (el.lyric) {
              if (!el.positioning || el.positioning.vocalPosition === "below")
                this.hasVocals = true;
              return;
            }
          }
        }
      }
    };
    AbstractEngraver.prototype.createABCLine = function(staffs, tempo, l) {
      this.minY = 2;
      this.containsLyrics(staffs);
      var staffgroup = new StaffGroupElement(this.getTextSize);
      this.tempoSet = false;
      for (var s2 = 0; s2 < staffs.length; s2++) {
        if (hint)
          this.restoreState();
        hint = false;
        this.createABCStaff(staffgroup, staffs[s2], tempo, s2, l);
      }
      return staffgroup;
    };
    AbstractEngraver.prototype.createABCStaff = function(staffgroup, abcstaff, tempo, s2, l) {
      staffgroup.getTextSize.updateFonts(abcstaff);
      for (var v2 = 0; v2 < abcstaff.voices.length; v2++) {
        var voice = new VoiceElement(v2, abcstaff.voices.length);
        if (v2 === 0) {
          voice.barfrom = abcstaff.connectBarLines === "start" || abcstaff.connectBarLines === "continue";
          voice.barto = abcstaff.connectBarLines === "continue" || abcstaff.connectBarLines === "end";
        } else {
          voice.duplicate = true;
        }
        if (abcstaff.title && abcstaff.title[v2]) {
          voice.header = abcstaff.title[v2].replace(/\\n/g, "\n");
          voice.headerPosition = 6 + staffgroup.getTextSize.baselineToCenter(voice.header, "voicefont", "staff-extra voice-name", v2, abcstaff.voices.length) / spacing.STEP;
        }
        if (abcstaff.clef && abcstaff.clef.type === "perc")
          voice.isPercussion = true;
        var clef = (!this.initialClef || l === 0) && createClef(abcstaff.clef, this.tuneNumber);
        if (clef) {
          if (v2 === 0 && abcstaff.barNumber) {
            this.addMeasureNumber(abcstaff.barNumber, clef);
          }
          voice.addChild(clef);
          this.startlimitelem = clef;
        }
        var keySig = createKeySignature(abcstaff.key, this.tuneNumber);
        if (keySig) {
          voice.addChild(keySig);
          this.startlimitelem = keySig;
        }
        if (abcstaff.meter) {
          if (abcstaff.meter.type === "specified") {
            this.measureLength = abcstaff.meter.value[0].num / abcstaff.meter.value[0].den;
          } else
            this.measureLength = 1;
          var ts = createTimeSignature(abcstaff.meter, this.tuneNumber);
          voice.addChild(ts);
          this.startlimitelem = ts;
        }
        if (voice.duplicate)
          voice.children = [];
        var staffLines = abcstaff.clef.stafflines || abcstaff.clef.stafflines === 0 ? abcstaff.clef.stafflines : 5;
        staffgroup.addVoice(voice, s2, staffLines);
        var isSingleLineStaff = staffLines === 1;
        this.createABCVoice(abcstaff.voices[v2], tempo, s2, v2, isSingleLineStaff, voice);
        staffgroup.setStaffLimits(voice);
        if (v2 === 0) {
          if (abcstaff.brace === "start" || !staffgroup.brace && abcstaff.brace) {
            if (!staffgroup.brace)
              staffgroup.brace = [];
            staffgroup.brace.push(new BraceElem(voice, "brace"));
          } else if (abcstaff.brace === "end" && staffgroup.brace) {
            staffgroup.brace[staffgroup.brace.length - 1].setBottomStaff(voice);
          } else if (abcstaff.brace === "continue" && staffgroup.brace) {
            staffgroup.brace[staffgroup.brace.length - 1].continuing(voice);
          }
          if (abcstaff.bracket === "start" || !staffgroup.bracket && abcstaff.bracket) {
            if (!staffgroup.bracket)
              staffgroup.bracket = [];
            staffgroup.bracket.push(new BraceElem(voice, "bracket"));
          } else if (abcstaff.bracket === "end" && staffgroup.bracket) {
            staffgroup.bracket[staffgroup.bracket.length - 1].setBottomStaff(voice);
          } else if (abcstaff.bracket === "continue" && staffgroup.bracket) {
            staffgroup.bracket[staffgroup.bracket.length - 1].continuing(voice);
          }
        }
      }
    };
    function getBeamGroup(abcline, pos) {
      var elem = abcline[pos];
      if (elem.el_type !== "note" || !elem.startBeam || elem.endBeam)
        return { count: 1, elem };
      var group = [];
      while (pos < abcline.length && abcline[pos].el_type === "note") {
        group.push(abcline[pos]);
        if (abcline[pos].endBeam)
          break;
        pos++;
      }
      return { count: group.length, elem: group };
    }
    AbstractEngraver.prototype.createABCVoice = function(abcline, tempo, s2, v2, isSingleLineStaff, voice) {
      this.popCrossLineElems(s2, v2);
      this.stemdir = this.isBagpipes ? "down" : null;
      this.abcline = abcline;
      if (this.partstartelem) {
        this.partstartelem = new EndingElem("", null, null);
        voice.addOther(this.partstartelem);
      }
      var voiceNumber = voice.voicetotal < 2 ? -1 : voice.voicenumber;
      for (var slur in this.slurs) {
        if (this.slurs.hasOwnProperty(slur)) {
          this.slurs[slur] = new TieElem({ force: this.slurs[slur].force, voiceNumber, stemDir: this.slurs[slur].stemDir, style: this.slurs[slur].dotted });
          if (hint) this.slurs[slur].setHint();
          voice.addOther(this.slurs[slur]);
        }
      }
      for (var i2 = 0; i2 < this.ties.length; i2++) {
        this.ties[i2] = new TieElem({ force: this.ties[i2].force, stemDir: this.ties[i2].stemDir, voiceNumber, style: this.ties[i2].dotted });
        if (hint) this.ties[i2].setHint();
        voice.addOther(this.ties[i2]);
      }
      for (var j = 0; j < this.abcline.length; j++) {
        setAveragePitch(this.abcline[j]);
        this.minY = Math.min(this.abcline[j].minpitch, this.minY);
      }
      var isFirstStaff = s2 === 0;
      var pos = 0;
      while (pos < this.abcline.length) {
        var ret = getBeamGroup(this.abcline, pos);
        var abselems = this.createABCElement(isFirstStaff, isSingleLineStaff, voice, ret.elem);
        if (abselems) {
          for (i2 = 0; i2 < abselems.length; i2++) {
            if (!this.tempoSet && tempo && !tempo.suppress) {
              this.tempoSet = true;
              var tempoElement = new AbsoluteElement(tempo, 0, 0, "tempo", this.tuneNumber, {});
              tempoElement.addFixedX(new TempoElement(tempo, this.tuneNumber, createNoteHead));
              voice.addChild(tempoElement);
            }
            voice.addChild(abselems[i2]);
          }
        }
        pos += ret.count;
      }
      this.pushCrossLineElems(s2, v2);
    };
    AbstractEngraver.prototype.saveState = function() {
      this.tiesSave = parseCommon.cloneArray(this.ties);
      this.slursSave = parseCommon.cloneHashOfHash(this.slurs);
      this.slursbyvoiceSave = parseCommon.cloneHashOfHash(this.slursbyvoice);
      this.tiesbyvoiceSave = parseCommon.cloneHashOfArrayOfHash(this.tiesbyvoice);
    };
    AbstractEngraver.prototype.restoreState = function() {
      this.ties = parseCommon.cloneArray(this.tiesSave);
      this.slurs = parseCommon.cloneHashOfHash(this.slursSave);
      this.slursbyvoice = parseCommon.cloneHashOfHash(this.slursbyvoiceSave);
      this.tiesbyvoice = parseCommon.cloneHashOfArrayOfHash(this.tiesbyvoiceSave);
    };
    AbstractEngraver.prototype.createABCElement = function(isFirstStaff, isSingleLineStaff, voice, elem) {
      var elemset = [];
      switch (elem.el_type) {
        case void 0:
          elemset = this.createBeam(isSingleLineStaff, voice, elem);
          break;
        case "note":
          elemset[0] = this.createNote(elem, false, isSingleLineStaff, voice);
          if (this.triplet && this.triplet.isClosed()) {
            voice.addOther(this.triplet);
            this.triplet = null;
            this.tripletmultiplier = 1;
          }
          break;
        case "bar":
          elemset[0] = this.createBarLine(voice, elem, isFirstStaff);
          if (voice.duplicate && elemset.length > 0) elemset[0].invisible = true;
          break;
        case "meter":
          elemset[0] = createTimeSignature(elem, this.tuneNumber);
          this.startlimitelem = elemset[0];
          if (voice.duplicate && elemset.length > 0) elemset[0].invisible = true;
          break;
        case "clef":
          elemset[0] = createClef(elem, this.tuneNumber);
          if (!elemset[0]) return null;
          if (voice.duplicate && elemset.length > 0) elemset[0].invisible = true;
          break;
        case "key":
          var absKey = createKeySignature(elem, this.tuneNumber);
          if (absKey) {
            elemset[0] = absKey;
            this.startlimitelem = elemset[0];
          }
          if (voice.duplicate && elemset.length > 0) elemset[0].invisible = true;
          break;
        case "stem":
          this.stemdir = elem.direction === "auto" ? void 0 : elem.direction;
          break;
        case "part":
          var abselem = new AbsoluteElement(elem, 0, 0, "part", this.tuneNumber);
          var dim = this.getTextSize.calc(elem.title, "partsfont", "part");
          abselem.addFixedX(new RelativeElement(elem.title, 0, 0, void 0, { type: "part", height: dim.height / spacing.STEP }));
          elemset[0] = abselem;
          break;
        case "tempo":
          var abselem3 = new AbsoluteElement(elem, 0, 0, "tempo", this.tuneNumber);
          abselem3.addFixedX(new TempoElement(elem, this.tuneNumber, createNoteHead));
          elemset[0] = abselem3;
          break;
        case "style":
          if (elem.head === "normal")
            delete this.style;
          else
            this.style = elem.head;
          break;
        case "hint":
          hint = true;
          this.saveState();
          break;
        case "midi":
          break;
        case "scale":
          this.voiceScale = elem.size;
          break;
        case "color":
          this.voiceColor = elem.color;
          voice.color = this.voiceColor;
          break;
        default:
          var abselem2 = new AbsoluteElement(elem, 0, 0, "unsupported", this.tuneNumber);
          abselem2.addFixed(new RelativeElement("element type " + elem.el_type, 0, 0, void 0, { type: "debug" }));
          elemset[0] = abselem2;
      }
      return elemset;
    };
    function setAveragePitch(elem) {
      if (elem.pitches) {
        sortPitch(elem);
        var sum = 0;
        for (var p = 0; p < elem.pitches.length; p++) {
          sum += elem.pitches[p].verticalPos;
        }
        elem.averagepitch = sum / elem.pitches.length;
        elem.minpitch = elem.pitches[0].verticalPos;
        elem.maxpitch = elem.pitches[elem.pitches.length - 1].verticalPos;
      }
    }
    AbstractEngraver.prototype.createBeam = function(isSingleLineStaff, voice, elems) {
      var abselemset = [];
      var beamelem = new BeamElem(this.stemHeight * this.voiceScale, this.stemdir, this.flatBeams, elems[0]);
      if (hint) beamelem.setHint();
      for (var i2 = 0; i2 < elems.length; i2++) {
        beamelem.runningDirection(elems[i2]);
      }
      beamelem.setStemDirection();
      var tempStemDir = this.stemdir;
      this.stemdir = beamelem.stemsUp ? "up" : "down";
      for (i2 = 0; i2 < elems.length; i2++) {
        var elem = elems[i2];
        var abselem = this.createNote(elem, true, isSingleLineStaff, voice);
        abselemset.push(abselem);
        beamelem.add(abselem);
        if (this.triplet && this.triplet.isClosed()) {
          voice.addOther(this.triplet);
          this.triplet = null;
          this.tripletmultiplier = 1;
        }
      }
      beamelem.calcDir();
      voice.addBeam(beamelem);
      this.stemdir = tempStemDir;
      return abselemset;
    };
    var sortPitch = function(elem) {
      var sorted;
      do {
        sorted = true;
        for (var p = 0; p < elem.pitches.length - 1; p++) {
          if (elem.pitches[p].pitch > elem.pitches[p + 1].pitch) {
            sorted = false;
            var tmp = elem.pitches[p];
            elem.pitches[p] = elem.pitches[p + 1];
            elem.pitches[p + 1] = tmp;
          }
        }
      } while (!sorted);
    };
    var ledgerLines = function(abselem, minPitch, maxPitch, isRest, symbolWidth, additionalLedgers, dir, dx, scale) {
      for (var i2 = maxPitch; i2 > 11; i2--) {
        if (i2 % 2 === 0 && !isRest) {
          abselem.addFixed(new RelativeElement(null, dx, (symbolWidth + 4) * scale, i2, { type: "ledger" }));
        }
      }
      for (i2 = minPitch; i2 < 1; i2++) {
        if (i2 % 2 === 0 && !isRest) {
          abselem.addFixed(new RelativeElement(null, dx, (symbolWidth + 4) * scale, i2, { type: "ledger" }));
        }
      }
      for (i2 = 0; i2 < additionalLedgers.length; i2++) {
        var ofs = symbolWidth;
        if (dir === "down") ofs = -ofs;
        abselem.addFixed(new RelativeElement(null, ofs + dx, (symbolWidth + 4) * scale, additionalLedgers[i2], { type: "ledger" }));
      }
    };
    AbstractEngraver.prototype.addGraceNotes = function(elem, voice, abselem, notehead, stemHeight, isBagpipes, roomtaken) {
      var gracescale = 3 / 5;
      var graceScaleStem = 3.5 / 5;
      stemHeight = Math.round(stemHeight * graceScaleStem);
      var gracebeam = null;
      var flag;
      if (elem.gracenotes.length > 1) {
        gracebeam = new BeamElem(stemHeight, "grace", isBagpipes);
        if (hint) gracebeam.setHint();
        gracebeam.mainNote = abselem;
      }
      var i2;
      var graceoffsets = [];
      for (i2 = elem.gracenotes.length - 1; i2 >= 0; i2--) {
        roomtaken += 10;
        graceoffsets[i2] = roomtaken;
        if (elem.gracenotes[i2].accidental) {
          roomtaken += 7;
        }
      }
      for (i2 = 0; i2 < elem.gracenotes.length; i2++) {
        var gracepitch = elem.gracenotes[i2].verticalPos;
        flag = gracebeam ? null : chartable.uflags[isBagpipes ? 5 : 3];
        var accidentalSlot = [];
        var ret = createNoteHead(
          abselem,
          "noteheads.quarter",
          elem.gracenotes[i2],
          { dir: "up", headx: -graceoffsets[i2], extrax: -graceoffsets[i2], flag, scale: gracescale * this.voiceScale, accidentalSlot }
        );
        ret.notehead.highestVert = ret.notehead.pitch + stemHeight;
        var grace = ret.notehead;
        this.addSlursAndTies(abselem, elem.gracenotes[i2], grace, voice, "up", true);
        abselem.addExtra(grace);
        if (elem.gracenotes[i2].acciaccatura) {
          var pos = elem.gracenotes[i2].verticalPos + 7 * gracescale;
          var dAcciaccatura = gracebeam ? 5 : 6;
          abselem.addRight(new RelativeElement("flags.ugrace", -graceoffsets[i2] + dAcciaccatura, 0, pos, { scalex: gracescale, scaley: gracescale }));
        }
        if (gracebeam) {
          var graceDuration = elem.gracenotes[i2].duration / 2;
          if (isBagpipes) graceDuration /= 2;
          var pseudoabselem = {
            heads: [grace],
            abcelem: { averagepitch: gracepitch, minpitch: gracepitch, maxpitch: gracepitch, duration: graceDuration }
          };
          gracebeam.add(pseudoabselem);
        } else {
          var p1 = gracepitch + 1 / 3 * gracescale;
          var p2 = gracepitch + 7 * gracescale;
          var dx = grace.dx + grace.w;
          var width = -0.6;
          abselem.addExtra(new RelativeElement(null, dx, 0, p1, { "type": "stem", "pitch2": p2, linewidth: width }));
        }
        ledgerLines(abselem, gracepitch, gracepitch, false, glyphs.getSymbolWidth("noteheads.quarter"), [], true, grace.dx - 1, 0.6);
        var isInvisibleRest = elem.rest && (elem.rest.type === "spacer" || elem.rest.type === "invisible");
        if (i2 === 0 && !isBagpipes && this.graceSlurs && !isInvisibleRest) {
          voice.addOther(new TieElem({ anchor1: grace, anchor2: notehead, isGrace: true }));
        }
      }
      if (gracebeam) {
        gracebeam.calcDir();
        voice.addBeam(gracebeam);
      }
      return roomtaken;
    };
    function addRestToAbsElement(abselem, elem, duration, dot, isMultiVoice, stemdir, isSingleLineStaff, durlog, voiceScale) {
      var c;
      var restpitch = 7;
      var noteHead;
      var roomTaken;
      var roomTakenRight;
      if (isMultiVoice) {
        if (stemdir === "down") restpitch = 3;
        if (stemdir === "up") restpitch = 11;
      }
      if (isSingleLineStaff) {
        if (duration < 0.5)
          restpitch = 7;
        else if (duration < 1)
          restpitch = 7;
        else
          restpitch = 5;
      }
      switch (elem.rest.type) {
        case "whole":
          c = chartable.rest[0];
          elem.averagepitch = restpitch;
          elem.minpitch = restpitch;
          elem.maxpitch = restpitch;
          dot = 0;
          break;
        case "rest":
          if (elem.style === "rhythm")
            c = chartable.rhythm[-durlog];
          else
            c = chartable.rest[-durlog];
          elem.averagepitch = restpitch;
          elem.minpitch = restpitch;
          elem.maxpitch = restpitch;
          break;
        case "invisible":
        case "invisible-multimeasure":
        case "spacer":
          c = "";
          elem.averagepitch = restpitch;
          elem.minpitch = restpitch;
          elem.maxpitch = restpitch;
          break;
        case "multimeasure":
          c = chartable.rest["multi"];
          elem.averagepitch = restpitch;
          elem.minpitch = restpitch;
          elem.maxpitch = restpitch;
          dot = 0;
          var mmWidth = glyphs.getSymbolWidth(c);
          abselem.addHead(new RelativeElement(c, mmWidth, mmWidth * 2, 7));
          var numMeasures = new RelativeElement("" + elem.rest.text, mmWidth, mmWidth, 16, { type: "multimeasure-text" });
          abselem.addExtra(numMeasures);
      }
      if (elem.rest.type.indexOf("multimeasure") < 0 && elem.rest.type !== "invisible") {
        var ret = createNoteHead(
          abselem,
          c,
          { verticalPos: restpitch },
          { dot, scale: voiceScale }
        );
        noteHead = ret.notehead;
        if (noteHead) {
          abselem.addHead(noteHead);
          roomTaken = ret.accidentalshiftx;
          roomTakenRight = ret.dotshiftx;
        }
      }
      return { noteHead, roomTaken, roomTakenRight };
    }
    function addIfNotExist(arr, item) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (JSON.stringify(arr[i2]) === JSON.stringify(item))
          return;
      }
      arr.push(item);
    }
    AbstractEngraver.prototype.addNoteToAbcElement = function(abselem, elem, dot, stemdir, style, zeroDuration, durlog, nostem, voice) {
      var dotshiftx = 0;
      var noteHead;
      var roomTaken = 0;
      var roomTakenRight = 0;
      var min;
      var i2;
      var additionalLedgers = [];
      var accidentalSlot = [];
      var symbolWidth = 0;
      var dir = elem.averagepitch >= 6 ? "down" : "up";
      if (stemdir) dir = stemdir;
      style = elem.style ? elem.style : style;
      if (!style || style === "normal") style = "note";
      var noteSymbol;
      if (zeroDuration)
        noteSymbol = chartable[style].nostem;
      else
        noteSymbol = chartable[style][-durlog];
      if (!noteSymbol)
        console.log("noteSymbol:", style, durlog, zeroDuration);
      var p;
      for (p = dir === "down" ? elem.pitches.length - 2 : 1; dir === "down" ? p >= 0 : p < elem.pitches.length; p = dir === "down" ? p - 1 : p + 1) {
        var prev = elem.pitches[dir === "down" ? p + 1 : p - 1];
        var curr = elem.pitches[p];
        var delta = dir === "down" ? prev.pitch - curr.pitch : curr.pitch - prev.pitch;
        if (delta <= 1 && !prev.printer_shift) {
          curr.printer_shift = delta ? "different" : "same";
          if (curr.verticalPos > 11 || curr.verticalPos < 1) {
            additionalLedgers.push(curr.verticalPos - curr.verticalPos % 2);
          }
          if (dir === "down") {
            roomTaken = glyphs.getSymbolWidth(noteSymbol) + 2;
          } else {
            dotshiftx = glyphs.getSymbolWidth(noteSymbol) + 2;
          }
        }
      }
      var pp = elem.pitches.length;
      for (p = 0; p < elem.pitches.length; p++) {
        if (!nostem) {
          var flag;
          if (dir === "down" && p !== 0 || dir === "up" && p !== pp - 1) {
            flag = null;
          } else {
            flag = chartable[dir === "down" ? "dflags" : "uflags"][-durlog];
          }
        }
        var c;
        if (elem.pitches[p].style) {
          c = chartable[elem.pitches[p].style][-durlog];
        } else if (voice.isPercussion && this.percmap) {
          c = noteSymbol;
          var percHead = this.percmap[pitchesToPerc(elem.pitches[p])];
          if (percHead && percHead.noteHead) {
            if (chartable[percHead.noteHead])
              c = chartable[percHead.noteHead][-durlog];
          }
        } else
          c = noteSymbol;
        elem.pitches[p].highestVert = elem.pitches[p].verticalPos;
        var isTopWhenStemIsDown = (stemdir === "up" || dir === "up") && p === 0;
        var isBottomWhenStemIsUp = (stemdir === "down" || dir === "down") && p === pp - 1;
        if (isTopWhenStemIsDown || isBottomWhenStemIsUp) {
          if (elem.startSlur || pp === 1) {
            elem.pitches[p].highestVert = elem.pitches[pp - 1].verticalPos;
            if (getDuration(elem) < 1 && (stemdir === "up" || dir === "up"))
              elem.pitches[p].highestVert += 6;
          }
          if (elem.startSlur) {
            if (!elem.pitches[p].startSlur) elem.pitches[p].startSlur = [];
            for (i2 = 0; i2 < elem.startSlur.length; i2++) {
              addIfNotExist(elem.pitches[p].startSlur, elem.startSlur[i2]);
            }
          }
          if (elem.endSlur) {
            elem.pitches[p].highestVert = elem.pitches[pp - 1].verticalPos;
            if (getDuration(elem) < 1 && (stemdir === "up" || dir === "up"))
              elem.pitches[p].highestVert += 6;
            if (!elem.pitches[p].endSlur) elem.pitches[p].endSlur = [];
            for (i2 = 0; i2 < elem.endSlur.length; i2++) {
              addIfNotExist(elem.pitches[p].endSlur, elem.endSlur[i2]);
            }
          }
        }
        var hasStem = !nostem && durlog <= -1;
        var ret = createNoteHead(
          abselem,
          c,
          elem.pitches[p],
          { dir, extrax: -roomTaken, flag, dot, dotshiftx, scale: this.voiceScale, accidentalSlot, shouldExtendStem: !stemdir, printAccidentals: !voice.isPercussion }
        );
        symbolWidth = Math.max(glyphs.getSymbolWidth(c), symbolWidth);
        abselem.extraw -= ret.extraLeft;
        noteHead = ret.notehead;
        if (noteHead) {
          this.addSlursAndTies(abselem, elem.pitches[p], noteHead, voice, hasStem ? dir : null, false);
          if (elem.gracenotes && elem.gracenotes.length > 0)
            noteHead.bottom = noteHead.bottom - 1;
          abselem.addHead(noteHead);
        }
        roomTaken += ret.accidentalshiftx;
        roomTakenRight = Math.max(roomTakenRight, ret.dotshiftx);
      }
      if (hasStem) {
        var stemHeight = Math.round(70 * this.voiceScale) / 10;
        var p1 = dir === "down" ? elem.minpitch - stemHeight : elem.minpitch + 1 / 3;
        if (p1 > 6 && !stemdir) p1 = 6;
        var p2 = dir === "down" ? elem.maxpitch - 1 / 3 : elem.maxpitch + stemHeight;
        if (p2 < 6 && !stemdir) p2 = 6;
        var dx = dir === "down" || abselem.heads.length === 0 ? 0 : abselem.heads[0].w;
        var width = dir === "down" ? 1 : -1;
        if (noteHead && noteHead.c === "noteheads.slash.quarter") {
          if (dir === "down")
            p2 -= 1;
          else
            p1 += 1;
        }
        if (noteHead && noteHead.c === "noteheads.triangle.quarter") {
          if (dir === "down")
            p2 -= 0.7;
          else
            p1 -= 1.2;
        }
        abselem.addRight(new RelativeElement(null, dx, 0, p1, { "type": "stem", "pitch2": p2, linewidth: width, bottom: p1 - 1 }));
        min = Math.min(p1, p2);
      }
      return { noteHead, roomTaken, roomTakenRight, min, additionalLedgers, dir, symbolWidth };
    };
    AbstractEngraver.prototype.addLyric = function(abselem, elem) {
      var lyricStr = "";
      elem.lyric.forEach(function(ly) {
        var div = ly.divider === " " ? "" : ly.divider;
        lyricStr += ly.syllable + div + "\n";
      });
      var lyricDim = this.getTextSize.calc(lyricStr, "vocalfont", "lyric");
      var position = elem.positioning ? elem.positioning.vocalPosition : "below";
      abselem.addCentered(new RelativeElement(lyricStr, 0, lyricDim.width, void 0, { type: "lyric", position, height: lyricDim.height / spacing.STEP, dim: this.getTextSize.attr("vocalfont", "lyric") }));
    };
    AbstractEngraver.prototype.createNote = function(elem, nostem, isSingleLineStaff, voice) {
      var notehead = null;
      var roomtaken = 0;
      var roomtakenright = 0;
      var symbolWidth = 0;
      var additionalLedgers = [];
      var dir;
      var duration = getDuration(elem);
      var zeroDuration = false;
      if (duration === 0) {
        zeroDuration = true;
        duration = 0.25;
        nostem = true;
      }
      var durlog = Math.floor(Math.log(duration) / Math.log(2));
      var dot = 0;
      for (var tot = Math.pow(2, durlog), inc = tot / 2; tot < duration; dot++, tot += inc, inc /= 2) ;
      if (elem.startTriplet) {
        this.tripletmultiplier = elem.tripletMultiplier;
      }
      var durationForSpacing = duration * this.tripletmultiplier;
      if (elem.rest && elem.rest.type === "multimeasure")
        durationForSpacing = 1;
      if (elem.rest && elem.rest.type === "invisible-multimeasure")
        durationForSpacing = this.measureLength * elem.rest.text;
      var absType = elem.rest ? "rest" : "note";
      var abselem = new AbsoluteElement(elem, durationForSpacing, 1, absType, this.tuneNumber, { durationClassOveride: elem.duration * this.tripletmultiplier });
      if (hint) abselem.setHint();
      if (elem.rest) {
        if (this.measureLength === duration && elem.rest.type !== "invisible" && elem.rest.type !== "spacer" && elem.rest.type.indexOf("multimeasure") < 0)
          elem.rest.type = "whole";
        var ret1 = addRestToAbsElement(abselem, elem, duration, dot, voice.voicetotal > 1, this.stemdir, isSingleLineStaff, durlog, this.voiceScale);
        notehead = ret1.noteHead;
        roomtaken = ret1.roomTaken;
        roomtakenright = ret1.roomTakenRight;
      } else {
        var ret2 = this.addNoteToAbcElement(abselem, elem, dot, this.stemdir, this.style, zeroDuration, durlog, nostem, voice);
        if (ret2.min !== void 0)
          this.minY = Math.min(ret2.min, this.minY);
        notehead = ret2.noteHead;
        roomtaken = ret2.roomTaken;
        roomtakenright = ret2.roomTakenRight;
        additionalLedgers = ret2.additionalLedgers;
        dir = ret2.dir;
        symbolWidth = ret2.symbolWidth;
      }
      if (elem.lyric !== void 0) {
        this.addLyric(abselem, elem);
      }
      if (elem.gracenotes !== void 0) {
        roomtaken += this.addGraceNotes(elem, voice, abselem, notehead, this.stemHeight * this.voiceScale, this.isBagpipes, roomtaken);
      }
      if (elem.decoration) {
        var bottom = nostem && dir !== "up" ? Math.min(-3, abselem.bottom - 6) : abselem.bottom;
        this.decoration.createDecoration(voice, elem.decoration, abselem.top, notehead ? notehead.w : 0, abselem, roomtaken, dir, bottom, elem.positioning, this.hasVocals, this.accentAbove);
      }
      if (elem.barNumber) {
        abselem.addFixed(new RelativeElement(elem.barNumber, -10, 0, 0, { type: "barNumber" }));
      }
      ledgerLines(abselem, elem.minpitch, elem.maxpitch, elem.rest, symbolWidth, additionalLedgers, dir, -2, 1);
      if (elem.chord !== void 0) {
        var ret3 = addChord(this.getTextSize, abselem, elem, roomtaken, roomtakenright, symbolWidth, this.jazzchords, this.germanAlphabet);
        roomtaken = ret3.roomTaken;
        roomtakenright = ret3.roomTakenRight;
      }
      if (elem.startTriplet) {
        this.triplet = new TripletElem(elem.startTriplet, notehead, { flatBeams: this.flatBeams });
      }
      if (elem.endTriplet && this.triplet) {
        this.triplet.setCloseAnchor(notehead);
      }
      if (this.triplet && !elem.startTriplet && !elem.endTriplet && !(elem.rest && elem.rest.type === "spacer")) {
        this.triplet.middleNote(notehead);
      }
      return abselem;
    };
    AbstractEngraver.prototype.addSlursAndTies = function(abselem, pitchelem, notehead, voice, dir, isGrace) {
      if (pitchelem.endTie) {
        if (this.ties.length > 0) {
          var found = false;
          for (var j = 0; j < this.ties.length; j++) {
            if (this.ties[j].anchor1 && this.ties[j].anchor1.pitch === notehead.pitch) {
              this.ties[j].setEndAnchor(notehead);
              voice.setRange(this.ties[j]);
              this.ties.splice(j, 1);
              found = true;
              break;
            }
          }
          if (!found) {
            this.ties[0].setEndAnchor(notehead);
            voice.setRange(this.ties[0]);
            this.ties.splice(0, 1);
          }
        }
      }
      var voiceNumber = voice.voicetotal < 2 ? -1 : voice.voicenumber;
      if (pitchelem.startTie) {
        var tie = new TieElem({ anchor1: notehead, force: this.stemdir === "down" || this.stemdir === "up", stemDir: this.stemdir, isGrace, voiceNumber, style: pitchelem.startTie.style });
        if (hint) tie.setHint();
        this.ties[this.ties.length] = tie;
        voice.addOther(tie);
        abselem.startTie = true;
      }
      var slur;
      var slurid;
      if (pitchelem.endSlur) {
        for (var i2 = 0; i2 < pitchelem.endSlur.length; i2++) {
          slurid = pitchelem.endSlur[i2];
          if (this.slurs[slurid]) {
            slur = this.slurs[slurid];
            slur.setEndAnchor(notehead);
            voice.setRange(slur);
            delete this.slurs[slurid];
          } else {
            slur = new TieElem({ anchor2: notehead, stemDir: this.stemdir, voiceNumber });
            if (hint) slur.setHint();
            voice.addOther(slur);
          }
          if (this.startlimitelem) {
            slur.setStartX(this.startlimitelem);
          }
        }
      } else if (!isGrace) {
        for (var s2 in this.slurs) {
          if (this.slurs.hasOwnProperty(s2)) {
            this.slurs[s2].addInternalNote(notehead);
          }
        }
      }
      if (pitchelem.startSlur) {
        for (i2 = 0; i2 < pitchelem.startSlur.length; i2++) {
          slurid = pitchelem.startSlur[i2].label;
          slur = new TieElem({ anchor1: notehead, stemDir: this.stemdir, voiceNumber, style: pitchelem.startSlur[i2].style });
          if (hint) slur.setHint();
          this.slurs[slurid] = slur;
          voice.addOther(slur);
        }
      }
    };
    AbstractEngraver.prototype.addMeasureNumber = function(number, abselem) {
      var measureNumDim = this.getTextSize.calc(number, "measurefont", "bar-number");
      var dx = 0;
      if (abselem.isClef)
        dx += measureNumDim.width / 2;
      var vert = measureNumDim.width > 10 && abselem.abcelem.type === "treble" ? 13.5 : 11;
      abselem.addFixed(new RelativeElement(number, dx, measureNumDim.width, vert + measureNumDim.height / spacing.STEP, { type: "barNumber", dim: this.getTextSize.attr("measurefont", "bar-number") }));
    };
    AbstractEngraver.prototype.createBarLine = function(voice, elem, isFirstStaff) {
      var abselem = new AbsoluteElement(elem, 0, 10, "bar", this.tuneNumber);
      var anchor = null;
      var dx = 0;
      if (elem.barNumber) {
        this.addMeasureNumber(elem.barNumber, abselem);
      }
      var firstdots = elem.type === "bar_right_repeat" || elem.type === "bar_dbl_repeat";
      var firstthin = elem.type !== "bar_left_repeat" && elem.type !== "bar_thick_thin" && elem.type !== "bar_invisible";
      var thick = elem.type === "bar_right_repeat" || elem.type === "bar_dbl_repeat" || elem.type === "bar_left_repeat" || elem.type === "bar_thin_thick" || elem.type === "bar_thick_thin";
      var secondthin = elem.type === "bar_left_repeat" || elem.type === "bar_thick_thin" || elem.type === "bar_thin_thin" || elem.type === "bar_dbl_repeat";
      var seconddots = elem.type === "bar_left_repeat" || elem.type === "bar_dbl_repeat";
      if (firstdots || seconddots) {
        for (var slur in this.slurs) {
          if (this.slurs.hasOwnProperty(slur)) {
            this.slurs[slur].setEndX(abselem);
          }
        }
        this.startlimitelem = abselem;
      }
      if (firstdots) {
        abselem.addRight(new RelativeElement("dots.dot", dx, 1, 7));
        abselem.addRight(new RelativeElement("dots.dot", dx, 1, 5));
        dx += 6;
      }
      if (firstthin) {
        anchor = new RelativeElement(null, dx, 1, 2, { "type": "bar", "pitch2": 10, linewidth: 0.6 });
        abselem.addRight(anchor);
      }
      if (elem.type === "bar_invisible") {
        anchor = new RelativeElement(null, dx, 1, 2, { "type": "none", "pitch2": 10, linewidth: 0.6 });
        abselem.addRight(anchor);
      }
      if (elem.decoration) {
        this.decoration.createDecoration(voice, elem.decoration, 12, thick ? 3 : 1, abselem, 0, "down", 2, elem.positioning, this.hasVocals, this.accentAbove);
      }
      if (thick) {
        dx += 4;
        anchor = new RelativeElement(null, dx, 4, 2, { "type": "bar", "pitch2": 10, linewidth: 4 });
        abselem.addRight(anchor);
        dx += 5;
      }
      if (this.partstartelem && elem.endEnding) {
        this.partstartelem.anchor2 = anchor;
        this.partstartelem = null;
      }
      if (secondthin) {
        dx += 3;
        anchor = new RelativeElement(null, dx, 1, 2, { "type": "bar", "pitch2": 10, linewidth: 0.6 });
        abselem.addRight(anchor);
      }
      if (seconddots) {
        dx += 3;
        abselem.addRight(new RelativeElement("dots.dot", dx, 1, 7));
        abselem.addRight(new RelativeElement("dots.dot", dx, 1, 5));
      }
      if (elem.startEnding && isFirstStaff) {
        var textWidth = this.getTextSize.calc(elem.startEnding, "repeatfont", "").width;
        abselem.minspacing += textWidth + 10;
        this.partstartelem = new EndingElem(elem.startEnding, anchor, null);
        voice.addOther(this.partstartelem);
      }
      abselem.extraw -= 5;
      if (elem.chord !== void 0) {
        var ret3 = addChord(this.getTextSize, abselem, elem, 0, 0, 0, false, this.germanAlphabet);
      }
      return abselem;
    };
    module.exports = AbstractEngraver;
  }
});

// node_modules/abcjs/src/write/svg.js
var require_svg = __commonJS({
  "node_modules/abcjs/src/write/svg.js"(exports, module) {
    var svgNS = "http://www.w3.org/2000/svg";
    function Svg(wrapper) {
      this.svg = createSvg();
      this.currentGroup = [];
      wrapper.appendChild(this.svg);
    }
    Svg.prototype.clear = function() {
      if (this.svg) {
        var wrapper = this.svg.parentNode;
        this.svg = createSvg();
        this.currentGroup = [];
        if (wrapper) {
          wrapper.innerHTML = "";
          wrapper.appendChild(this.svg);
        }
      }
    };
    Svg.prototype.setTitle = function(title) {
      var titleEl = document.createElement("title");
      var titleNode = document.createTextNode(title);
      titleEl.appendChild(titleNode);
      this.svg.insertBefore(titleEl, this.svg.firstChild);
    };
    Svg.prototype.setResponsiveWidth = function(w, h) {
      this.svg.setAttribute("viewBox", "0 0 " + w + " " + h);
      this.svg.setAttribute("preserveAspectRatio", "xMinYMin meet");
      this.svg.removeAttribute("height");
      this.svg.removeAttribute("width");
      this.svg.style["display"] = "inline-block";
      this.svg.style["position"] = "absolute";
      this.svg.style["top"] = "0";
      this.svg.style["left"] = "0";
      if (this.svg.parentNode) {
        var cls = this.svg.parentNode.getAttribute("class");
        if (!cls)
          this.svg.parentNode.setAttribute("class", "abcjs-container");
        else if (cls.indexOf("abcjs-container") < 0)
          this.svg.parentNode.setAttribute("class", cls + " abcjs-container");
        this.svg.parentNode.style["display"] = "inline-block";
        this.svg.parentNode.style["position"] = "relative";
        this.svg.parentNode.style["width"] = "100%";
        var padding = h / w * 100;
        this.svg.parentNode.style["padding-bottom"] = padding + "%";
        this.svg.parentNode.style["vertical-align"] = "middle";
        this.svg.parentNode.style["overflow"] = "hidden";
      }
    };
    Svg.prototype.setSize = function(w, h) {
      this.svg.setAttribute("width", w);
      this.svg.setAttribute("height", h);
    };
    Svg.prototype.setAttribute = function(attr, value) {
      this.svg.setAttribute(attr, value);
    };
    Svg.prototype.setScale = function(scale) {
      if (scale !== 1) {
        this.svg.style.transform = "scale(" + scale + "," + scale + ")";
        this.svg.style["-ms-transform"] = "scale(" + scale + "," + scale + ")";
        this.svg.style["-webkit-transform"] = "scale(" + scale + "," + scale + ")";
        this.svg.style["transform-origin"] = "0 0";
        this.svg.style["-ms-transform-origin-x"] = "0";
        this.svg.style["-ms-transform-origin-y"] = "0";
        this.svg.style["-webkit-transform-origin-x"] = "0";
        this.svg.style["-webkit-transform-origin-y"] = "0";
      } else {
        this.svg.style.transform = "";
        this.svg.style["-ms-transform"] = "";
        this.svg.style["-webkit-transform"] = "";
      }
    };
    Svg.prototype.insertStyles = function(styles) {
      var el = document.createElementNS(svgNS, "style");
      el.textContent = styles;
      this.svg.insertBefore(el, this.svg.firstChild);
    };
    Svg.prototype.setParentStyles = function(attr) {
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          if (this.svg.parentNode)
            this.svg.parentNode.style[key] = attr[key];
        }
      }
      if (this.dummySvg) {
        var body = document.querySelector("body");
        body.removeChild(this.dummySvg);
        this.dummySvg = null;
      }
    };
    function constructHLine(x1, y1, x2) {
      var len = x2 - x1;
      return "M " + x1 + " " + y1 + " l " + len + " 0 l 0 1  l " + -len + " 0  z ";
    }
    function constructVLine(x1, y1, y2) {
      var len = y2 - y1;
      return "M " + x1 + " " + y1 + " l 0 " + len + " l 1 0  l 0 " + -len + "  z ";
    }
    Svg.prototype.rect = function(attr) {
      var lines = [];
      var x1 = attr.x;
      var y1 = attr.y;
      var x2 = attr.x + attr.width;
      var y2 = attr.y + attr.height;
      lines.push(constructHLine(x1, y1, x2));
      lines.push(constructHLine(x1, y2, x2));
      lines.push(constructVLine(x2, y1, y2));
      lines.push(constructVLine(x1, y2, y1));
      return this.path({ path: lines.join(" "), stroke: "none", "data-name": attr["data-name"] });
    };
    Svg.prototype.dottedLine = function(attr) {
      var el = document.createElementNS(svgNS, "line");
      el.setAttribute("x1", attr.x1);
      el.setAttribute("x2", attr.x2);
      el.setAttribute("y1", attr.y1);
      el.setAttribute("y2", attr.y2);
      el.setAttribute("stroke", attr.stroke);
      el.setAttribute("stroke-dasharray", "5,5");
      this.svg.insertBefore(el, this.svg.firstChild);
    };
    Svg.prototype.rectBeneath = function(attr) {
      var el = document.createElementNS(svgNS, "rect");
      el.setAttribute("x", attr.x);
      el.setAttribute("width", attr.width);
      el.setAttribute("y", attr.y);
      el.setAttribute("height", attr.height);
      if (attr.stroke)
        el.setAttribute("stroke", attr.stroke);
      if (attr["stroke-opacity"])
        el.setAttribute("stroke-opacity", attr["stroke-opacity"]);
      if (attr.fill)
        el.setAttribute("fill", attr.fill);
      if (attr["fill-opacity"])
        el.setAttribute("fill-opacity", attr["fill-opacity"]);
      this.svg.insertBefore(el, this.svg.firstChild);
    };
    Svg.prototype.text = function(text, attr, target) {
      var el = document.createElementNS(svgNS, "text");
      el.setAttribute("stroke", "none");
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          el.setAttribute(key, attr[key]);
        }
      }
      var lines = ("" + text).split("\n");
      for (var i2 = 0; i2 < lines.length; i2++) {
        var line = document.createElementNS(svgNS, "tspan");
        line.setAttribute("x", attr.x ? attr.x : 0);
        if (i2 !== 0)
          line.setAttribute("dy", "1.2em");
        if (lines[i2].indexOf("") !== -1) {
          var parts = lines[i2].split("");
          line.textContent = parts[0];
          if (parts[1]) {
            var ts2 = document.createElementNS(svgNS, "tspan");
            ts2.setAttribute("dy", "-0.3em");
            ts2.setAttribute("style", "font-size:0.7em");
            ts2.textContent = parts[1];
            line.appendChild(ts2);
          }
          if (parts[2]) {
            var dist = parts[1] ? "0.4em" : "0.1em";
            var ts3 = document.createElementNS(svgNS, "tspan");
            ts3.setAttribute("dy", dist);
            ts3.setAttribute("style", "font-size:0.7em");
            ts3.textContent = parts[2];
            line.appendChild(ts3);
          }
        } else
          line.textContent = lines[i2];
        el.appendChild(line);
      }
      if (target)
        target.appendChild(el);
      else
        this.append(el);
      return el;
    };
    Svg.prototype.richTextLine = function(phrases, x, y, klass, anchor, target) {
      var el = document.createElementNS(svgNS, "text");
      el.setAttribute("stroke", "none");
      el.setAttribute("class", klass);
      el.setAttribute("x", x);
      el.setAttribute("y", y);
      el.setAttribute("text-anchor", anchor);
      el.setAttribute("dominant-baseline", "middle");
      for (var i2 = 0; i2 < phrases.length; i2++) {
        var phrase = phrases[i2];
        var tspan = document.createElementNS(svgNS, "tspan");
        var attrs = Object.keys(phrase.attrs);
        for (var j = 0; j < attrs.length; j++) {
          var value = phrase.attrs[attrs[j]];
          if (value !== "")
            tspan.setAttribute(attrs[j], value);
        }
        tspan.textContent = phrase.content;
        el.appendChild(tspan);
      }
      if (target)
        target.appendChild(el);
      else
        this.append(el);
      return el;
    };
    Svg.prototype.guessWidth = function(text, attr) {
      var svg = this.createDummySvg();
      var el = this.text(text, attr, svg);
      var size;
      try {
        size = el.getBBox();
        if (isNaN(size.height) || !size.height)
          size = { width: attr["font-size"] / 2, height: attr["font-size"] + 2 };
        else
          size = { width: size.width, height: size.height };
      } catch (ex) {
        size = { width: attr["font-size"] / 2, height: attr["font-size"] + 2 };
      }
      svg.removeChild(el);
      return size;
    };
    Svg.prototype.createDummySvg = function() {
      if (!this.dummySvg) {
        this.dummySvg = createSvg();
        var styles = [
          "display: block !important;",
          "height: 1px;",
          "width: 1px;",
          "position: absolute;"
        ];
        this.dummySvg.setAttribute("style", styles.join(""));
        var body = document.querySelector("body");
        body.appendChild(this.dummySvg);
      }
      return this.dummySvg;
    };
    var sizeCache = {};
    Svg.prototype.getTextSize = function(text, attr, el) {
      if (typeof text === "number")
        text = "" + text;
      if (!text || text.match(/^\s+$/))
        return { width: 0, height: 0 };
      var key;
      if (text.length < 20) {
        key = text + JSON.stringify(attr);
        if (sizeCache[key])
          return sizeCache[key];
      }
      var removeLater = !el;
      if (!el)
        el = this.text(text, attr);
      var size;
      try {
        size = el.getBBox();
        if (isNaN(size.height) || !size.height)
          size = this.guessWidth(text, attr);
        else
          size = { width: size.width, height: size.height };
      } catch (ex) {
        size = this.guessWidth(text, attr);
      }
      if (removeLater) {
        if (this.currentGroup.length > 0)
          this.currentGroup[0].removeChild(el);
        else
          this.svg.removeChild(el);
      }
      if (key)
        sizeCache[key] = size;
      return size;
    };
    Svg.prototype.openGroup = function(options) {
      options = options ? options : {};
      var el = document.createElementNS(svgNS, "g");
      if (options.klass)
        el.setAttribute("class", options.klass);
      if (options.fill)
        el.setAttribute("fill", options.fill);
      if (options.stroke)
        el.setAttribute("stroke", options.stroke);
      if (options["data-name"])
        el.setAttribute("data-name", options["data-name"]);
      if (options.prepend)
        this.prepend(el);
      else
        this.append(el);
      this.currentGroup.unshift(el);
      return el;
    };
    Svg.prototype.closeGroup = function() {
      var g = this.currentGroup.shift();
      if (g && g.children.length === 0) {
        g.parentElement.removeChild(g);
        return null;
      }
      return g;
    };
    Svg.prototype.path = function(attr) {
      var el = document.createElementNS(svgNS, "path");
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          if (key === "path")
            el.setAttributeNS(null, "d", attr.path);
          else if (key === "klass")
            el.setAttributeNS(null, "class", attr[key]);
          else if (attr[key] !== void 0)
            el.setAttributeNS(null, key, attr[key]);
        }
      }
      this.append(el);
      return el;
    };
    Svg.prototype.pathToBack = function(attr) {
      var el = document.createElementNS(svgNS, "path");
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          if (key === "path")
            el.setAttributeNS(null, "d", attr.path);
          else if (key === "klass")
            el.setAttributeNS(null, "class", attr[key]);
          else
            el.setAttributeNS(null, key, attr[key]);
        }
      }
      this.prepend(el);
      return el;
    };
    Svg.prototype.lineToBack = function(attr) {
      var el = document.createElementNS(svgNS, "line");
      var keys = Object.keys(attr);
      for (var i2 = 0; i2 < keys.length; i2++)
        el.setAttribute(keys[i2], attr[keys[i2]]);
      this.prepend(el);
      return el;
    };
    Svg.prototype.append = function(el) {
      if (this.currentGroup.length > 0)
        this.currentGroup[0].appendChild(el);
      else
        this.svg.appendChild(el);
    };
    Svg.prototype.prepend = function(el) {
      if (this.currentGroup.length > 0)
        this.currentGroup[0].appendChild(el);
      else
        this.svg.insertBefore(el, this.svg.firstChild);
    };
    Svg.prototype.setAttributeOnElement = function(el, attr) {
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          el.setAttributeNS(null, key, attr[key]);
        }
      }
    };
    Svg.prototype.moveElementToChild = function(parent, child) {
      parent.appendChild(child);
    };
    function createSvg() {
      var svg = document.createElementNS(svgNS, "svg");
      svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
      svg.setAttribute("role", "img");
      svg.setAttribute("fill", "currentColor");
      svg.setAttribute("stroke", "currentColor");
      return svg;
    }
    module.exports = Svg;
  }
});

// node_modules/abcjs/src/write/renderer.js
var require_renderer = __commonJS({
  "node_modules/abcjs/src/write/renderer.js"(exports, module) {
    var spacing = require_spacing();
    var Svg = require_svg();
    var Renderer = function(paper) {
      this.paper = new Svg(paper);
      this.controller = null;
      this.space = 3 * spacing.SPACE;
      this.padding = {};
      this.reset();
      this.firefox112 = navigator.userAgent.indexOf("Firefox/112.0") >= 0;
    };
    Renderer.prototype.reset = function() {
      this.paper.clear();
      this.y = 0;
      this.abctune = null;
      this.path = null;
      this.isPrint = false;
      this.lineThickness = 0;
      this.initVerticalSpace();
    };
    Renderer.prototype.newTune = function(abcTune) {
      this.abctune = abcTune;
      this.setVerticalSpace(abcTune.formatting);
      this.isPrint = abcTune.media === "print";
      this.setPadding(abcTune);
    };
    Renderer.prototype.setLineThickness = function(lineThickness) {
      this.lineThickness = lineThickness;
    };
    Renderer.prototype.setPaddingOverride = function(params) {
      this.paddingOverride = {
        top: params.paddingtop,
        bottom: params.paddingbottom,
        right: params.paddingright,
        left: params.paddingleft
      };
    };
    Renderer.prototype.setPadding = function(abctune) {
      function setPaddingVariable(self, paddingKey, formattingKey, printDefault, screenDefault) {
        if (abctune.formatting[formattingKey] !== void 0)
          self.padding[paddingKey] = abctune.formatting[formattingKey];
        else if (self.paddingOverride[paddingKey] !== void 0)
          self.padding[paddingKey] = self.paddingOverride[paddingKey];
        else if (self.isPrint)
          self.padding[paddingKey] = printDefault;
        else
          self.padding[paddingKey] = screenDefault;
      }
      setPaddingVariable(this, "top", "topmargin", 38, 15);
      setPaddingVariable(this, "bottom", "botmargin", 38, 15);
      setPaddingVariable(this, "left", "leftmargin", 68, 15);
      setPaddingVariable(this, "right", "rightmargin", 68, 15);
    };
    Renderer.prototype.adjustNonScaledItems = function(scale) {
      this.padding.top /= scale;
      this.padding.bottom /= scale;
      this.padding.left /= scale;
      this.padding.right /= scale;
      this.abctune.formatting.headerfont.size /= scale;
      this.abctune.formatting.footerfont.size /= scale;
    };
    Renderer.prototype.initVerticalSpace = function() {
      this.spacing = {
        composer: 7.56,
        // Set the vertical space above the composer.
        graceBefore: 8.67,
        // Define the space before, inside and after the grace notes.
        graceInside: 10.67,
        graceAfter: 16,
        info: 0,
        // Set the vertical space above the infoline.
        lineSkipFactor: 1.1,
        // Set the factor for spacing between lines of text. (multiply this by the font size)
        music: 7.56,
        // Set the vertical space above the first staff.
        paragraphSkipFactor: 0.4,
        // Set the factor for spacing between text paragraphs. (multiply this by the font size)
        parts: 11.33,
        // Set the vertical space above a new part.
        slurHeight: 1,
        // Set the slur height factor.
        staffSeparation: 61.33,
        // Do not put a staff system closer than <unit> from the previous system.
        staffTopMargin: 0,
        stemHeight: 26.67 + 10,
        // Set the stem height.
        subtitle: 3.78,
        // Set the vertical space above the subtitle.
        systemStaffSeparation: 48,
        // Do not place the staves closer than <unit> inside a system. * This values applies to all staves when in the tune header. Otherwise, it applies to the next staff
        text: 18.9,
        // Set the vertical space above the history.
        title: 7.56,
        // Set the vertical space above the title.
        top: 30.24,
        //Set the vertical space above the tunes and on the top of the continuation pages.
        vocal: 0,
        // Set the vertical space above the lyrics under the staves.
        words: 0
        // Set the vertical space above the lyrics at the end of the tune.
      };
    };
    Renderer.prototype.setVerticalSpace = function(formatting) {
      if (formatting.staffsep !== void 0)
        this.spacing.staffSeparation = formatting.staffsep * 4 / 3;
      if (formatting.composerspace !== void 0)
        this.spacing.composer = formatting.composerspace * 4 / 3;
      if (formatting.partsspace !== void 0)
        this.spacing.parts = formatting.partsspace * 4 / 3;
      if (formatting.textspace !== void 0)
        this.spacing.text = formatting.textspace * 4 / 3;
      if (formatting.musicspace !== void 0)
        this.spacing.music = formatting.musicspace * 4 / 3;
      if (formatting.titlespace !== void 0)
        this.spacing.title = formatting.titlespace * 4 / 3;
      if (formatting.sysstaffsep !== void 0)
        this.spacing.systemStaffSeparation = formatting.sysstaffsep * 4 / 3;
      if (formatting.stafftopmargin !== void 0)
        this.spacing.staffTopMargin = formatting.stafftopmargin * 4 / 3;
      if (formatting.subtitlespace !== void 0)
        this.spacing.subtitle = formatting.subtitlespace * 4 / 3;
      if (formatting.topspace !== void 0)
        this.spacing.top = formatting.topspace * 4 / 3;
      if (formatting.vocalspace !== void 0)
        this.spacing.vocal = formatting.vocalspace * 4 / 3;
      if (formatting.wordsspace !== void 0)
        this.spacing.words = formatting.wordsspace * 4 / 3;
    };
    Renderer.prototype.calcY = function(ofs) {
      return this.y - ofs * spacing.STEP;
    };
    Renderer.prototype.moveY = function(em, numLines) {
      if (numLines === void 0) numLines = 1;
      this.y += em * numLines;
    };
    Renderer.prototype.absolutemoveY = function(y) {
      this.y = y;
    };
    module.exports = Renderer;
  }
});

// node_modules/abcjs/src/write/creation/elements/free-text.js
var require_free_text = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/free-text.js"(exports, module) {
    function FreeText(info, vskip, getFontAndAttr, paddingLeft, width, getTextSize) {
      var text = info.text;
      this.rows = [];
      var size;
      if (vskip)
        this.rows.push({ move: vskip });
      var hash = getFontAndAttr.calc("textfont", "defined-text");
      if (text === "") {
        this.rows.push({ move: hash.attr["font-size"] * 2 });
      } else if (typeof text === "string") {
        this.rows.push({ move: hash.attr["font-size"] / 2 });
        this.rows.push({ left: paddingLeft, text, font: "textfont", klass: "defined-text", anchor: "start", startChar: info.startChar, endChar: info.endChar, absElemType: "freeText", name: "free-text" });
        size = getTextSize.calc(text, "textfont", "defined-text");
        this.rows.push({ move: size.height });
      } else if (text) {
        var maxHeight = 0;
        var leftSide = paddingLeft;
        var currentFont = "textfont";
        for (var i2 = 0; i2 < text.length; i2++) {
          if (text[i2].font) {
            currentFont = text[i2].font;
          } else
            currentFont = "textfont";
          this.rows.push({ left: leftSide, text: text[i2].text, font: currentFont, klass: "defined-text", anchor: "start", startChar: info.startChar, endChar: info.endChar, absElemType: "freeText", name: "free-text" });
          size = getTextSize.calc(text[i2].text, getFontAndAttr.calc(currentFont, "defined-text").font, "defined-text");
          leftSide += size.width + size.height / 2;
          maxHeight = Math.max(maxHeight, size.height);
        }
        this.rows.push({ move: maxHeight });
      } else {
        if (info.length === 1) {
          var x = width / 2;
          this.rows.push({ left: x, text: info[0].text, font: "textfont", klass: "defined-text", anchor: "middle", startChar: info.startChar, endChar: info.endChar, absElemType: "freeText", name: "free-text" });
          size = getTextSize.calc(info[0].text, "textfont", "defined-text");
          this.rows.push({ move: size.height });
        }
      }
    }
    module.exports = FreeText;
  }
});

// node_modules/abcjs/src/write/creation/elements/separator.js
var require_separator = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/separator.js"(exports, module) {
    function Separator(spaceAbove, lineLength, spaceBelow) {
      this.rows = [];
      if (spaceAbove)
        this.rows.push({ move: spaceAbove });
      this.rows.push({ separator: lineLength, absElemType: "separator" });
      if (spaceBelow)
        this.rows.push({ move: spaceBelow });
    }
    module.exports = Separator;
  }
});

// node_modules/abcjs/src/write/creation/elements/subtitle.js
var require_subtitle = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/subtitle.js"(exports, module) {
    function Subtitle(spaceAbove, formatting, info, center, paddingLeft, getTextSize) {
      this.rows = [];
      if (spaceAbove)
        this.rows.push({ move: spaceAbove });
      var tAnchor = formatting.titleleft ? "start" : "middle";
      var tLeft = formatting.titleleft ? paddingLeft : center;
      this.rows.push({ left: tLeft, text: info.text, font: "subtitlefont", klass: "text subtitle", anchor: tAnchor, startChar: info.startChar, endChar: info.endChar, absElemType: "subtitle", name: "subtitle" });
      var size = getTextSize.calc(info.text, "subtitlefont", "text subtitle");
      this.rows.push({ move: size.height });
    }
    module.exports = Subtitle;
  }
});

// node_modules/abcjs/src/write/creation/add-text-if.js
var require_add_text_if = __commonJS({
  "node_modules/abcjs/src/write/creation/add-text-if.js"(exports, module) {
    function addTextIf(rows, params, getTextSize) {
      if (!params.text)
        return;
      if (!params.marginLeft) params.marginLeft = 0;
      if (!params.klass) params.klass = "";
      if (!params.anchor) params.anchor = "start";
      if (!params.info) params.info = { startChar: -2, endChar: -2 };
      if (params.marginTop)
        rows.push({ move: params.marginTop });
      var attr = { left: params.marginLeft, text: params.text, font: params.font, anchor: params.anchor, startChar: params.info.startChar, endChar: params.info.endChar, "dominant-baseline": params["dominant-baseline"] };
      if (params.absElemType)
        attr.absElemType = params.absElemType;
      if (!params.inGroup && params.klass)
        attr.klass = params.klass;
      if (params.name)
        attr.name = params.name;
      rows.push(attr);
      var size = getTextSize.calc("A", params.font, params.klass);
      var numLines = params.text.split("\n").length;
      if (params.text[params.text.length - 1] === "\n")
        numLines--;
      if (!params.noMove) {
        var h = size.height * 1.1 * numLines;
        rows.push({ move: Math.round(h) });
        if (params.marginBottom)
          rows.push({ move: params.marginBottom });
      }
    }
    module.exports = addTextIf;
  }
});

// node_modules/abcjs/src/write/creation/elements/rich-text.js
var require_rich_text = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/rich-text.js"(exports, module) {
    var addTextIf = require_add_text_if();
    function richText(rows, str, defFont, klass, name, paddingLeft, attr, getTextSize) {
      var space = getTextSize.calc("i", defFont, klass);
      if (str === "") {
        rows.push({ move: space.height });
      } else {
        if (typeof str === "string") {
          addTextIf(rows, { marginLeft: paddingLeft, text: str, font: defFont, klass, marginTop: attr.marginTop, anchor: attr.anchor, absElemType: attr.absElemType, info: attr.info, name }, getTextSize);
          return;
        }
        if (attr.marginTop)
          rows.push({ move: attr.marginTop });
        var largestY = 0;
        var gap = 0;
        var row = {
          left: paddingLeft,
          anchor: attr.anchor,
          phrases: []
        };
        if (klass)
          row.klass = klass;
        rows.push(row);
        for (var k = 0; k < str.length; k++) {
          var thisWord = str[k];
          var font = thisWord.font ? thisWord.font : getTextSize.attr(defFont, klass).font;
          var phrase = {
            content: thisWord.text
          };
          if (font)
            phrase.attrs = {
              "font-family": getTextSize.getFamily(font.face),
              "font-size": font.size,
              "font-weight": font.weight,
              "font-style": font.style,
              "font-decoration": font.decoration
            };
          row.phrases.push(phrase);
          var size = getTextSize.calc(thisWord.text, font, klass);
          largestY = Math.max(largestY, size.height);
          if (thisWord.text[thisWord.text.length - 1] === " ") {
            gap = space.width;
          }
        }
        rows.push({ move: largestY });
      }
    }
    module.exports = richText;
  }
});

// node_modules/abcjs/src/write/creation/elements/top-text.js
var require_top_text = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/top-text.js"(exports, module) {
    var addTextIf = require_add_text_if();
    var richText = require_rich_text();
    function TopText(metaText, metaTextInfo, formatting, lines, width, isPrint, paddingLeft, spacing, shouldAddClasses, getTextSize) {
      this.rows = [];
      if (metaText.header && isPrint) {
        var headerTextHeight = getTextSize.calc("X", "headerfont", "abcjs-header abcjs-meta-top").height;
        addTextIf(this.rows, { marginLeft: paddingLeft, text: metaText.header.left, font: "headerfont", klass: "header meta-top", marginTop: -headerTextHeight, info: metaTextInfo.header, name: "header" }, getTextSize);
        addTextIf(this.rows, { marginLeft: paddingLeft + width / 2, text: metaText.header.center, font: "headerfont", klass: "header meta-top", marginTop: -headerTextHeight, anchor: "middle", info: metaTextInfo.header, name: "header" }, getTextSize);
        addTextIf(this.rows, { marginLeft: paddingLeft + width, text: metaText.header.right, font: "headerfont", klass: "header meta-top", marginTop: -headerTextHeight, anchor: "end", info: metaTextInfo.header, name: "header" }, getTextSize);
      }
      if (isPrint)
        this.rows.push({ move: spacing.top });
      var tAnchor = formatting.titleleft ? "start" : "middle";
      var tLeft = formatting.titleleft ? paddingLeft : paddingLeft + width / 2;
      if (metaText.title) {
        var klass = shouldAddClasses ? "abcjs-title" : "";
        richText(this.rows, metaText.title, "titlefont", klass, "title", tLeft, { marginTop: spacing.title, anchor: tAnchor, absElemType: "title", info: metaTextInfo.title }, getTextSize);
      }
      if (lines.length) {
        var index = 0;
        while (index < lines.length && lines[index].subtitle) {
          var klass = shouldAddClasses ? "abcjs-text abcjs-subtitle" : "";
          richText(this.rows, lines[index].subtitle.text, "subtitlefont", klass, "subtitle", tLeft, { marginTop: spacing.subtitle, anchor: tAnchor, absElemType: "subtitle", info: lines[index].subtitle }, getTextSize);
          index++;
        }
      }
      if (metaText.rhythm || metaText.origin || metaText.composer) {
        this.rows.push({ move: spacing.composer });
        if (metaText.rhythm && metaText.rhythm.length > 0) {
          var noMove = !!(metaText.composer || metaText.origin);
          var klass = shouldAddClasses ? "abcjs-rhythm" : "";
          addTextIf(this.rows, { marginLeft: paddingLeft, text: metaText.rhythm, font: "infofont", klass, absElemType: "rhythm", noMove, info: metaTextInfo.rhythm, name: "rhythm" }, getTextSize);
        }
        var hasSimpleComposerLine = true;
        if (metaText.composer && typeof metaText.composer !== "string")
          hasSimpleComposerLine = false;
        if (metaText.origin && typeof metaText.origin !== "string")
          hasSimpleComposerLine = false;
        var composerLine = metaText.composer ? metaText.composer : "";
        if (metaText.origin) {
          if (typeof composerLine === "string" && typeof metaText.origin === "string")
            composerLine += " (" + metaText.origin + ")";
          else if (typeof composerLine === "string" && typeof metaText.origin !== "string") {
            composerLine = [{ text: composerLine }];
            composerLine.push({ text: " (" });
            composerLine = composerLine.concat(metaText.origin);
            composerLine.push({ text: ")" });
          } else {
            composerLine.push({ text: " (" });
            composerLine = composerLine.concat(metaText.origin);
            composerLine.push({ text: ")" });
          }
        }
        if (composerLine) {
          var klass = shouldAddClasses ? "abcjs-composer" : "";
          richText(this.rows, composerLine, "composerfont", klass, "composer", paddingLeft + width, { anchor: "end", absElemType: "composer", info: metaTextInfo.composer, ingroup: true }, getTextSize);
        }
      }
      if (metaText.author && metaText.author.length > 0) {
        var klass = shouldAddClasses ? "abcjs-author" : "";
        richText(this.rows, metaText.author, "composerfont", klass, "author", paddingLeft + width, { anchor: "end", absElemType: "author", info: metaTextInfo.author }, getTextSize);
      }
      if (metaText.partOrder && metaText.partOrder.length > 0) {
        var klass = shouldAddClasses ? "abcjs-part-order" : "";
        richText(this.rows, metaText.partOrder, "partsfont", klass, "part-order", paddingLeft, { absElemType: "partOrder", info: metaTextInfo.partOrder, anchor: "start" }, getTextSize);
      }
    }
    module.exports = TopText;
  }
});

// node_modules/abcjs/src/write/creation/elements/bottom-text.js
var require_bottom_text = __commonJS({
  "node_modules/abcjs/src/write/creation/elements/bottom-text.js"(exports, module) {
    var addTextIf = require_add_text_if();
    var richText = require_rich_text();
    function BottomText(metaText, width, isPrint, paddingLeft, spacing, shouldAddClasses, getTextSize) {
      this.rows = [];
      if (metaText.unalignedWords && metaText.unalignedWords.length > 0)
        this.unalignedWords(metaText.unalignedWords, paddingLeft, spacing, shouldAddClasses, getTextSize);
      this.extraText(metaText, paddingLeft, spacing, shouldAddClasses, getTextSize);
      if (metaText.footer && isPrint)
        this.footer(metaText.footer, width, paddingLeft, getTextSize);
    }
    BottomText.prototype.unalignedWords = function(unalignedWords, marginLeft, spacing, shouldAddClasses, getTextSize) {
      var klass = shouldAddClasses ? "abcjs-unaligned-words" : "";
      var defFont = "wordsfont";
      var space = getTextSize.calc("i", defFont, klass);
      this.rows.push({ move: spacing.words });
      addMultiLine(this.rows, "", unalignedWords, marginLeft, defFont, "unalignedWords", "unalignedWords", klass, "unalignedWords", spacing, shouldAddClasses, getTextSize);
      this.rows.push({ move: space.height });
    };
    function addSingleLine(rows, preface, text, marginLeft, klass, shouldAddClasses, getTextSize) {
      if (text) {
        if (preface) {
          if (typeof text === "string")
            text = preface + text;
          else
            text = [{ text: preface }].concat(text);
        }
        klass = shouldAddClasses ? "abcjs-extra-text " + klass : "";
        richText(rows, text, "historyfont", klass, "description", marginLeft, { absElemType: "extraText", anchor: "start" }, getTextSize);
      }
    }
    function addMultiLine(rows, preface, content, marginLeft, defFont, absElemType, groupName, klass, name, spacing, shouldAddClasses, getTextSize) {
      if (content) {
        klass = shouldAddClasses ? "abcjs-extra-text " + klass : "";
        var size = getTextSize.calc("A", defFont, klass);
        if (typeof content === "string") {
          if (preface)
            content = preface + "\n" + content;
          addTextIf(rows, { marginLeft, text: content, font: defFont, absElemType: "extraText", name, "dominant-baseline": "middle", klass }, getTextSize);
        } else {
          rows.push({ startGroup: groupName, klass, name });
          rows.push({ move: spacing.info });
          if (preface) {
            addTextIf(rows, { marginLeft, text: preface, font: defFont, absElemType: "extraText", name, "dominant-baseline": "middle" }, getTextSize);
            rows.push({ move: size.height * 3 / 4 });
          }
          for (var j = 0; j < content.length; j++) {
            richText(rows, content[j], defFont, "", name, marginLeft, { anchor: "start" }, getTextSize);
            if (j < content.length - 1 && typeof content[j] === "string" && typeof content[j + 1] !== "string")
              rows.push({ move: size.height * 3 / 4 });
          }
          rows.push({ endGroup: groupName, absElemType, startChar: -1, endChar: -1, name });
          rows.push({ move: size.height });
        }
      }
    }
    BottomText.prototype.extraText = function(metaText, marginLeft, spacing, shouldAddClasses, getTextSize) {
      addSingleLine(this.rows, "Book: ", metaText.book, marginLeft, "abcjs-book", shouldAddClasses, getTextSize);
      addSingleLine(this.rows, "Source: ", metaText.source, marginLeft, "abcjs-source", shouldAddClasses, getTextSize);
      addSingleLine(this.rows, "Discography: ", metaText.discography, marginLeft, "abcjs-discography", shouldAddClasses, getTextSize);
      addMultiLine(this.rows, "Notes:", metaText.notes, marginLeft, "historyfont", "extraText", "notes", "abcjs-notes", "description", spacing, shouldAddClasses, getTextSize);
      addSingleLine(this.rows, "Transcription: ", metaText.transcription, marginLeft, "abcjs-transcription", shouldAddClasses, getTextSize);
      addMultiLine(this.rows, "History:", metaText.history, marginLeft, "historyfont", "extraText", "history", "abcjs-history", "description", spacing, shouldAddClasses, getTextSize);
      addSingleLine(this.rows, "Copyright: ", metaText["abc-copyright"], marginLeft, "abcjs-copyright", shouldAddClasses, getTextSize);
      addSingleLine(this.rows, "Creator: ", metaText["abc-creator"], marginLeft, "abcjs-creator", shouldAddClasses, getTextSize);
      addSingleLine(this.rows, "Edited By: ", metaText["abc-edited-by"], marginLeft, "abcjs-edited-by", shouldAddClasses, getTextSize);
    };
    BottomText.prototype.footer = function(footer, width, paddingLeft, getTextSize) {
      var klass = "header meta-bottom";
      var font = "footerfont";
      this.rows.push({ startGroup: "footer", klass });
      addTextIf(this.rows, { marginLeft: paddingLeft, text: footer.left, font, klass, name: "footer" }, getTextSize);
      addTextIf(this.rows, { marginLeft: paddingLeft + width / 2, text: footer.center, font, klass, anchor: "middle", name: "footer" }, getTextSize);
      addTextIf(this.rows, { marginLeft: paddingLeft + width, text: footer.right, font, klass, anchor: "end", name: "footer" }, getTextSize);
    };
    module.exports = BottomText;
  }
});

// node_modules/abcjs/src/write/interactive/create-analysis.js
var require_create_analysis = __commonJS({
  "node_modules/abcjs/src/write/interactive/create-analysis.js"(exports, module) {
    function findNumber(klass, match, target, name) {
      if (klass.indexOf(match) === 0) {
        var value = klass.replace(match, "");
        var num = parseInt(value, 10);
        if ("" + num === value)
          target[name] = num;
      }
    }
    function createAnalysis(target, ev) {
      var classes = [];
      if (target.absEl.elemset) {
        var classObj = {};
        for (var j = 0; j < target.absEl.elemset.length; j++) {
          var es = target.absEl.elemset[j];
          if (es) {
            var klass = es.getAttribute("class").split(" ");
            for (var k = 0; k < klass.length; k++)
              classObj[klass[k]] = true;
          }
        }
        for (var kk = 0; kk < Object.keys(classObj).length; kk++)
          classes.push(Object.keys(classObj)[kk]);
      }
      var analysis = {};
      for (var ii = 0; ii < classes.length; ii++) {
        findNumber(classes[ii], "abcjs-v", analysis, "voice");
        findNumber(classes[ii], "abcjs-l", analysis, "line");
        findNumber(classes[ii], "abcjs-m", analysis, "measure");
      }
      if (target.staffPos)
        analysis.staffPos = target.staffPos;
      var closest = ev.target;
      while (closest && closest.dataset && !closest.dataset.name && closest.tagName.toLowerCase() !== "svg")
        closest = closest.parentNode;
      var parent = ev.target;
      while (parent && parent.dataset && !parent.dataset.index && parent.tagName.toLowerCase() !== "svg")
        parent = parent.parentNode;
      if (parent && parent.dataset) {
        analysis.name = parent.dataset.name;
        analysis.clickedName = closest.dataset.name;
        analysis.parentClasses = parent.classList;
      }
      if (closest && closest.classList)
        analysis.clickedClasses = closest.classList;
      analysis.selectableElement = target.svgEl;
      return { classes, analysis };
    }
    module.exports = createAnalysis;
  }
});

// node_modules/abcjs/src/write/interactive/selection.js
var require_selection = __commonJS({
  "node_modules/abcjs/src/write/interactive/selection.js"(exports, module) {
    var spacing = require_spacing();
    var createAnalysis = require_create_analysis();
    function setupSelection(engraver, svgs) {
      engraver.rangeHighlight = rangeHighlight;
      if (engraver.dragging) {
        for (var h = 0; h < engraver.selectables.length; h++) {
          var hist = engraver.selectables[h];
          if (hist.svgEl.getAttribute("selectable") === "true") {
            hist.svgEl.setAttribute("tabindex", 0);
            hist.svgEl.setAttribute("data-index", h);
            hist.svgEl.addEventListener("keydown", keyboardDown.bind(engraver));
            hist.svgEl.addEventListener("keyup", keyboardSelection.bind(engraver));
            hist.svgEl.addEventListener("focus", elementFocused.bind(engraver));
          }
        }
      }
      for (var i2 = 0; i2 < svgs.length; i2++) {
        svgs[i2].addEventListener("touchstart", mouseDown.bind(engraver), { passive: true });
        svgs[i2].addEventListener("touchmove", mouseMove.bind(engraver), { passive: true });
        svgs[i2].addEventListener("touchend", mouseUp.bind(engraver), { passive: true });
        svgs[i2].addEventListener("mousedown", mouseDown.bind(engraver));
        svgs[i2].addEventListener("mousemove", mouseMove.bind(engraver));
        svgs[i2].addEventListener("mouseup", mouseUp.bind(engraver));
      }
    }
    function getCoord(ev) {
      var scaleX = 1;
      var scaleY = 1;
      var svg = ev.target.closest("svg");
      var yOffset = 0;
      if (svg && svg.viewBox && svg.viewBox.baseVal) {
        if (svg.viewBox.baseVal.width !== 0)
          scaleX = svg.viewBox.baseVal.width / svg.clientWidth;
        if (svg.viewBox.baseVal.height !== 0)
          scaleY = svg.viewBox.baseVal.height / svg.clientHeight;
        yOffset = svg.viewBox.baseVal.y;
      }
      var svgClicked = ev.target && ev.target.tagName === "svg";
      var x;
      var y;
      if (svgClicked) {
        x = ev.offsetX;
        y = ev.offsetY;
      } else {
        x = ev.layerX;
        y = ev.layerY;
      }
      x = x * scaleX;
      y = y * scaleY;
      return [x, y + yOffset];
    }
    function elementFocused(ev) {
      if (this.dragMechanism === "keyboard" && this.dragYStep !== 0 && this.dragTarget)
        notifySelect.bind(this)(this.dragTarget, this.dragYStep, this.selectables.length, this.dragIndex, ev);
      this.dragYStep = 0;
    }
    function keyboardDown(ev) {
      switch (ev.keyCode) {
        case 38:
        case 40:
          ev.preventDefault();
      }
    }
    function keyboardSelection(ev) {
      var handled = false;
      var index = ev.target.dataset.index;
      switch (ev.keyCode) {
        case 13:
        case 32:
          handled = true;
          this.dragTarget = this.selectables[index];
          this.dragIndex = index;
          this.dragMechanism = "keyboard";
          mouseUp.bind(this)(ev);
          break;
        case 38:
          handled = true;
          this.dragTarget = this.selectables[index];
          this.dragIndex = index;
          if (this.dragTarget && this.dragTarget.isDraggable) {
            if (this.dragging && this.dragTarget.isDraggable)
              this.dragTarget.absEl.highlight(void 0, this.dragColor);
            this.dragYStep--;
            this.dragTarget.svgEl.setAttribute("transform", "translate(0," + this.dragYStep * spacing.STEP + ")");
          }
          break;
        case 40:
          handled = true;
          this.dragTarget = this.selectables[index];
          this.dragIndex = index;
          this.dragMechanism = "keyboard";
          if (this.dragTarget && this.dragTarget.isDraggable) {
            if (this.dragging && this.dragTarget.isDraggable)
              this.dragTarget.absEl.highlight(void 0, this.dragColor);
            this.dragYStep++;
            this.dragTarget.svgEl.setAttribute("transform", "translate(0," + this.dragYStep * spacing.STEP + ")");
          }
          break;
        case 9:
          if (this.dragYStep !== 0) {
            mouseUp.bind(this)(ev);
          }
          break;
        default:
          break;
      }
      if (handled)
        ev.preventDefault();
    }
    function findElementInHistory(selectables, el) {
      if (!el)
        return -1;
      for (var i2 = 0; i2 < selectables.length; i2++) {
        if (el.dataset.index === selectables[i2].svgEl.dataset.index)
          return i2;
      }
      return -1;
    }
    function findElementByCoord(self, x, y) {
      var minDistance = 9999999;
      var closestIndex = -1;
      for (var i2 = 0; i2 < self.selectables.length && minDistance > 0; i2++) {
        var el = self.selectables[i2];
        self.getDim(el);
        if (el.dim.left < x && el.dim.right > x && el.dim.top < y && el.dim.bottom > y) {
          closestIndex = i2;
          minDistance = 0;
        } else if (el.dim.top < y && el.dim.bottom > y) {
          var horiz = Math.min(Math.abs(el.dim.left - x), Math.abs(el.dim.right - x));
          if (horiz < minDistance) {
            minDistance = horiz;
            closestIndex = i2;
          }
        } else if (el.dim.left < x && el.dim.right > x) {
          var vert = Math.min(Math.abs(el.dim.top - y), Math.abs(el.dim.bottom - y));
          if (vert < minDistance) {
            minDistance = vert;
            closestIndex = i2;
          }
        } else {
          var dx = Math.abs(x - el.dim.left) > Math.abs(x - el.dim.right) ? Math.abs(x - el.dim.right) : Math.abs(x - el.dim.left);
          var dy = Math.abs(y - el.dim.top) > Math.abs(y - el.dim.bottom) ? Math.abs(y - el.dim.bottom) : Math.abs(y - el.dim.top);
          var hypotenuse = Math.sqrt(dx * dx + dy * dy);
          if (hypotenuse < minDistance) {
            minDistance = hypotenuse;
            closestIndex = i2;
          }
        }
      }
      return closestIndex >= 0 && minDistance <= 12 ? closestIndex : -1;
    }
    function getBestMatchCoordinates(dim, ev, scale) {
      if (dim.x <= ev.offsetX && dim.x + dim.width >= ev.offsetX && dim.y <= ev.offsetY && dim.y + dim.height >= ev.offsetY)
        return [ev.offsetX, ev.offsetY];
      var epsilon = Math.abs(ev.layerY / scale - ev.offsetY);
      if (epsilon < 3)
        return [ev.offsetX, ev.offsetY];
      else
        return [ev.layerX, ev.layerY];
    }
    function getTarget(target) {
      if (!target)
        return null;
      if (target.tagName === "svg")
        return target;
      if (!target.getAttribute)
        return null;
      var found = target.getAttribute("selectable");
      while (!found) {
        if (!target.parentElement)
          found = true;
        else {
          target = target.parentElement;
          if (target.tagName === "svg")
            found = true;
          else
            found = target.getAttribute("selectable");
        }
      }
      return target;
    }
    function getMousePosition(self, ev) {
      var x;
      var y;
      var box;
      var clickedOn = findElementInHistory(self.selectables, getTarget(ev.target));
      if (clickedOn >= 0) {
        box = getBestMatchCoordinates(self.selectables[clickedOn].svgEl.getBBox(), ev, self.scale);
        x = box[0];
        y = box[1];
      } else {
        box = getCoord(ev);
        x = box[0];
        y = box[1];
        clickedOn = findElementByCoord(self, x, y);
      }
      return { x, y, clickedOn };
    }
    function attachMissingTouchEventAttributes(touchEv) {
      if (!touchEv || !touchEv.target || !touchEv.touches || touchEv.touches.length < 1)
        return;
      var rect = touchEv.target.getBoundingClientRect();
      var offsetX = touchEv.touches[0].pageX - rect.left;
      var offsetY = touchEv.touches[0].pageY - rect.top;
      touchEv.touches[0].offsetX = offsetX;
      touchEv.touches[0].offsetY = offsetY;
      touchEv.touches[0].layerX = touchEv.touches[0].pageX;
      touchEv.touches[0].layerY = touchEv.touches[0].pageY;
    }
    function mouseDown(ev) {
      var _ev = ev;
      if (ev.type === "touchstart") {
        attachMissingTouchEventAttributes(ev);
        if (ev.touches.length > 0)
          _ev = ev.touches[0];
      }
      var positioning = getMousePosition(this, _ev);
      if (positioning.clickedOn >= 0 && (ev.type === "touchstart" || ev.button === 0) && this.selectables[positioning.clickedOn]) {
        this.dragTarget = this.selectables[positioning.clickedOn];
        this.dragIndex = positioning.clickedOn;
        this.dragMechanism = "mouse";
        this.dragMouseStart = { x: positioning.x, y: positioning.y };
        if (this.dragging && this.dragTarget.isDraggable) {
          addGlobalClass(this.renderer.paper, "abcjs-dragging-in-progress");
          this.dragTarget.absEl.highlight(void 0, this.dragColor);
        }
      }
    }
    function mouseMove(ev) {
      var _ev = ev;
      if (ev.type === "touchmove") {
        attachMissingTouchEventAttributes(ev);
        if (ev.touches.length > 0)
          _ev = ev.touches[0];
      }
      this.lastTouchMove = ev;
      if (!this.dragTarget || !this.dragging || !this.dragTarget.isDraggable || this.dragMechanism !== "mouse" || !this.dragMouseStart)
        return;
      var positioning = getMousePosition(this, _ev);
      var yDist = Math.round((positioning.y - this.dragMouseStart.y) / spacing.STEP);
      if (yDist !== this.dragYStep) {
        this.dragYStep = yDist;
        this.dragTarget.svgEl.setAttribute("transform", "translate(0," + yDist * spacing.STEP + ")");
      }
    }
    function mouseUp(ev) {
      var _ev = ev;
      if (ev.type === "touchend" && this.lastTouchMove) {
        attachMissingTouchEventAttributes(this.lastTouchMove);
        if (this.lastTouchMove && this.lastTouchMove.touches && this.lastTouchMove.touches.length > 0)
          _ev = this.lastTouchMove.touches[0];
      }
      if (!this.dragTarget)
        return;
      clearSelection.bind(this)();
      if (this.dragTarget.absEl && this.dragTarget.absEl.highlight) {
        this.selected = [this.dragTarget.absEl];
        this.dragTarget.absEl.highlight(void 0, this.selectionColor);
      }
      notifySelect.bind(this)(this.dragTarget, this.dragYStep, this.selectables.length, this.dragIndex, _ev);
      if (this.dragTarget.svgEl && this.dragTarget.svgEl.focus) {
        this.dragTarget.svgEl.focus();
        this.dragTarget = null;
        this.dragIndex = -1;
      }
      removeGlobalClass(this.renderer.svg, "abcjs-dragging-in-progress");
    }
    function setSelection(dragIndex) {
      if (dragIndex >= 0 && dragIndex < this.selectables.length) {
        this.dragTarget = this.selectables[dragIndex];
        this.dragIndex = dragIndex;
        this.dragMechanism = "keyboard";
        mouseUp.bind(this)({ target: this.dragTarget.svgEl });
      }
    }
    function notifySelect(target, dragStep, dragMax, dragIndex, ev) {
      var ret = createAnalysis(target, ev);
      var classes = ret.classes;
      var analysis = ret.analysis;
      for (var i2 = 0; i2 < this.listeners.length; i2++) {
        this.listeners[i2](target.absEl.abcelem, target.absEl.tuneNumber, classes.join(" "), analysis, { step: dragStep, max: dragMax, index: dragIndex, setSelection: setSelection.bind(this) }, ev);
      }
    }
    function clearSelection() {
      for (var i2 = 0; i2 < this.selected.length; i2++) {
        this.selected[i2].unhighlight(void 0, this.renderer.foregroundColor);
      }
      this.selected = [];
    }
    function rangeHighlight(start, end) {
      clearSelection.bind(this)();
      for (var line = 0; line < this.staffgroups.length; line++) {
        var voices = this.staffgroups[line].voices;
        for (var voice = 0; voice < voices.length; voice++) {
          var elems = voices[voice].children;
          for (var elem = 0; elem < elems.length; elem++) {
            var elStart = elems[elem].abcelem.startChar;
            var elEnd = elems[elem].abcelem.endChar;
            if (end > elStart && start < elEnd || end === start && end === elEnd) {
              this.selected[this.selected.length] = elems[elem];
              elems[elem].highlight(void 0, this.selectionColor);
            }
          }
        }
      }
    }
    function getClassSet(el) {
      var oldClass = el.getAttribute("class");
      if (!oldClass)
        oldClass = "";
      var klasses = oldClass.split(" ");
      var obj = {};
      for (var i2 = 0; i2 < klasses.length; i2++)
        obj[klasses[i2]] = true;
      return obj;
    }
    function setClassSet(el, klassSet) {
      var klasses = [];
      for (var key in klassSet) {
        if (klassSet.hasOwnProperty(key))
          klasses.push(key);
      }
      el.setAttribute("class", klasses.join(" "));
    }
    function addGlobalClass(svg, klass) {
      if (svg) {
        var obj = getClassSet(svg.svg);
        obj[klass] = true;
        setClassSet(svg.svg, obj);
      }
    }
    function removeGlobalClass(svg, klass) {
      if (svg) {
        var obj = getClassSet(svg.svg);
        delete obj[klass];
        setClassSet(svg.svg, obj);
      }
    }
    module.exports = setupSelection;
  }
});

// node_modules/abcjs/src/write/layout/get-bar-y-at.js
var require_get_bar_y_at = __commonJS({
  "node_modules/abcjs/src/write/layout/get-bar-y-at.js"(exports, module) {
    function getBarYAt(startx, starty, endx, endy, x) {
      return starty + (endy - starty) / (endx - startx) * (x - startx);
    }
    module.exports = getBarYAt;
  }
});

// node_modules/abcjs/src/write/layout/beam.js
var require_beam = __commonJS({
  "node_modules/abcjs/src/write/layout/beam.js"(exports, module) {
    var RelativeElement = require_relative_element();
    var spacing = require_spacing();
    var getBarYAt = require_get_bar_y_at();
    var layoutBeam = function(beam) {
      if (beam.elems.length === 0 || beam.allrests) return;
      var dy = calcDy(beam.stemsUp, beam.isgrace);
      var firstElement = beam.elems[0];
      var lastElement = beam.elems[beam.elems.length - 1];
      var minStemHeight = 0;
      var referencePitch = beam.stemsUp ? firstElement.abcelem.maxpitch : firstElement.abcelem.minpitch;
      minStemHeight = minStem(firstElement, beam.stemsUp, referencePitch, minStemHeight);
      minStemHeight = minStem(lastElement, beam.stemsUp, referencePitch, minStemHeight);
      minStemHeight = Math.max(beam.stemHeight, minStemHeight + 3);
      var yPos = calcYPos(beam.average, beam.elems.length, minStemHeight, beam.stemsUp, firstElement.abcelem.averagepitch, lastElement.abcelem.averagepitch, beam.isflat, beam.min, beam.max, beam.isgrace);
      var xPos = calcXPos(beam.stemsUp, firstElement, lastElement);
      beam.addBeam({ startX: xPos[0], endX: xPos[1], startY: yPos[0], endY: yPos[1], dy });
      var beams = createAdditionalBeams(beam.elems, beam.stemsUp, beam.beams[0], beam.isgrace, dy);
      for (var i2 = 0; i2 < beams.length; i2++)
        beam.addBeam(beams[i2]);
      createStems(beam.elems, beam.stemsUp, beam.beams[0], dy, beam.mainNote);
    };
    var getDurlog = function(duration) {
      if (duration === void 0) {
        return 0;
      }
      return Math.floor(Math.log(duration) / Math.log(2));
    };
    function minStem(element, stemsUp, referencePitch, minStemHeight) {
      if (!element.children)
        return minStemHeight;
      for (var i2 = 0; i2 < element.children.length; i2++) {
        var elem = element.children[i2];
        if (stemsUp && elem.top !== void 0 && elem.c === "flags.ugrace")
          minStemHeight = Math.max(minStemHeight, elem.top - referencePitch);
        else if (!stemsUp && elem.bottom !== void 0 && elem.c === "flags.ugrace")
          minStemHeight = Math.max(minStemHeight, referencePitch - elem.bottom + 7);
      }
      return minStemHeight;
    }
    function calcSlant(leftAveragePitch, rightAveragePitch, numStems, isFlat) {
      if (isFlat)
        return 0;
      var slant = leftAveragePitch - rightAveragePitch;
      var maxSlant = numStems / 2;
      if (slant > maxSlant) slant = maxSlant;
      if (slant < -maxSlant) slant = -maxSlant;
      return slant;
    }
    function calcDy(asc, isGrace) {
      var dy = asc ? spacing.STEP : -spacing.STEP;
      if (isGrace) dy = dy * 0.4;
      return dy;
    }
    function calcXPos(asc, firstElement, lastElement) {
      var starthead = firstElement.heads[asc ? 0 : firstElement.heads.length - 1];
      var endhead = lastElement.heads[asc ? 0 : lastElement.heads.length - 1];
      var startX = starthead.x;
      if (asc) startX += starthead.w - 0.6;
      var endX = endhead.x;
      endX += asc ? endhead.w : 0.6;
      return [startX, endX];
    }
    function calcYPos(average, numElements, stemHeight, asc, firstAveragePitch, lastAveragePitch, isFlat, minPitch, maxPitch, isGrace) {
      var barpos = stemHeight - 2;
      var barminpos = stemHeight - 2;
      var pos = Math.round(asc ? Math.max(average + barpos, maxPitch + barminpos) : Math.min(average - barpos, minPitch - barminpos));
      var slant = calcSlant(firstAveragePitch, lastAveragePitch, numElements, isFlat);
      var startY = pos + Math.floor(slant / 2);
      var endY = pos + Math.floor(-slant / 2);
      if (!isGrace) {
        if (asc && pos < 6) {
          startY = 6;
          endY = 6;
        } else if (!asc && pos > 6) {
          startY = 6;
          endY = 6;
        }
      }
      return [startY, endY];
    }
    function createStems(elems, asc, beam, dy, mainNote) {
      for (var i2 = 0; i2 < elems.length; i2++) {
        var elem = elems[i2];
        if (elem.abcelem.rest)
          continue;
        var isGrace = elem.addExtra ? false : true;
        var parent = isGrace ? mainNote : elem;
        var furthestHead = elem.heads[asc ? 0 : elem.heads.length - 1];
        var ovalDelta = 1 / 5;
        var pitch = furthestHead.pitch + (asc ? ovalDelta : -ovalDelta);
        var dx = asc ? furthestHead.w : 0;
        if (!isGrace)
          dx += furthestHead.dx;
        var x = furthestHead.x + dx;
        var bary = getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, x);
        var lineWidth = asc ? -0.6 : 0.6;
        if (!asc)
          bary -= dy / 2 / spacing.STEP;
        if (isGrace)
          dx += elem.heads[0].dx;
        if (furthestHead.c === "noteheads.slash.quarter") {
          if (asc)
            pitch += 1;
          else
            pitch -= 1;
        }
        var stem = new RelativeElement(null, dx, 0, pitch, {
          "type": "stem",
          "pitch2": bary,
          linewidth: lineWidth
        });
        stem.setX(parent.x);
        parent.addRight(stem);
      }
    }
    function createAdditionalBeams(elems, asc, beam, isGrace, dy) {
      var beams = [];
      var auxBeams = [];
      for (var i2 = 0; i2 < elems.length; i2++) {
        var elem = elems[i2];
        if (elem.abcelem.rest)
          continue;
        var furthestHead = elem.heads[asc ? 0 : elem.heads.length - 1];
        var x = furthestHead.x + (asc ? furthestHead.w : 0);
        var bary = getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, x);
        var sy = asc ? -1.5 : 1.5;
        if (isGrace) sy = sy * 2 / 3;
        var duration = elem.abcelem.duration;
        if (duration === 0) duration = 0.25;
        for (var durlog = getDurlog(duration); durlog < -3; durlog++) {
          var index = -4 - durlog;
          if (auxBeams[index]) {
            auxBeams[index].single = false;
          } else {
            auxBeams[index] = {
              x: x + (asc ? -0.6 : 0),
              y: bary + sy * (index + 1),
              durlog,
              single: true
            };
          }
          if (i2 > 0 && elem.abcelem.beambr && elem.abcelem.beambr <= index + 1) {
            if (!auxBeams[index].split)
              auxBeams[index].split = [auxBeams[index].x];
            var xPos = calcXPos(asc, elems[i2 - 1], elem);
            if (auxBeams[index].split[auxBeams[index].split.length - 1] >= xPos[0]) {
              xPos[0] += elem.w;
            }
            auxBeams[index].split.push(xPos[0]);
            auxBeams[index].split.push(xPos[1]);
          }
        }
        for (var j = auxBeams.length - 1; j >= 0; j--) {
          if (i2 === elems.length - 1 || getDurlog(elems[i2 + 1].abcelem.duration) > -j - 4) {
            var auxBeamEndX = x;
            var auxBeamEndY = bary + sy * (j + 1);
            if (auxBeams[j].single) {
              auxBeamEndX = i2 === 0 ? x + 5 : x - 5;
              auxBeamEndY = getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, auxBeamEndX) + sy * (j + 1);
            }
            var b = { startX: auxBeams[j].x, endX: auxBeamEndX, startY: auxBeams[j].y, endY: auxBeamEndY, dy };
            if (auxBeams[j].split !== void 0) {
              var split = auxBeams[j].split;
              if (b.endX <= split[split.length - 1]) {
                split[split.length - 1] -= elem.w;
              }
              split.push(b.endX);
              b.split = auxBeams[j].split;
            }
            beams.push(b);
            auxBeams = auxBeams.slice(0, j);
          }
        }
      }
      return beams;
    }
    module.exports = layoutBeam;
  }
});

// node_modules/abcjs/src/write/layout/triplet.js
var require_triplet = __commonJS({
  "node_modules/abcjs/src/write/layout/triplet.js"(exports, module) {
    var getBarYAt = require_get_bar_y_at();
    function layoutTriplet(element) {
      if (element.anchor1 && element.anchor2) {
        element.hasBeam = !!element.anchor1.parent.beam && element.anchor1.parent.beam === element.anchor2.parent.beam;
        var beam = element.anchor1.parent.beam;
        if (element.hasBeam && (beam.elems[0] !== element.anchor1.parent || beam.elems[beam.elems.length - 1] !== element.anchor2.parent))
          element.hasBeam = false;
        if (element.hasBeam) {
          var left = isAbove(beam) ? element.anchor1.x + element.anchor1.w : element.anchor1.x;
          element.yTextPos = heightAtMidpoint(left, element.anchor2.x, beam);
          element.yTextPos += isAbove(beam) ? 3 : -2;
          element.xTextPos = xAtMidpoint(left, element.anchor2.x);
          element.top = element.yTextPos + 1;
          element.bottom = element.yTextPos - 2;
          if (isAbove(beam))
            element.endingHeightAbove = 4;
        } else {
          element.startNote = Math.max(element.anchor1.parent.top, 9) + 4;
          element.endNote = Math.max(element.anchor2.parent.top, 9) + 4;
          if (element.anchor1.parent.type === "rest" && element.anchor2.parent.type !== "rest")
            element.startNote = element.endNote;
          else if (element.anchor2.parent.type === "rest" && element.anchor1.parent.type !== "rest")
            element.endNote = element.startNote;
          var max = 0;
          for (var i2 = 0; i2 < element.middleElems.length; i2++) {
            max = Math.max(max, element.middleElems[i2].top);
          }
          max += 4;
          if (max > element.startNote || max > element.endNote) {
            element.startNote = max;
            element.endNote = max;
          }
          if (element.flatBeams) {
            element.startNote = Math.max(element.startNote, element.endNote);
            element.endNote = Math.max(element.startNote, element.endNote);
          }
          element.yTextPos = element.startNote + (element.endNote - element.startNote) / 2;
          element.xTextPos = element.anchor1.x + (element.anchor2.x + element.anchor2.w - element.anchor1.x) / 2;
          element.top = element.yTextPos + 1;
        }
      }
      delete element.middleElems;
      delete element.flatBeams;
    }
    function isAbove(beam) {
      return beam.stemsUp;
    }
    function heightAtMidpoint(startX, endX, beam) {
      if (beam.beams.length === 0)
        return 0;
      beam = beam.beams[0];
      var midPoint = startX + (endX - startX) / 2;
      return getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, midPoint);
    }
    function xAtMidpoint(startX, endX) {
      return startX + (endX - startX) / 2;
    }
    module.exports = layoutTriplet;
  }
});

// node_modules/abcjs/src/write/layout/voice.js
var require_voice = __commonJS({
  "node_modules/abcjs/src/write/layout/voice.js"(exports, module) {
    var layoutBeam = require_beam();
    var getBarYAt = require_get_bar_y_at();
    var layoutTriplet = require_triplet();
    var layoutVoice = function(voice) {
      for (var i2 = 0; i2 < voice.beams.length; i2++) {
        if (voice.beams[i2].type === "BeamElem") {
          layoutBeam(voice.beams[i2]);
          moveDecorations(voice.beams[i2]);
          for (var j = 0; j < voice.beams[i2].elems.length; j++) {
            voice.adjustRange(voice.beams[i2].elems[j]);
          }
        }
      }
      voice.staff.specialY.chordLines = setLaneForChord(voice.children);
      for (i2 = 0; i2 < voice.otherchildren.length; i2++) {
        var child = voice.otherchildren[i2];
        if (child.type === "TripletElem") {
          layoutTriplet(child);
          voice.adjustRange(child);
        }
      }
      voice.staff.top = Math.max(voice.staff.top, voice.top);
      voice.staff.bottom = Math.min(voice.staff.bottom, voice.bottom);
    };
    function moveDecorations(beam) {
      var padding = 1.5;
      for (var ch = 0; ch < beam.elems.length; ch++) {
        var child = beam.elems[ch];
        if (child.top) {
          var top = yAtNote(child, beam);
          for (var i2 = 0; i2 < child.children.length; i2++) {
            var el = child.children[i2];
            if (el.klass === "ornament" && el.position !== "below") {
              if (el.bottom - padding < top) {
                var distance = top - el.bottom + padding;
                el.bottom += distance;
                el.top += distance;
                el.pitch += distance;
                top = child.top = el.top;
              }
            }
          }
        }
      }
    }
    function placeInLane(rightMost, relElem) {
      var xCoords = relElem.getChordDim();
      if (xCoords) {
        for (var i2 = 0; i2 < rightMost.length; i2++) {
          var fits = rightMost[i2] < xCoords.left;
          if (fits) {
            if (i2 > 0)
              relElem.putChordInLane(i2);
            rightMost[i2] = xCoords.right;
            return;
          }
        }
        rightMost.push(xCoords.right);
        relElem.putChordInLane(rightMost.length - 1);
      }
    }
    function setLaneForChord(absElems) {
      var rightMostAbove = [0];
      var rightMostBelow = [0];
      var i2;
      var j;
      var relElem;
      for (i2 = 0; i2 < absElems.length; i2++) {
        for (j = 0; j < absElems[i2].children.length; j++) {
          relElem = absElems[i2].children[j];
          if (relElem.chordHeightAbove) {
            placeInLane(rightMostAbove, relElem);
          }
        }
        for (j = absElems[i2].children.length - 1; j >= 0; j--) {
          relElem = absElems[i2].children[j];
          if (relElem.chordHeightBelow) {
            placeInLane(rightMostBelow, relElem);
          }
        }
      }
      if (rightMostAbove.length > 1 || rightMostBelow.length > 1)
        setLane(absElems, rightMostAbove.length, rightMostBelow.length);
      return { above: rightMostAbove.length, below: rightMostBelow.length };
    }
    function numAnnotationsBelow(absElem) {
      var count = 0;
      for (var j = 0; j < absElem.children.length; j++) {
        var relElem = absElem.children[j];
        if (relElem.chordHeightBelow)
          count++;
      }
      return count;
    }
    function setLane(absElems, numLanesAbove, numLanesBelow) {
      for (var i2 = 0; i2 < absElems.length; i2++) {
        var below = numAnnotationsBelow(absElems[i2]);
        for (var j = 0; j < absElems[i2].children.length; j++) {
          var relElem = absElems[i2].children[j];
          if (relElem.chordHeightAbove) {
            relElem.invertLane(numLanesAbove);
          }
        }
      }
    }
    function yAtNote(element, beam) {
      beam = beam.beams[0];
      return getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, element.x);
    }
    module.exports = layoutVoice;
  }
});

// node_modules/abcjs/src/write/layout/set-upper-and-lower-elements.js
var require_set_upper_and_lower_elements = __commonJS({
  "node_modules/abcjs/src/write/layout/set-upper-and-lower-elements.js"(exports, module) {
    var spacing = require_spacing();
    var setUpperAndLowerElements = function(renderer, staffGroup) {
      var lastStaffBottom;
      for (var i2 = 0; i2 < staffGroup.staffs.length; i2++) {
        var staff = staffGroup.staffs[i2];
        var positionY = {
          tempoHeightAbove: 0,
          partHeightAbove: 0,
          volumeHeightAbove: 0,
          dynamicHeightAbove: 0,
          endingHeightAbove: 0,
          chordHeightAbove: 0,
          lyricHeightAbove: 0,
          lyricHeightBelow: 0,
          chordHeightBelow: 0,
          volumeHeightBelow: 0,
          dynamicHeightBelow: 0
        };
        if (renderer.showDebug && renderer.showDebug.indexOf("box") >= 0) {
          staff.originalTop = staff.top;
          staff.originalBottom = staff.bottom;
        }
        incTop(staff, positionY, "lyricHeightAbove");
        incTop(staff, positionY, "chordHeightAbove", staff.specialY.chordLines.above);
        if (staff.specialY.endingHeightAbove) {
          if (staff.specialY.chordHeightAbove)
            staff.top += 2;
          else
            staff.top += staff.specialY.endingHeightAbove + margin;
          positionY.endingHeightAbove = staff.top;
        }
        if (staff.specialY.dynamicHeightAbove && staff.specialY.volumeHeightAbove) {
          staff.top += Math.max(staff.specialY.dynamicHeightAbove, staff.specialY.volumeHeightAbove) + margin;
          positionY.dynamicHeightAbove = staff.top;
          positionY.volumeHeightAbove = staff.top;
        } else {
          incTop(staff, positionY, "dynamicHeightAbove");
          incTop(staff, positionY, "volumeHeightAbove");
        }
        incTop(staff, positionY, "partHeightAbove");
        incTop(staff, positionY, "tempoHeightAbove");
        if (staff.specialY.lyricHeightBelow) {
          staff.specialY.lyricHeightBelow += renderer.spacing.vocal / spacing.STEP;
          positionY.lyricHeightBelow = staff.bottom;
          staff.bottom -= staff.specialY.lyricHeightBelow + margin;
        }
        if (staff.specialY.chordHeightBelow) {
          positionY.chordHeightBelow = staff.bottom;
          var hgt = staff.specialY.chordHeightBelow;
          if (staff.specialY.chordLines.below)
            hgt *= staff.specialY.chordLines.below;
          staff.bottom -= hgt + margin;
        }
        if (staff.specialY.volumeHeightBelow && staff.specialY.dynamicHeightBelow) {
          positionY.volumeHeightBelow = staff.bottom;
          positionY.dynamicHeightBelow = staff.bottom;
          staff.bottom -= Math.max(staff.specialY.volumeHeightBelow, staff.specialY.dynamicHeightBelow) + margin;
        } else if (staff.specialY.volumeHeightBelow) {
          positionY.volumeHeightBelow = staff.bottom;
          staff.bottom -= staff.specialY.volumeHeightBelow + margin;
        } else if (staff.specialY.dynamicHeightBelow) {
          positionY.dynamicHeightBelow = staff.bottom;
          staff.bottom -= staff.specialY.dynamicHeightBelow + margin;
        }
        if (renderer.showDebug && renderer.showDebug.indexOf("box") >= 0)
          staff.positionY = positionY;
        for (var j = 0; j < staff.voices.length; j++) {
          var voice = staffGroup.voices[staff.voices[j]];
          setUpperAndLowerVoiceElements(positionY, voice, renderer.spacing);
        }
        if (lastStaffBottom !== void 0) {
          var thisStaffTop = staff.top - 10;
          var forcedSpacingBetween = lastStaffBottom + thisStaffTop;
          var minSpacingInPitches = renderer.spacing.systemStaffSeparation / spacing.STEP;
          var addedSpace = minSpacingInPitches - forcedSpacingBetween;
          if (addedSpace > 0)
            staff.top += addedSpace;
        }
        staff.top += renderer.spacing.staffTopMargin / spacing.STEP;
        lastStaffBottom = 2 - staff.bottom;
      }
    };
    var margin = 1;
    function incTop(staff, positionY, item, count) {
      if (staff.specialY[item]) {
        var height = staff.specialY[item];
        if (count)
          height *= count;
        staff.top += height + margin;
        positionY[item] = staff.top;
      }
    }
    function setUpperAndLowerVoiceElements(positionY, voice, spacing2) {
      var i2;
      var abselem;
      for (i2 = 0; i2 < voice.children.length; i2++) {
        abselem = voice.children[i2];
        setUpperAndLowerAbsoluteElements(positionY, abselem, spacing2);
      }
      for (i2 = 0; i2 < voice.otherchildren.length; i2++) {
        abselem = voice.otherchildren[i2];
        switch (abselem.type) {
          case "CrescendoElem":
            setUpperAndLowerCrescendoElements(positionY, abselem);
            break;
          case "DynamicDecoration":
            setUpperAndLowerDynamicElements(positionY, abselem);
            break;
          case "EndingElem":
            setUpperAndLowerEndingElements(positionY, abselem);
            break;
          case "TieElem":
            var yBounds = abselem.getYBounds();
            voice.staff.top = Math.max(voice.staff.top, yBounds[0]);
            voice.staff.top = Math.max(voice.staff.top, yBounds[1]);
            voice.staff.bottom = Math.min(voice.staff.bottom, yBounds[0]);
            voice.staff.bottom = Math.min(voice.staff.bottom, yBounds[1]);
            break;
        }
      }
    }
    function setUpperAndLowerAbsoluteElements(specialYResolved, element, spacing2) {
      for (var i2 = 0; i2 < element.children.length; i2++) {
        var child = element.children[i2];
        for (var key in element.specialY) {
          if (element.specialY.hasOwnProperty(key)) {
            if (child[key]) {
              child.pitch = specialYResolved[key];
              if (child.top === void 0) {
                if (child.type === "TempoElement") {
                  setUpperAndLowerTempoElement(specialYResolved, child);
                } else {
                  setUpperAndLowerRelativeElements(specialYResolved, child, spacing2);
                }
                element.pushTop(child.top);
                element.pushBottom(child.bottom);
              }
            }
          }
        }
      }
    }
    function setUpperAndLowerCrescendoElements(positionY, element) {
      if (element.dynamicHeightAbove)
        element.pitch = positionY.dynamicHeightAbove;
      else
        element.pitch = positionY.dynamicHeightBelow;
    }
    function setUpperAndLowerDynamicElements(positionY, element) {
      if (element.volumeHeightAbove)
        element.pitch = positionY.volumeHeightAbove;
      else
        element.pitch = positionY.volumeHeightBelow;
    }
    function setUpperAndLowerEndingElements(positionY, element) {
      element.pitch = positionY.endingHeightAbove - 2;
    }
    function setUpperAndLowerTempoElement(positionY, element) {
      element.pitch = positionY.tempoHeightAbove;
      element.top = positionY.tempoHeightAbove;
      element.bottom = positionY.tempoHeightAbove;
      if (element.note) {
        var tempoPitch = element.pitch - element.totalHeightInPitches + 1;
        element.note.top = tempoPitch;
        element.note.bottom = tempoPitch;
        for (var i2 = 0; i2 < element.note.children.length; i2++) {
          var child = element.note.children[i2];
          child.top += tempoPitch;
          child.bottom += tempoPitch;
          child.pitch += tempoPitch;
          if (child.pitch2 !== void 0)
            child.pitch2 += tempoPitch;
        }
      }
    }
    function setUpperAndLowerRelativeElements(positionY, element, renderSpacing) {
      switch (element.type) {
        case "part":
          element.top = positionY.partHeightAbove + element.height;
          element.bottom = positionY.partHeightAbove;
          break;
        case "text":
        case "chord":
          if (element.chordHeightAbove) {
            element.top = positionY.chordHeightAbove;
            element.bottom = positionY.chordHeightAbove;
          } else {
            element.top = positionY.chordHeightBelow;
            element.bottom = positionY.chordHeightBelow;
          }
          break;
        case "lyric":
          if (element.lyricHeightAbove) {
            element.top = positionY.lyricHeightAbove;
            element.bottom = positionY.lyricHeightAbove;
          } else {
            element.top = positionY.lyricHeightBelow + renderSpacing.vocal / spacing.STEP;
            element.bottom = positionY.lyricHeightBelow + renderSpacing.vocal / spacing.STEP;
            element.pitch -= renderSpacing.vocal / spacing.STEP;
          }
          break;
        case "debug":
          element.top = positionY.chordHeightAbove;
          element.bottom = positionY.chordHeightAbove;
          break;
      }
      if (element.pitch === void 0 || element.top === void 0)
        console.error("RelativeElement position not set.", element.type, element.pitch, element.top, positionY);
    }
    module.exports = setUpperAndLowerElements;
  }
});

// node_modules/abcjs/src/write/layout/voice-elements.js
var require_voice_elements = __commonJS({
  "node_modules/abcjs/src/write/layout/voice-elements.js"(exports, module) {
    var VoiceElement = function VoiceElements() {
    };
    VoiceElement.beginLayout = function(startx, voice) {
      voice.i = 0;
      voice.durationindex = 0;
      voice.startx = startx;
      voice.minx = startx;
      voice.nextx = startx;
      voice.spacingduration = 0;
    };
    VoiceElement.layoutEnded = function(voice) {
      return voice.i >= voice.children.length;
    };
    VoiceElement.getNextX = function(voice) {
      return Math.max(voice.minx, voice.nextx);
    };
    VoiceElement.getSpacingUnits = function(voice) {
      return Math.sqrt(voice.spacingduration * 8);
    };
    VoiceElement.layoutOneItem = function(x, spacing, voice, minPadding, firstVoice) {
      var child = voice.children[voice.i];
      if (!child) return 0;
      var er = x - voice.minx;
      var pad = voice.durationindex + child.duration > 0 ? minPadding : 0;
      if (child.abcelem.el_type === "note" && !child.abcelem.rest && voice.voicenumber !== 0 && firstVoice) {
        var firstChild = firstVoice.children[firstVoice.i];
        var overlaps = firstChild && (child.abcelem.maxpitch <= firstChild.abcelem.maxpitch + 1 && child.abcelem.maxpitch >= firstChild.abcelem.minpitch - 1 || child.abcelem.minpitch <= firstChild.abcelem.maxpitch + 1 && child.abcelem.minpitch >= firstChild.abcelem.minpitch - 1);
        if (overlaps && child.abcelem.minpitch === firstChild.abcelem.minpitch && child.abcelem.maxpitch === firstChild.abcelem.maxpitch && firstChild.heads && firstChild.heads.length > 0 && child.heads && child.heads.length > 0 && firstChild.heads[0].c === child.heads[0].c)
          overlaps = false;
        if (overlaps) {
          var firstChildNoteWidth = firstChild.heads && firstChild.heads.length > 0 ? firstChild.heads[0].realWidth : firstChild.fixed.w;
          if (!child.adjustedWidth)
            child.adjustedWidth = firstChildNoteWidth + child.w;
          child.w = child.adjustedWidth;
          for (var j = 0; j < child.children.length; j++) {
            var relativeChild = child.children[j];
            if (relativeChild.name.indexOf("accidental") < 0) {
              if (!relativeChild.adjustedWidth)
                relativeChild.adjustedWidth = relativeChild.dx + firstChildNoteWidth;
              relativeChild.dx = relativeChild.adjustedWidth;
            }
          }
        }
      }
      var extraWidth = getExtraWidth(child, pad);
      if (er < extraWidth) {
        if (voice.i === 0 || child.type !== "bar" || voice.children[voice.i - 1].type !== "part" && voice.children[voice.i - 1].type !== "tempo")
          x += extraWidth - er;
      }
      child.setX(x);
      voice.spacingduration = child.duration;
      voice.minx = x + getMinWidth(child);
      if (voice.i !== voice.children.length - 1) voice.minx += child.minspacing;
      this.updateNextX(x, spacing, voice);
      return x;
    };
    VoiceElement.shiftRight = function(dx, voice) {
      var child = voice.children[voice.i];
      if (!child) return;
      child.setX(child.x + dx);
      voice.minx += dx;
      voice.nextx += dx;
    };
    VoiceElement.updateNextX = function(x, spacing, voice) {
      voice.nextx = x + spacing * this.getSpacingUnits(voice);
    };
    VoiceElement.updateIndices = function(voice) {
      if (!this.layoutEnded(voice)) {
        voice.durationindex += voice.children[voice.i].duration;
        if (voice.children[voice.i].type === "bar") voice.durationindex = Math.round(voice.durationindex * 64) / 64;
        voice.i++;
      }
    };
    function getExtraWidth(child, minPadding) {
      var padding = 0;
      if (child.type === "note" || child.type === "bar")
        padding = minPadding;
      return -child.extraw + padding;
    }
    function getMinWidth(child) {
      return child.w;
    }
    module.exports = VoiceElement;
  }
});

// node_modules/abcjs/src/write/layout/staff-group.js
var require_staff_group = __commonJS({
  "node_modules/abcjs/src/write/layout/staff-group.js"(exports, module) {
    var layoutVoiceElements = require_voice_elements();
    function checkLastBarX(voices) {
      var maxX = 0;
      for (var i2 = 0; i2 < voices.length; i2++) {
        var curVoice = voices[i2];
        if (curVoice.children.length > 0) {
          var lastChild = curVoice.children.length - 1;
          var maxChild = curVoice.children[lastChild];
          if (maxChild.abcelem.el_type === "bar") {
            var barX = maxChild.children[0].x;
            if (barX > maxX) {
              maxX = barX;
            } else {
              maxChild.children[0].x = maxX;
            }
          }
        }
      }
    }
    var layoutStaffGroup = function(spacing, minPadding, debug, staffGroup, leftEdge) {
      var epsilon = 1e-7;
      var spacingunits = 0;
      var minspace = 1e3;
      var x = leftEdge;
      staffGroup.startx = x;
      var i2;
      var currentduration = 0;
      if (debug) console.log("init layout", spacing);
      for (i2 = 0; i2 < staffGroup.voices.length; i2++) {
        layoutVoiceElements.beginLayout(x, staffGroup.voices[i2]);
      }
      var spacingunit = 0;
      while (!finished(staffGroup.voices)) {
        currentduration = null;
        for (i2 = 0; i2 < staffGroup.voices.length; i2++) {
          if (!layoutVoiceElements.layoutEnded(staffGroup.voices[i2]) && (!currentduration || getDurationIndex(staffGroup.voices[i2]) < currentduration))
            currentduration = getDurationIndex(staffGroup.voices[i2]);
        }
        var currentvoices = [];
        var othervoices = [];
        for (i2 = 0; i2 < staffGroup.voices.length; i2++) {
          var durationIndex = getDurationIndex(staffGroup.voices[i2]);
          if (durationIndex - currentduration > epsilon) {
            othervoices.push(staffGroup.voices[i2]);
          } else {
            currentvoices.push(staffGroup.voices[i2]);
          }
        }
        spacingunit = 0;
        var spacingduration = 0;
        for (i2 = 0; i2 < currentvoices.length; i2++) {
          if (layoutVoiceElements.getNextX(currentvoices[i2]) > x) {
            x = layoutVoiceElements.getNextX(currentvoices[i2]);
            spacingunit = layoutVoiceElements.getSpacingUnits(currentvoices[i2]);
            spacingduration = currentvoices[i2].spacingduration;
          }
        }
        spacingunits += spacingunit;
        minspace = Math.min(minspace, spacingunit);
        if (debug) console.log("currentduration: ", currentduration, spacingunits, minspace);
        var lastTopVoice = void 0;
        for (i2 = 0; i2 < currentvoices.length; i2++) {
          var v2 = currentvoices[i2];
          if (v2.voicenumber === 0)
            lastTopVoice = i2;
          var topVoice = lastTopVoice !== void 0 && currentvoices[lastTopVoice].voicenumber !== v2.voicenumber ? currentvoices[lastTopVoice] : void 0;
          if (!isSameStaff(v2, topVoice))
            topVoice = void 0;
          var voicechildx = layoutVoiceElements.layoutOneItem(x, spacing, v2, minPadding, topVoice);
          var dx = voicechildx - x;
          if (dx > 0) {
            x = voicechildx;
            for (var j = 0; j < i2; j++) {
              layoutVoiceElements.shiftRight(dx, currentvoices[j]);
            }
          }
        }
        for (i2 = 0; i2 < othervoices.length; i2++) {
          othervoices[i2].spacingduration -= spacingduration;
          layoutVoiceElements.updateNextX(x, spacing, othervoices[i2]);
        }
        for (i2 = 0; i2 < currentvoices.length; i2++) {
          var voice = currentvoices[i2];
          layoutVoiceElements.updateIndices(voice);
        }
      }
      for (i2 = 0; i2 < staffGroup.voices.length; i2++) {
        if (layoutVoiceElements.getNextX(staffGroup.voices[i2]) > x) {
          x = layoutVoiceElements.getNextX(staffGroup.voices[i2]);
          spacingunit = layoutVoiceElements.getSpacingUnits(staffGroup.voices[i2]);
        }
      }
      checkLastBarX(staffGroup.voices);
      spacingunits += spacingunit;
      staffGroup.setWidth(x);
      return { spacingUnits: spacingunits, minSpace: minspace };
    };
    function finished(voices) {
      for (var i2 = 0; i2 < voices.length; i2++) {
        if (!layoutVoiceElements.layoutEnded(voices[i2])) return false;
      }
      return true;
    }
    function getDurationIndex(element) {
      return element.durationindex - (element.children[element.i] && element.children[element.i].duration > 0 ? 0 : 5e-7);
    }
    function isSameStaff(voice1, voice2) {
      if (!voice1 || !voice1.staff || !voice1.staff.voices || voice1.staff.voices.length === 0)
        return false;
      if (!voice2 || !voice2.staff || !voice2.staff.voices || voice2.staff.voices.length === 0)
        return false;
      return voice1.staff.voices[0] === voice2.staff.voices[0];
    }
    module.exports = layoutStaffGroup;
  }
});

// node_modules/abcjs/src/write/layout/get-left-edge-of-staff.js
var require_get_left_edge_of_staff = __commonJS({
  "node_modules/abcjs/src/write/layout/get-left-edge-of-staff.js"(exports, module) {
    function getLeftEdgeOfStaff(renderer, getTextSize, voices, brace, bracket) {
      var x = renderer.padding.left;
      var voiceheaderw = 0;
      var i2;
      var size;
      for (i2 = 0; i2 < voices.length; i2++) {
        if (voices[i2].header) {
          size = getTextSize.calc(voices[i2].header, "voicefont", "");
          voiceheaderw = Math.max(voiceheaderw, size.width);
        }
      }
      voiceheaderw = addBraceSize(voiceheaderw, brace, getTextSize);
      voiceheaderw = addBraceSize(voiceheaderw, bracket, getTextSize);
      if (voiceheaderw) {
        var sizeW = getTextSize.calc("A", "voicefont", "");
        voiceheaderw += sizeW.width;
      }
      x += voiceheaderw;
      var ofs = 0;
      ofs = setBraceLocation(brace, x, ofs);
      ofs = setBraceLocation(bracket, x, ofs);
      return x + ofs;
    }
    function addBraceSize(voiceheaderw, brace, getTextSize) {
      if (brace) {
        for (var i2 = 0; i2 < brace.length; i2++) {
          if (brace[i2].header) {
            var size = getTextSize.calc(brace[i2].header, "voicefont", "");
            voiceheaderw = Math.max(voiceheaderw, size.width);
          }
        }
      }
      return voiceheaderw;
    }
    function setBraceLocation(brace, x, ofs) {
      if (brace) {
        for (var i2 = 0; i2 < brace.length; i2++) {
          setLocation(x, brace[i2]);
          ofs = Math.max(ofs, brace[i2].getWidth());
        }
      }
      return ofs;
    }
    function setLocation(x, element) {
      element.x = x;
    }
    module.exports = getLeftEdgeOfStaff;
  }
});

// node_modules/abcjs/src/write/layout/layout-in-grid.js
var require_layout_in_grid = __commonJS({
  "node_modules/abcjs/src/write/layout/layout-in-grid.js"(exports, module) {
    var getLeftEdgeOfStaff = require_get_left_edge_of_staff();
    function layoutInGrid(renderer, staffGroup, timeBasedLayout) {
      var leftEdge = getLeftEdgeOfStaff(renderer, staffGroup.getTextSize, staffGroup.voices, staffGroup.brace, staffGroup.bracket);
      var ret = getTotalDuration(staffGroup, timeBasedLayout.minPadding);
      var totalDuration = ret.totalDuration;
      var minSpacing = ret.minSpacing;
      var totalWidth = minSpacing * totalDuration;
      if (timeBasedLayout.minWidth)
        totalWidth = Math.max(totalWidth, timeBasedLayout.minWidth);
      var leftAlignPadding = timeBasedLayout.minPadding ? timeBasedLayout.minPadding / 2 : 2;
      staffGroup.startx = leftEdge;
      staffGroup.w = totalWidth + leftEdge;
      for (var i2 = 0; i2 < staffGroup.voices.length; i2++) {
        var voice = staffGroup.voices[i2];
        voice.startx = leftEdge;
        voice.w = totalWidth + leftEdge;
        var x = leftEdge;
        var afterFixedLeft = false;
        var durationUnit = 0;
        for (var j = 0; j < voice.children.length; j++) {
          var child = voice.children[j];
          if (!afterFixedLeft) {
            if (child.duration !== 0) {
              afterFixedLeft = true;
              durationUnit = (totalWidth + leftEdge - x) / totalDuration;
              staffGroup.gridStart = x;
            } else {
              child.x = x;
              x += child.w + child.minspacing;
            }
          }
          if (afterFixedLeft) {
            if (timeBasedLayout.align === "center")
              child.x = x + child.duration * durationUnit / 2 - child.w / 2;
            else {
              if (child.duration === 0) {
                child.x = x + 1 - child.w;
              } else {
                child.x = x + leftAlignPadding - child.extraw;
              }
            }
            x += child.duration * durationUnit;
          }
          for (var k = 0; k < child.children.length; k++) {
            var grandchild = child.children[k];
            var dx = grandchild.dx ? grandchild.dx : 0;
            grandchild.x = child.x + dx;
          }
        }
        staffGroup.gridEnd = x;
      }
      return totalWidth;
    }
    function getTotalDuration(staffGroup, timeBasedLayout) {
      var maxSpacing = 0;
      var maxCount = 0;
      for (var i2 = 0; i2 < staffGroup.voices.length; i2++) {
        var count = 0;
        var voice = staffGroup.voices[i2];
        for (var j = 0; j < voice.children.length; j++) {
          var element = voice.children[j];
          count += element.duration;
          if (element.duration) {
            var width = (element.w + timeBasedLayout) / element.duration;
            maxSpacing = Math.max(maxSpacing, width);
          }
        }
        maxCount = Math.max(maxCount, count);
      }
      return { totalDuration: maxCount, minSpacing: maxSpacing };
    }
    module.exports = layoutInGrid;
  }
});

// node_modules/abcjs/src/write/layout/layout.js
var require_layout = __commonJS({
  "node_modules/abcjs/src/write/layout/layout.js"(exports, module) {
    var layoutVoice = require_voice();
    var setUpperAndLowerElements = require_set_upper_and_lower_elements();
    var layoutStaffGroup = require_staff_group();
    var getLeftEdgeOfStaff = require_get_left_edge_of_staff();
    var layoutInGrid = require_layout_in_grid();
    var layout = function(renderer, abctune, width, space, expandToWidest, timeBasedLayout) {
      var i2;
      var abcLine;
      var maxWidth = width;
      for (i2 = 0; i2 < abctune.lines.length; i2++) {
        abcLine = abctune.lines[i2];
        if (abcLine.staff) {
          var thisWidth;
          if (timeBasedLayout !== void 0)
            thisWidth = layoutInGrid(renderer, abcLine.staffGroup, timeBasedLayout);
          else
            thisWidth = setXSpacing(renderer, maxWidth, space, abcLine.staffGroup, abctune.formatting, i2 === abctune.lines.length - 1, false);
          if (Math.round(thisWidth) > Math.round(maxWidth)) {
            maxWidth = thisWidth;
            if (expandToWidest)
              i2 = -1;
          }
        }
      }
      for (i2 = 0; i2 < abctune.lines.length; i2++) {
        abcLine = abctune.lines[i2];
        if (abcLine.staffGroup && abcLine.staffGroup.voices) {
          for (var j = 0; j < abcLine.staffGroup.voices.length; j++)
            layoutVoice(abcLine.staffGroup.voices[j]);
          setUpperAndLowerElements(renderer, abcLine.staffGroup);
        }
      }
      for (i2 = 0; i2 < abctune.lines.length; i2++) {
        abcLine = abctune.lines[i2];
        if (abcLine.staffGroup) {
          abcLine.staffGroup.setHeight();
        }
      }
      return maxWidth;
    };
    var setXSpacing = function(renderer, width, space, staffGroup, formatting, isLastLine, debug) {
      var leftEdge = getLeftEdgeOfStaff(renderer, staffGroup.getTextSize, staffGroup.voices, staffGroup.brace, staffGroup.bracket);
      var newspace = space;
      for (var it = 0; it < 8; it++) {
        var ret = layoutStaffGroup(newspace, renderer.minPadding, debug, staffGroup, leftEdge);
        newspace = calcHorizontalSpacing(isLastLine, formatting.stretchlast, width + renderer.padding.left, staffGroup.w, newspace, ret.spacingUnits, ret.minSpace, renderer.padding.left + renderer.padding.right);
        if (debug)
          console.log("setXSpace", it, staffGroup.w, newspace, staffGroup.minspace);
        if (newspace === null) break;
      }
      centerWholeRests(staffGroup.voices);
      return staffGroup.w - leftEdge;
    };
    function calcHorizontalSpacing(isLastLine, stretchLast, targetWidth, lineWidth, spacing, spacingUnits, minSpace, padding) {
      if (isLastLine) {
        if (stretchLast === void 0) {
          if (lineWidth / targetWidth < 0.66) return null;
        } else {
          var lack = 1 - (lineWidth + padding) / targetWidth;
          var stretch = lack < stretchLast;
          if (!stretch) return null;
        }
      }
      if (Math.abs(targetWidth - lineWidth) < 2) return null;
      var relSpace = spacingUnits * spacing;
      var constSpace = lineWidth - relSpace;
      if (spacingUnits > 0) {
        spacing = (targetWidth - constSpace) / spacingUnits;
        if (spacing * minSpace > 50) {
          spacing = 50 / minSpace;
        }
        return spacing;
      }
      return null;
    }
    function centerWholeRests(voices) {
      for (var i2 = 0; i2 < voices.length; i2++) {
        var voice = voices[i2];
        for (var j = 1; j < voice.children.length - 1; j++) {
          var absElem = voice.children[j];
          if (absElem.abcelem.rest && (absElem.abcelem.rest.type === "whole" || absElem.abcelem.rest.type === "multimeasure")) {
            var before = voice.children[j - 1];
            var after = voice.children[j + 1];
            absElem.center(before, after);
          }
        }
      }
    }
    module.exports = layout;
  }
});

// node_modules/abcjs/src/write/helpers/classes.js
var require_classes = __commonJS({
  "node_modules/abcjs/src/write/helpers/classes.js"(exports, module) {
    var Classes = function Classes2(options) {
      this.shouldAddClasses = options.shouldAddClasses;
      this.reset();
    };
    Classes.prototype.reset = function() {
      this.lineNumber = null;
      this.voiceNumber = null;
      this.measureNumber = null;
      this.measureTotalPerLine = [];
      this.noteNumber = null;
    };
    Classes.prototype.incrLine = function() {
      if (this.lineNumber === null)
        this.lineNumber = 0;
      else
        this.lineNumber++;
      this.voiceNumber = null;
      this.measureNumber = null;
      this.noteNumber = null;
    };
    Classes.prototype.incrVoice = function() {
      if (this.voiceNumber === null)
        this.voiceNumber = 0;
      else
        this.voiceNumber++;
      this.measureNumber = null;
      this.noteNumber = null;
    };
    Classes.prototype.isInMeasure = function() {
      return this.measureNumber !== null;
    };
    Classes.prototype.newMeasure = function() {
      if (this.measureNumber)
        this.measureTotalPerLine[this.lineNumber] = this.measureNumber;
      this.measureNumber = null;
      this.noteNumber = null;
    };
    Classes.prototype.startMeasure = function() {
      this.measureNumber = 0;
      this.noteNumber = 0;
    };
    Classes.prototype.incrMeasure = function() {
      this.measureNumber++;
      this.noteNumber = 0;
    };
    Classes.prototype.incrNote = function() {
      this.noteNumber++;
    };
    Classes.prototype.measureTotal = function() {
      var total = 0;
      for (var i2 = 0; i2 < this.lineNumber; i2++)
        total += this.measureTotalPerLine[i2] ? this.measureTotalPerLine[i2] : 0;
      if (this.measureNumber)
        total += this.measureNumber;
      return total;
    };
    Classes.prototype.getCurrent = function(c) {
      return {
        line: this.lineNumber,
        measure: this.measureNumber,
        measureTotal: this.measureTotal(),
        voice: this.voiceNumber,
        note: this.noteNumber
      };
    };
    Classes.prototype.generate = function(c) {
      if (!this.shouldAddClasses)
        return "";
      var ret = [];
      if (c && c.length > 0) ret.push(c);
      if (c === "abcjs-tab-number")
        return ret.join(" ");
      if (c === "text instrument-name")
        return "abcjs-text abcjs-instrument-name";
      if (this.lineNumber !== null) ret.push("l" + this.lineNumber);
      if (this.measureNumber !== null) ret.push("m" + this.measureNumber);
      if (this.measureNumber !== null) ret.push("mm" + this.measureTotal());
      if (this.voiceNumber !== null) ret.push("v" + this.voiceNumber);
      if (c && (c.indexOf("note") >= 0 || c.indexOf("rest") >= 0 || c.indexOf("lyric") >= 0) && this.noteNumber !== null) ret.push("n" + this.noteNumber);
      if (ret.length > 0) {
        ret = ret.join(" ");
        ret = ret.split(" ");
        for (var i2 = 0; i2 < ret.length; i2++) {
          if (ret[i2].indexOf("abcjs-") !== 0 && ret[i2].length > 0)
            ret[i2] = "abcjs-" + ret[i2];
        }
      }
      return ret.join(" ");
    };
    module.exports = Classes;
  }
});

// node_modules/abcjs/src/write/helpers/get-font-and-attr.js
var require_get_font_and_attr = __commonJS({
  "node_modules/abcjs/src/write/helpers/get-font-and-attr.js"(exports, module) {
    var GetFontAndAttr = function GetFontAndAttr2(formatting, classes) {
      this.formatting = formatting;
      this.classes = classes;
    };
    GetFontAndAttr.prototype.updateFonts = function(fontOverrides) {
      if (fontOverrides.gchordfont)
        this.formatting.gchordfont = fontOverrides.gchordfont;
      if (fontOverrides.tripletfont)
        this.formatting.tripletfont = fontOverrides.tripletfont;
      if (fontOverrides.annotationfont)
        this.formatting.annotationfont = fontOverrides.annotationfont;
      if (fontOverrides.vocalfont)
        this.formatting.vocalfont = fontOverrides.vocalfont;
    };
    GetFontAndAttr.prototype.getFamily = function(type) {
      if (type[0] === '"' && type[type.length - 1] === '"') {
        return type.substring(1, type.length - 1);
      }
      return type;
    };
    GetFontAndAttr.prototype.calc = function(type, klass) {
      var font;
      if (typeof type === "string") {
        font = this.formatting[type];
        if (font)
          font = { face: font.face, size: Math.round(font.size * 4 / 3), decoration: font.decoration, style: font.style, weight: font.weight, box: font.box };
        else
          font = { face: "Arial", size: Math.round(12 * 4 / 3), decoration: "underline", style: "normal", weight: "normal" };
      } else
        font = { face: type.face, size: Math.round(type.size * 4 / 3), decoration: type.decoration, style: type.style, weight: type.weight, box: type.box };
      var paddingPercent = this.formatting.fontboxpadding ? this.formatting.fontboxpadding : 0.1;
      font.padding = font.size * paddingPercent;
      var attr = {
        "font-size": font.size,
        "font-style": font.style,
        "font-family": this.getFamily(font.face),
        "font-weight": font.weight,
        "text-decoration": font.decoration,
        "class": this.classes.generate(klass)
      };
      return { font, attr };
    };
    module.exports = GetFontAndAttr;
  }
});

// node_modules/abcjs/src/write/helpers/get-text-size.js
var require_get_text_size = __commonJS({
  "node_modules/abcjs/src/write/helpers/get-text-size.js"(exports, module) {
    var GetTextSize = function GetTextSize2(getFontAndAttr, svg) {
      this.getFontAndAttr = getFontAndAttr;
      this.svg = svg;
    };
    GetTextSize.prototype.updateFonts = function(fontOverrides) {
      this.getFontAndAttr.updateFonts(fontOverrides);
    };
    GetTextSize.prototype.attr = function(type, klass) {
      return this.getFontAndAttr.calc(type, klass);
    };
    GetTextSize.prototype.getFamily = function(type) {
      if (type[0] === '"' && type[type.length - 1] === '"') {
        return type.substring(1, type.length - 1);
      }
      return type;
    };
    GetTextSize.prototype.calc = function(text, type, klass, el) {
      var hash;
      if (typeof type === "string")
        hash = this.attr(type, klass);
      else {
        hash = {
          font: {
            face: type.face,
            size: type.size,
            decoration: type.decoration,
            style: type.style,
            weight: type.weight
          },
          attr: {
            "font-size": type.size,
            "font-style": type.style,
            "font-family": this.getFamily(type.face),
            "font-weight": type.weight,
            "text-decoration": type.decoration,
            "class": this.getFontAndAttr.classes.generate(klass)
          }
        };
      }
      var size = this.svg.getTextSize(text, hash.attr, el);
      if (hash.font.box) {
        return { height: size.height + hash.font.padding * 4, width: size.width + hash.font.padding * 4 };
      }
      return size;
    };
    GetTextSize.prototype.baselineToCenter = function(text, type, klass, index, total) {
      var height = this.calc(text, type, klass).height;
      var fontHeight = this.attr(type, klass).font.size;
      return height * 0.5 + (total - index - 2) * fontHeight;
    };
    module.exports = GetTextSize;
  }
});

// node_modules/abcjs/src/write/draw/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/abcjs/src/write/draw/sprintf.js"(exports, module) {
    var sprintf = function() {
      var i2 = 0, a, f = arguments[i2++], o = [], m, p, c, x;
      while (f) {
        if (m = /^[^\x25]+/.exec(f)) o.push(m[0]);
        else if (m = /^\x25{2}/.exec(f)) o.push("%");
        else if (m = /^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(f)) {
          if ((a = arguments[m[1] || i2++]) == null || a == void 0) throw "Too few arguments.";
          if (/[^s]/.test(m[7]) && typeof a != "number")
            throw "Expecting number but found " + typeof a;
          switch (m[7]) {
            case "b":
              a = a.toString(2);
              break;
            case "c":
              a = String.fromCharCode(a);
              break;
            case "d":
              a = parseInt(a);
              break;
            case "e":
              a = m[6] ? a.toExponential(m[6]) : a.toExponential();
              break;
            case "f":
              a = m[6] ? parseFloat(a).toFixed(m[6]) : parseFloat(a);
              break;
            case "o":
              a = a.toString(8);
              break;
            case "s":
              a = (a = String(a)) && m[6] ? a.substring(0, m[6]) : a;
              break;
            case "u":
              a = Math.abs(a);
              break;
            case "x":
              a = a.toString(16);
              break;
            case "X":
              a = a.toString(16).toUpperCase();
              break;
          }
          a = /[def]/.test(m[7]) && m[2] && a > 0 ? "+" + a : a;
          c = m[3] ? m[3] == "0" ? "0" : m[3][1] : " ";
          x = m[5] - String(a).length;
          p = m[5] ? str_repeat(c, x) : "";
          o.push(m[4] ? a + p : p + a);
        } else throw "Huh ?!";
        f = f.substring(m[0].length);
      }
      return o.join("");
    };
    module.exports = sprintf;
  }
});

// node_modules/abcjs/src/write/draw/round-number.js
var require_round_number = __commonJS({
  "node_modules/abcjs/src/write/draw/round-number.js"(exports, module) {
    function roundNumber(x) {
      return parseFloat(x.toFixed(2));
    }
    module.exports = roundNumber;
  }
});

// node_modules/abcjs/src/write/draw/text.js
var require_text = __commonJS({
  "node_modules/abcjs/src/write/draw/text.js"(exports, module) {
    var roundNumber = require_round_number();
    function renderText(renderer, params, alreadyInGroup) {
      var y = params.y;
      if (params.phrases) {
        var elem = renderer.paper.richTextLine(params.phrases, params.x, params.y, params.klass, params.anchor);
        return elem;
      }
      if (params.lane) {
        var laneMargin = params.dim.font.size * 0.25;
        y += (params.dim.font.size + laneMargin) * params.lane;
      }
      var hash;
      if (params.dim) {
        hash = params.dim;
        hash.attr.class = params.klass;
      } else
        hash = renderer.controller.getFontAndAttr.calc(params.type, params.klass);
      if (params.anchor)
        hash.attr["text-anchor"] = params.anchor;
      if (params["dominant-baseline"])
        hash.attr["dominant-baseline"] = params["dominant-baseline"];
      hash.attr.x = params.x;
      hash.attr.y = y;
      if (!params.centerVertically)
        hash.attr.y += hash.font.size;
      if (params.type === "debugfont") {
        console.log("Debug msg: " + params.text);
        hash.attr.stroke = "#ff0000";
      }
      if (params.cursor) {
        hash.attr.cursor = params.cursor;
      }
      var text = params.text.replace(/\n\n/g, "\n \n");
      text = text.replace(/^\n/, " \n");
      if (hash.font.box) {
        if (!alreadyInGroup)
          renderer.paper.openGroup({ klass: hash.attr["class"], fill: renderer.foregroundColor, "data-name": params.name });
        if (hash.attr["text-anchor"] === "end") {
          hash.attr.x -= hash.font.padding;
        } else if (hash.attr["text-anchor"] === "start") {
          hash.attr.x += hash.font.padding;
        }
        hash.attr.y += hash.font.padding;
        delete hash.attr["class"];
      }
      if (params.noClass)
        delete hash.attr["class"];
      hash.attr.x = roundNumber(hash.attr.x);
      hash.attr.y = roundNumber(hash.attr.y);
      if (params.name)
        hash.attr["data-name"] = params.name;
      var elem = renderer.paper.text(text, hash.attr);
      if (hash.font.box) {
        var size = elem.getBBox();
        var delta = 0;
        if (hash.attr["text-anchor"] === "middle") {
          delta = size.width / 2 + hash.font.padding;
        } else if (hash.attr["text-anchor"] === "end") {
          delta = size.width + hash.font.padding * 2;
        }
        var deltaY = 0;
        if (params.centerVertically) {
          deltaY = size.height - hash.font.padding;
        }
        renderer.paper.rect({ "data-name": "box", x: Math.round(params.x - delta), y: Math.round(y - deltaY), width: Math.round(size.width + hash.font.padding * 2), height: Math.round(size.height + hash.font.padding * 2) });
        if (!alreadyInGroup)
          elem = renderer.paper.closeGroup();
      }
      return elem;
    }
    module.exports = renderText;
  }
});

// node_modules/abcjs/src/write/draw/brace.js
var require_brace = __commonJS({
  "node_modules/abcjs/src/write/draw/brace.js"(exports, module) {
    var sprintf = require_sprintf();
    var spacing = require_spacing();
    var renderText = require_text();
    function drawBrace(renderer, params, selectables) {
      var startY = params.startVoice.staff.absoluteY - spacing.STEP * 10;
      if (params.endVoice && params.endVoice.staff)
        params.endY = params.endVoice.staff.absoluteY - spacing.STEP * 2;
      else if (params.lastContinuedVoice && params.lastContinuedVoice.staff)
        params.endY = params.lastContinuedVoice.staff.absoluteY - spacing.STEP * 2;
      else
        params.endY = params.startVoice.staff.absoluteY - spacing.STEP * 2;
      return draw(renderer, params.x, startY, params.endY, params.type, params.header, selectables);
    }
    function straightPath(renderer, xLeft, yTop, yBottom, type) {
      xLeft += spacing.STEP;
      var xLineWidth = spacing.STEP * 0.75;
      var yOverlap = spacing.STEP * 0.75;
      var height = yBottom - yTop;
      var pathString = sprintf(
        "M %f %f l %f %f l %f %f l %f %f z",
        xLeft,
        yTop - yOverlap,
        // top left line
        0,
        height + yOverlap * 2,
        // bottom left line
        xLineWidth,
        0,
        // bottom right line
        0,
        -(height + yOverlap * 2)
        // top right line
      );
      var wCurve = spacing.STEP * 2;
      var hCurve = spacing.STEP;
      pathString += sprintf(
        "M %f %f q %f %f %f %f q %f %f %f %f z",
        xLeft + xLineWidth,
        yTop - yOverlap,
        // top left arm
        wCurve * 0.6,
        hCurve * 0.2,
        wCurve,
        -hCurve,
        // right point
        -wCurve * 0.1,
        hCurve * 0.3,
        -wCurve,
        hCurve + spacing.STEP
        // left bottom
      );
      pathString += sprintf(
        "M %f %f q %f %f %f %f q %f %f %f %f z",
        xLeft + xLineWidth,
        yTop + yOverlap + height,
        // bottom left arm
        wCurve * 0.6,
        -hCurve * 0.2,
        wCurve,
        hCurve,
        // right point
        -wCurve * 0.1,
        -hCurve * 0.3,
        -wCurve,
        -hCurve - spacing.STEP
        // left bottom
      );
      return renderer.paper.path({ path: pathString, stroke: renderer.foregroundColor, fill: renderer.foregroundColor, "class": renderer.controller.classes.generate(type), "data-name": type });
    }
    function curvyPath(renderer, xLeft, yTop, yBottom, type) {
      var yHeight = yBottom - yTop;
      var pathString = curve(
        xLeft,
        yTop,
        [7.5, -8, 21, 0, 18.5, -10.5, 7.5],
        [0, yHeight / 5.5, yHeight / 3.14, yHeight / 2, yHeight / 2.93, yHeight / 4.88, 0]
      );
      pathString += curve(
        xLeft,
        yTop,
        [0, 17.5, -7.5, 6.6, -5, 20, 0],
        [yHeight / 2, yHeight / 1.46, yHeight / 1.22, yHeight, yHeight / 1.19, yHeight / 1.42, yHeight / 2]
      );
      return renderer.paper.path({ path: pathString, stroke: renderer.foregroundColor, fill: renderer.foregroundColor, "class": renderer.controller.classes.generate(type), "data-name": type });
    }
    function curve(xLeft, yTop, xCurve, yCurve) {
      return sprintf(
        "M %f %f C %f %f %f %f %f %f C %f %f %f %f %f %f z",
        xLeft + xCurve[0],
        yTop + yCurve[0],
        xLeft + xCurve[1],
        yTop + yCurve[1],
        xLeft + xCurve[2],
        yTop + yCurve[2],
        xLeft + xCurve[3],
        yTop + yCurve[3],
        xLeft + xCurve[4],
        yTop + yCurve[4],
        xLeft + xCurve[5],
        yTop + yCurve[5],
        xLeft + xCurve[6],
        yTop + yCurve[6]
      );
    }
    var draw = function(renderer, xLeft, yTop, yBottom, type, header, selectables) {
      var ret;
      if (header) {
        renderer.paper.openGroup({ klass: renderer.controller.classes.generate("staff-extra voice-name"), "data-name": type });
        var position = yTop + (yBottom - yTop) / 2;
        position = position - renderer.controller.getTextSize.baselineToCenter(header, "voicefont", "staff-extra voice-name", 0, 1);
        renderText(renderer, {
          x: renderer.padding.left,
          y: position,
          text: header,
          type: "voicefont",
          klass: "staff-extra voice-name",
          anchor: "start",
          centerVertically: true
        });
      }
      if (type === "brace")
        ret = curvyPath(renderer, xLeft, yTop, yBottom, type);
      else if (type === "bracket")
        ret = straightPath(renderer, xLeft, yTop, yBottom, type);
      if (header) {
        ret = renderer.paper.closeGroup();
      }
      selectables.wrapSvgEl({ el_type: type, startChar: -1, endChar: -1 }, ret);
      return ret;
    };
    module.exports = drawBrace;
  }
});

// node_modules/abcjs/src/write/draw/print-path.js
var require_print_path = __commonJS({
  "node_modules/abcjs/src/write/draw/print-path.js"(exports, module) {
    function printPath(renderer, attrs, params) {
      var ret = renderer.paper.path(attrs);
      return ret;
    }
    module.exports = printPath;
  }
});

// node_modules/abcjs/src/write/draw/glissando.js
var require_glissando = __commonJS({
  "node_modules/abcjs/src/write/draw/glissando.js"(exports, module) {
    var sprintf = require_sprintf();
    var printPath = require_print_path();
    var roundNumber = require_round_number();
    function drawGlissando(renderer, params, selectables) {
      if (!params.anchor1 || !params.anchor2 || !params.anchor1.heads || !params.anchor2.heads || params.anchor1.heads.length === 0 || params.anchor2.heads.length === 0)
        window.console.error("Glissando Element not set.");
      var margin = 4;
      var leftY = renderer.calcY(params.anchor1.heads[0].pitch);
      var rightY = renderer.calcY(params.anchor2.heads[0].pitch);
      var leftX = params.anchor1.x + params.anchor1.w / 2;
      var rightX = params.anchor2.x + params.anchor2.w / 2;
      var len = lineLength(leftX, leftY, rightX, rightY);
      var marginLeft = params.anchor1.w / 2 + margin;
      var marginRight = params.anchor2.w / 2 + margin;
      var s2 = slope(leftX, leftY, rightX, rightY);
      var leftYAdj = getY(leftY, s2, marginLeft);
      var rightYAdj = getY(rightY, s2, -marginRight);
      var num = numSquigglies(len - marginLeft - marginRight);
      var el = drawSquiggly(renderer, leftX + marginLeft, leftYAdj, num, s2);
      selectables.wrapSvgEl({ el_type: "glissando", startChar: -1, endChar: -1 }, el);
      return [el];
    }
    function lineLength(leftX, leftY, rightX, rightY) {
      var w = rightX - leftX;
      var h = rightY - leftY;
      return Math.sqrt(w * w + h * h);
    }
    function slope(leftX, leftY, rightX, rightY) {
      return (rightY - leftY) / (rightX - leftX);
    }
    function getY(y, slope2, xOfs) {
      return roundNumber(y + xOfs * slope2);
    }
    function numSquigglies(length) {
      var endLen = 5;
      return Math.max(2, Math.floor((length - endLen * 2) / 6));
    }
    var leftStart = [[3.5, -4.8]];
    var right = [[1.5, -1], [0.3, -0.3], [-3.5, 3.8]];
    var leftEnd = [[-1.5, 2]];
    var top = [[3, 4], [3, -4]];
    var bottom = [[-3, 4], [-3, -4]];
    function segment(arr, slope2) {
      var ret = "";
      for (var i2 = 0; i2 < arr.length; i2++) {
        ret += "l" + arr[i2][0] + " " + getY(arr[i2][1], slope2, arr[i2][0]);
      }
      return ret;
    }
    var drawSquiggly = function(renderer, x, y, num, slope2) {
      var p = sprintf("M %f %f", x, y);
      p += segment(leftStart, slope2);
      var i2;
      for (i2 = 0; i2 < num; i2++) {
        p += segment(top, slope2);
      }
      p += segment(right, slope2);
      for (i2 = 0; i2 < num; i2++)
        p += segment(bottom, slope2);
      p += segment(leftEnd, slope2) + "z";
      return printPath(renderer, { path: p, highlight: "stroke", stroke: renderer.foregroundColor, "class": renderer.controller.classes.generate("decoration"), "data-name": "glissando" });
    };
    module.exports = drawGlissando;
  }
});

// node_modules/abcjs/src/write/draw/crescendo.js
var require_crescendo = __commonJS({
  "node_modules/abcjs/src/write/draw/crescendo.js"(exports, module) {
    var sprintf = require_sprintf();
    var printPath = require_print_path();
    var roundNumber = require_round_number();
    function drawCrescendo(renderer, params, selectables) {
      if (params.pitch === void 0)
        window.console.error("Crescendo Element y-coordinate not set.");
      var y = renderer.calcY(params.pitch) + 4;
      var height = 8;
      var left = params.anchor1 ? params.anchor1.x : 0;
      var right = params.anchor2 ? params.anchor2.x : 800;
      var el;
      if (params.dir === "<") {
        el = drawLine(renderer, y + height / 2, y, y + height / 2, y + height, left, right);
      } else {
        el = drawLine(renderer, y, y + height / 2, y + height, y + height / 2, left, right);
      }
      selectables.wrapSvgEl({ el_type: "dynamicDecoration", startChar: -1, endChar: -1 }, el);
      return [el];
    }
    var drawLine = function(renderer, y1, y2, y3, y4, left, right) {
      y1 = roundNumber(y1);
      y2 = roundNumber(y2);
      y3 = roundNumber(y3);
      y4 = roundNumber(y4);
      left = roundNumber(left);
      right = roundNumber(right);
      var pathString = sprintf(
        "M %f %f L %f %f M %f %f L %f %f",
        left,
        y1,
        right,
        y2,
        left,
        y3,
        right,
        y4
      );
      return printPath(renderer, { path: pathString, highlight: "stroke", stroke: renderer.foregroundColor, "class": renderer.controller.classes.generate("dynamics decoration"), "data-name": "dynamics" });
    };
    module.exports = drawCrescendo;
  }
});

// node_modules/abcjs/src/write/draw/group-elements.js
var require_group_elements = __commonJS({
  "node_modules/abcjs/src/write/draw/group-elements.js"(exports, module) {
    var roundNumber = require_round_number();
    function Group() {
      this.ingroup = false;
    }
    Group.prototype.beginGroup = function(paper, controller) {
      this.paper = paper;
      this.controller = controller;
      this.path = [];
      this.lastM = [0, 0];
      this.ingroup = true;
      this.paper.openGroup();
    };
    Group.prototype.isInGroup = function() {
      return this.ingroup;
    };
    Group.prototype.addPath = function(path) {
      path = path || [];
      if (path.length === 0) return;
      path[0][0] = "m";
      path[0][1] = roundNumber(path[0][1] - this.lastM[0]);
      path[0][2] = roundNumber(path[0][2] - this.lastM[1]);
      this.lastM[0] += path[0][1];
      this.lastM[1] += path[0][2];
      this.path.push(path[0]);
      for (var i2 = 1, ii = path.length; i2 < ii; i2++) {
        if (path[i2][0] === "m") {
          this.lastM[0] += path[i2][1];
          this.lastM[1] += path[i2][2];
        }
        this.path.push(path[i2]);
      }
    };
    Group.prototype.endGroup = function(klass, name) {
      this.ingroup = false;
      var path = "";
      for (var i2 = 0; i2 < this.path.length; i2++)
        path += this.path[i2].join(" ");
      this.path = [];
      var ret = this.paper.closeGroup();
      if (ret) {
        ret.setAttribute("class", this.controller.classes.generate(klass));
        ret.setAttribute("fill", this.controller.renderer.foregroundColor);
        ret.setAttribute("stroke", "none");
        ret.setAttribute("data-name", name);
      }
      return ret;
    };
    var elementGroup = new Group();
    module.exports = elementGroup;
  }
});

// node_modules/abcjs/src/write/draw/print-symbol.js
var require_print_symbol = __commonJS({
  "node_modules/abcjs/src/write/draw/print-symbol.js"(exports, module) {
    var renderText = require_text();
    var glyphs = require_glyphs();
    var elementGroup = require_group_elements();
    function printSymbol(renderer, x, offset, symbol, options) {
      var el;
      var ycorr;
      if (!symbol) return null;
      if (symbol.length > 1 && symbol.indexOf(".") < 0) {
        var groupClass = elementGroup.isInGroup() ? "" : options.klass;
        renderer.paper.openGroup({ "data-name": options.name, klass: groupClass });
        var dx = 0;
        for (var i2 = 0; i2 < symbol.length; i2++) {
          var s2 = symbol[i2];
          ycorr = glyphs.getYCorr(s2);
          el = glyphs.printSymbol(x + dx, renderer.calcY(offset + ycorr), s2, renderer.paper, { stroke: options.stroke, fill: options.fill });
          if (el) {
            if (i2 < symbol.length - 1)
              dx += kernSymbols(s2, symbol[i2 + 1], glyphs.getSymbolWidth(s2));
          } else {
            renderText(renderer, { x, y: renderer.y, text: "no symbol:" + symbol, type: "debugfont", klass: "debug-msg", anchor: "start" }, false);
          }
        }
        var g = renderer.paper.closeGroup();
        return g;
      } else {
        ycorr = glyphs.getYCorr(symbol);
        if (elementGroup.isInGroup()) {
          el = glyphs.printSymbol(x, renderer.calcY(offset + ycorr), symbol, renderer.paper, { "data-name": options.name });
        } else {
          el = glyphs.printSymbol(x, renderer.calcY(offset + ycorr), symbol, renderer.paper, { klass: options.klass, stroke: options.stroke, fill: options.fill, "data-name": options.name });
        }
        if (el) {
          return el;
        }
        renderText(renderer, { x, y: renderer.y, text: "no symbol:" + symbol, type: "debugfont", klass: "debug-msg", anchor: "start" }, false);
        return null;
      }
    }
    function kernSymbols(lastSymbol, thisSymbol, lastSymbolWidth) {
      var width = lastSymbolWidth;
      if (lastSymbol === "f" && thisSymbol === "f")
        width = width * 2 / 3;
      if (lastSymbol === "p" && thisSymbol === "p")
        width = width * 5 / 6;
      if (lastSymbol === "f" && thisSymbol === "z")
        width = width * 5 / 8;
      return width;
    }
    module.exports = printSymbol;
  }
});

// node_modules/abcjs/src/write/draw/dynamics.js
var require_dynamics = __commonJS({
  "node_modules/abcjs/src/write/draw/dynamics.js"(exports, module) {
    var printSymbol = require_print_symbol();
    function drawDynamics(renderer, params, selectables) {
      if (params.pitch === void 0)
        window.console.error("Dynamic Element y-coordinate not set.");
      var scalex = 1;
      var scaley = 1;
      var el = printSymbol(renderer, params.anchor.x, params.pitch, params.dec, {
        scalex,
        scaley,
        klass: renderer.controller.classes.generate("decoration dynamics"),
        fill: renderer.foregroundColor,
        stroke: "none",
        name: "dynamics"
      });
      selectables.wrapSvgEl({ el_type: "dynamicDecoration", startChar: -1, endChar: -1, decoration: params.dec }, el);
      return [el];
    }
    module.exports = drawDynamics;
  }
});

// node_modules/abcjs/src/write/draw/triplet.js
var require_triplet2 = __commonJS({
  "node_modules/abcjs/src/write/draw/triplet.js"(exports, module) {
    var sprintf = require_sprintf();
    var renderText = require_text();
    var printPath = require_print_path();
    var roundNumber = require_round_number();
    function drawTriplet(renderer, params, selectables) {
      renderer.paper.openGroup({ klass: renderer.controller.classes.generate("triplet " + params.durationClass), "data-name": "triplet" });
      if (!params.hasBeam) {
        drawBracket(renderer, params.anchor1.x, params.startNote, params.anchor2.x + params.anchor2.w, params.endNote);
      }
      renderText(renderer, { x: params.xTextPos, y: renderer.calcY(params.yTextPos - 1), text: "" + params.number, type: "tripletfont", anchor: "middle", centerVertically: true, noClass: true, name: "" + params.number }, true);
      var g = renderer.paper.closeGroup();
      selectables.wrapSvgEl({ el_type: "triplet", startChar: -1, endChar: -1 }, g);
      return g;
    }
    function drawLine(l, t, r, b) {
      return sprintf("M %f %f L %f %f", roundNumber(l), roundNumber(t), roundNumber(r), roundNumber(b));
    }
    function drawBracket(renderer, x1, y1, x2, y2) {
      y1 = renderer.calcY(y1);
      y2 = renderer.calcY(y2);
      var bracketHeight = 5;
      var pathString = "";
      pathString += drawLine(x1, y1, x1, y1 + bracketHeight);
      pathString += drawLine(x2, y2, x2, y2 + bracketHeight);
      var midX = x1 + (x2 - x1) / 2;
      var gapWidth = 8;
      var slope = (y2 - y1) / (x2 - x1);
      var leftEndX = midX - gapWidth;
      var leftEndY = y1 + (leftEndX - x1) * slope;
      pathString += drawLine(x1, y1, leftEndX, leftEndY);
      var rightStartX = midX + gapWidth;
      var rightStartY = y1 + (rightStartX - x1) * slope;
      pathString += drawLine(rightStartX, rightStartY, x2, y2);
      printPath(renderer, { path: pathString, stroke: renderer.foregroundColor, "data-name": "triplet-bracket" });
    }
    module.exports = drawTriplet;
  }
});

// node_modules/abcjs/src/write/draw/ending.js
var require_ending = __commonJS({
  "node_modules/abcjs/src/write/draw/ending.js"(exports, module) {
    var sprintf = require_sprintf();
    var renderText = require_text();
    var printPath = require_print_path();
    var roundNumber = require_round_number();
    function drawEnding(renderer, params, linestartx, lineendx, selectables) {
      if (params.pitch === void 0)
        window.console.error("Ending Element y-coordinate not set.");
      var y = roundNumber(renderer.calcY(params.pitch));
      var height = 20;
      var pathString = "";
      if (params.anchor1) {
        linestartx = roundNumber(params.anchor1.x + params.anchor1.w);
        pathString += sprintf(
          "M %f %f L %f %f ",
          linestartx,
          y,
          linestartx,
          roundNumber(y + height)
        );
      }
      if (params.anchor2) {
        lineendx = roundNumber(params.anchor2.x);
        pathString += sprintf(
          "M %f %f L %f %f ",
          lineendx,
          y,
          lineendx,
          roundNumber(y + height)
        );
      }
      pathString += sprintf(
        "M %f %f L %f %f ",
        linestartx,
        y,
        lineendx,
        y
      );
      renderer.paper.openGroup({ klass: renderer.controller.classes.generate("ending"), "data-name": "ending" });
      printPath(renderer, { path: pathString, stroke: renderer.foregroundColor, fill: renderer.foregroundColor, "data-name": "line" });
      if (params.anchor1)
        renderText(renderer, {
          x: roundNumber(linestartx + 5),
          y: roundNumber(renderer.calcY(params.pitch - 0.5)),
          text: params.text,
          type: "repeatfont",
          klass: "ending",
          anchor: "start",
          noClass: true,
          name: params.text
        });
      var g = renderer.paper.closeGroup();
      selectables.wrapSvgEl({ el_type: "ending", startChar: -1, endChar: -1 }, g);
      return [g];
    }
    module.exports = drawEnding;
  }
});

// node_modules/abcjs/src/write/draw/tie.js
var require_tie = __commonJS({
  "node_modules/abcjs/src/write/draw/tie.js"(exports, module) {
    var sprintf = require_sprintf();
    var roundNumber = require_round_number();
    function drawTie(renderer, params, linestartx, lineendx, selectables) {
      layout(params, linestartx, lineendx);
      var klass = "";
      if (params.anchor1) {
        klass += "abcjs-start-m" + params.anchor1.parent.counters.measure + "-n" + params.anchor1.parent.counters.note;
      } else
        klass += "abcjs-start-edge";
      if (params.anchor2) {
        klass += " abcjs-end-m" + params.anchor2.parent.counters.measure + "-n" + params.anchor2.parent.counters.note;
      } else
        klass += " abcjs-end-edge";
      if (params.hint)
        klass = "abcjs-hint";
      var fudgeY = params.fixedY ? 1.5 : 0;
      var el = drawArc(renderer, params.startX, params.endX, params.startY + fudgeY, params.endY + fudgeY, params.above, klass, params.isTie, params.dotted);
      var startChar = -1;
      if (params.anchor1 && !params.isTie)
        startChar = params.anchor1.parent.abcelem.startChar - 1;
      var endChar = -1;
      if (params.anchor2 && !params.isTie)
        endChar = params.anchor2.parent.abcelem.endChar + 1;
      selectables.wrapSvgEl({ el_type: "slur", startChar, endChar }, el);
      return [el];
    }
    var layout = function(params, lineStartX, lineEndX) {
      if (!params.anchor1 || !params.anchor2)
        params.isTie = true;
      else if (params.anchor1.pitch === params.anchor2.pitch && params.internalNotes.length === 0)
        params.isTie = true;
      else
        params.isTie = false;
      if (params.isTie) {
        params.calcTieDirection();
        params.calcX(lineStartX, lineEndX);
        params.calcTieY();
      } else {
        params.calcSlurDirection();
        params.calcX(lineStartX, lineEndX);
        params.calcSlurY();
      }
      params.avoidCollisionAbove();
    };
    var drawArc = function(renderer, x1, x2, pitch1, pitch2, above, klass, isTie, dotted) {
      var spacing = isTie ? 1.2 : 1.5;
      x1 = roundNumber(x1 + 6);
      x2 = roundNumber(x2 + 4);
      pitch1 = pitch1 + (above ? spacing : -spacing);
      pitch2 = pitch2 + (above ? spacing : -spacing);
      var y1 = roundNumber(renderer.calcY(pitch1));
      var y2 = roundNumber(renderer.calcY(pitch2));
      var dx = x2 - x1;
      var dy = y2 - y1;
      var norm = Math.sqrt(dx * dx + dy * dy);
      var ux = dx / norm;
      var uy = dy / norm;
      var flatten = norm / 3.5;
      var maxFlatten = isTie ? 10 : 25;
      var curve = (above ? -1 : 1) * Math.min(maxFlatten, Math.max(4, flatten));
      var controlx1 = roundNumber(x1 + flatten * ux - curve * uy);
      var controly1 = roundNumber(y1 + flatten * uy + curve * ux);
      var controlx2 = roundNumber(x2 - flatten * ux - curve * uy);
      var controly2 = roundNumber(y2 - flatten * uy + curve * ux);
      var thickness = 2;
      if (klass)
        klass += " slur";
      else
        klass = "slur";
      klass += isTie ? " tie" : " legato";
      var ret;
      if (dotted) {
        klass += " dotted";
        var pathString2 = sprintf(
          "M %f %f C %f %f %f %f %f %f",
          x1,
          y1,
          controlx1,
          controly1,
          controlx2,
          controly2,
          x2,
          y2
        );
        ret = renderer.paper.path({ path: pathString2, stroke: renderer.foregroundColor, fill: "none", "stroke-dasharray": "5 5", "class": renderer.controller.classes.generate(klass), "data-name": isTie ? "tie" : "slur" });
      } else {
        var pathString = sprintf(
          "M %f %f C %f %f %f %f %f %f C %f %f %f %f %f %f z",
          x1,
          y1,
          controlx1,
          controly1,
          controlx2,
          controly2,
          x2,
          y2,
          roundNumber(controlx2 - thickness * uy),
          roundNumber(controly2 + thickness * ux),
          roundNumber(controlx1 - thickness * uy),
          roundNumber(controly1 + thickness * ux),
          x1,
          y1
        );
        ret = renderer.paper.path({ path: pathString, stroke: "none", fill: renderer.foregroundColor, "class": renderer.controller.classes.generate(klass), "data-name": isTie ? "tie" : "slur" });
      }
      return ret;
    };
    module.exports = drawTie;
  }
});

// node_modules/abcjs/src/write/draw/beam.js
var require_beam2 = __commonJS({
  "node_modules/abcjs/src/write/draw/beam.js"(exports, module) {
    var printPath = require_print_path();
    var roundNumber = require_round_number();
    function drawBeam(renderer, params) {
      if (params.beams.length === 0) return;
      var pathString = "";
      for (var i2 = 0; i2 < params.beams.length; i2++) {
        var beam = params.beams[i2];
        if (beam.split) {
          var slope = getSlope(renderer, beam.startX, beam.startY, beam.endX, beam.endY);
          var xes = [];
          for (var j = 0; j < beam.split.length; j += 2) {
            xes.push([beam.split[j], beam.split[j + 1]]);
          }
          for (j = 0; j < xes.length; j++) {
            var y1 = getY(beam.startX, beam.startY, slope, xes[j][0]);
            var y2 = getY(beam.startX, beam.startY, slope, xes[j][1]);
            pathString += draw(renderer, xes[j][0], y1, xes[j][1], y2, beam.dy);
          }
        } else
          pathString += draw(renderer, beam.startX, beam.startY, beam.endX, beam.endY, beam.dy);
      }
      var durationClass = ("abcjs-d" + params.duration).replace(/\./g, "-");
      var klasses = renderer.controller.classes.generate("beam-elem " + durationClass);
      var el = printPath(renderer, {
        path: pathString,
        stroke: "none",
        fill: renderer.foregroundColor,
        "class": klasses
      });
      return [el];
    }
    function draw(renderer, startX, startY, endX, endY, dy) {
      startY = roundNumber(renderer.calcY(startY));
      endY = roundNumber(renderer.calcY(endY));
      startX = roundNumber(startX);
      endX = roundNumber(endX);
      var startY2 = roundNumber(startY + dy);
      var endY2 = roundNumber(endY + dy);
      return "M" + startX + " " + startY + " L" + endX + " " + endY + "L" + endX + " " + endY2 + " L" + startX + " " + startY2 + "z";
    }
    function getSlope(renderer, startX, startY, endX, endY) {
      return (endY - startY) / (endX - startX);
    }
    function getY(startX, startY, slope, currentX) {
      var x = currentX - startX;
      return startY + x * slope;
    }
    module.exports = drawBeam;
  }
});

// node_modules/abcjs/src/write/draw/print-stem.js
var require_print_stem = __commonJS({
  "node_modules/abcjs/src/write/draw/print-stem.js"(exports, module) {
    var elementGroup = require_group_elements();
    var roundNumber = require_round_number();
    function printStem(renderer, x, dx, y1, y2, klass, name) {
      if (dx < 0 || y1 < y2) {
        var tmp = roundNumber(y2);
        y2 = roundNumber(y1);
        y1 = tmp;
      } else {
        y1 = roundNumber(y1);
        y2 = roundNumber(y2);
      }
      x = roundNumber(x);
      var x2 = roundNumber(x + dx);
      if (renderer.firefox112) {
        x += dx / 2;
        var attr = {
          x1: x,
          x2: x,
          y1,
          y2,
          stroke: renderer.foregroundColor,
          "stroke-width": Math.abs(dx)
        };
        if (klass)
          attr["class"] = klass;
        if (name)
          attr["data-name"] = name;
        return renderer.paper.lineToBack(attr);
      }
      var pathArray = [["M", x, y1], ["L", x, y2], ["L", x2, y2], ["L", x2, y1], ["z"]];
      var attr = { path: "" };
      for (var i2 = 0; i2 < pathArray.length; i2++)
        attr.path += pathArray[i2].join(" ");
      if (klass)
        attr["class"] = klass;
      if (name)
        attr["data-name"] = name;
      if (!elementGroup.isInGroup()) {
        attr.stroke = "none";
        attr.fill = renderer.foregroundColor;
      }
      return renderer.paper.pathToBack(attr);
    }
    module.exports = printStem;
  }
});

// node_modules/abcjs/src/write/draw/print-line.js
var require_print_line = __commonJS({
  "node_modules/abcjs/src/write/draw/print-line.js"(exports, module) {
    var sprintf = require_sprintf();
    var roundNumber = require_round_number();
    function printLine(renderer, x1, x2, y, klass, name, dy) {
      var fill = renderer.foregroundColor;
      x1 = roundNumber(x1);
      x2 = roundNumber(x2);
      var y1 = roundNumber(y - dy);
      var y2 = roundNumber(y + dy);
      if (renderer.firefox112) {
        y += dy / 2;
        var attr = {
          x1,
          x2,
          y1: y,
          y2: y,
          stroke: renderer.foregroundColor,
          "stroke-width": Math.abs(dy * 2)
        };
        if (klass)
          attr["class"] = klass;
        if (name)
          attr["data-name"] = name;
        return renderer.paper.lineToBack(attr);
      }
      var pathString = sprintf(
        "M %f %f L %f %f L %f %f L %f %f z",
        x1,
        y1,
        x2,
        y1,
        x2,
        y2,
        x1,
        y2
      );
      var options = { path: pathString, stroke: "none", fill };
      if (name)
        options["data-name"] = name;
      if (klass)
        options["class"] = klass;
      var ret = renderer.paper.pathToBack(options);
      return ret;
    }
    module.exports = printLine;
  }
});

// node_modules/abcjs/src/write/draw/staff-line.js
var require_staff_line = __commonJS({
  "node_modules/abcjs/src/write/draw/staff-line.js"(exports, module) {
    var printLine = require_print_line();
    function printStaffLine(renderer, x1, x2, pitch, klass, name, dy) {
      var y = renderer.calcY(pitch);
      return printLine(renderer, x1, x2, y, klass, name, dy);
    }
    module.exports = printStaffLine;
  }
});

// node_modules/abcjs/src/write/draw/relative.js
var require_relative = __commonJS({
  "node_modules/abcjs/src/write/draw/relative.js"(exports, module) {
    var renderText = require_text();
    var printStem = require_print_stem();
    var printStaffLine = require_staff_line();
    var printSymbol = require_print_symbol();
    function drawRelativeElement(renderer, params, bartop) {
      if (params.pitch === void 0)
        window.console.error(params.type + " Relative Element y-coordinate not set.");
      var y = renderer.calcY(params.pitch);
      switch (params.type) {
        case "symbol":
          if (params.c === null) return null;
          var klass = "symbol";
          if (params.klass) klass += " " + params.klass;
          params.graphelem = printSymbol(renderer, params.x, params.pitch, params.c, {
            scalex: params.scalex,
            scaley: params.scaley,
            klass: renderer.controller.classes.generate(klass),
            //				fill:"none",
            //				stroke: renderer.foregroundColor,
            name: params.name
          });
          break;
        case "debug":
          params.graphelem = renderText(renderer, { x: params.x, y: renderer.calcY(15), text: "" + params.c, type: "debugfont", klass: renderer.controller.classes.generate("debug-msg"), anchor: "start", centerVertically: false, dim: params.dim }, false);
          break;
        case "tabNumber":
          var hAnchor = "middle";
          var tabFont = "tabnumberfont";
          var tabClass = "abcjs-tab-number";
          if (params.isGrace) {
            tabFont = "tabgracefont";
            y += 2.5;
            tabClass = "tab-grace";
          }
          params.graphelem = renderText(renderer, { x: params.x, y, text: "" + params.c, type: tabFont, klass: renderer.controller.classes.generate(tabClass), anchor: hAnchor, centerVertically: false, dim: params.dim, cursor: "default" }, false);
          break;
        case "barNumber":
          params.graphelem = renderText(renderer, { x: params.x, y, text: "" + params.c, type: "measurefont", klass: renderer.controller.classes.generate("bar-number"), anchor: "middle", dim: params.dim, name: "bar-number" }, true);
          break;
        case "lyric":
          params.graphelem = renderText(renderer, { x: params.x, y, text: params.c, type: "vocalfont", klass: renderer.controller.classes.generate("lyric"), anchor: "middle", dim: params.dim, name: "lyric" }, false);
          break;
        case "chord":
          params.graphelem = renderText(renderer, { x: params.x, y, text: params.c, type: "gchordfont", klass: renderer.controller.classes.generate("chord"), anchor: "middle", dim: params.dim, lane: params.getLane(), name: "chord" }, false);
          break;
        case "decoration":
          params.graphelem = renderText(renderer, { x: params.x, y: y + 6, text: params.c, type: "annotationfont", klass: renderer.controller.classes.generate("annotation"), anchor: params.anchor, centerVertically: true, dim: params.dim }, false);
          break;
        case "text":
          params.graphelem = renderText(renderer, { x: params.x, y, text: params.c, type: "annotationfont", klass: renderer.controller.classes.generate("annotation"), anchor: "start", centerVertically: params.centerVertically, dim: params.dim, lane: params.getLane(), name: "annotation" }, false);
          break;
        case "multimeasure-text":
          params.graphelem = renderText(renderer, { x: params.x + params.w / 2, y, text: params.c, type: "tempofont", klass: renderer.controller.classes.generate("rest"), anchor: "middle", centerVertically: false, dim: params.dim }, false);
          break;
        case "part":
          params.graphelem = renderText(renderer, { x: params.x, y, text: params.c, type: "partsfont", klass: renderer.controller.classes.generate("part"), anchor: "start", dim: params.dim, name: params.c }, true);
          break;
        case "bar":
          params.graphelem = printStem(renderer, params.x, params.linewidth + renderer.lineThickness, y, bartop ? bartop : renderer.calcY(params.pitch2), null, "bar");
          break;
        // bartop can't be 0
        case "stem":
          var stemWidth = params.linewidth > 0 ? params.linewidth + renderer.lineThickness : params.linewidth - renderer.lineThickness;
          params.graphelem = printStem(renderer, params.x, stemWidth, y, renderer.calcY(params.pitch2), "abcjs-stem", "stem");
          break;
        case "ledger":
          params.graphelem = printStaffLine(renderer, params.x, params.x + params.w, params.pitch, "abcjs-ledger", "ledger", 0.35 + renderer.lineThickness);
          break;
      }
      if (params.scalex !== 1 && params.graphelem) {
        scaleExistingElem(renderer.paper, params.graphelem, params.scalex, params.scaley, params.x, y);
      }
      return params.graphelem;
    }
    function scaleExistingElem(paper, elem, scaleX, scaleY, x, y) {
      paper.setAttributeOnElement(elem, { style: "transform:scale(" + scaleX + "," + scaleY + ");transform-origin:" + x + "px " + y + "px;" });
    }
    module.exports = drawRelativeElement;
  }
});

// node_modules/abcjs/src/write/draw/tempo.js
var require_tempo = __commonJS({
  "node_modules/abcjs/src/write/draw/tempo.js"(exports, module) {
    var drawRelativeElement = require_relative();
    var renderText = require_text();
    function drawTempo(renderer, params) {
      var x = params.x;
      if (params.pitch === void 0)
        window.console.error("Tempo Element y-coordinate not set.");
      params.tempo.el_type = "tempo";
      var descenderHeight = 2;
      var y = renderer.calcY(params.pitch) + 2;
      var text;
      var size;
      if (params.tempo.preString) {
        text = renderText(renderer, { x, y, text: params.tempo.preString, type: "tempofont", klass: "abcjs-tempo", anchor: "start", noClass: true, name: "pre" }, true);
        size = renderer.controller.getTextSize.calc(params.tempo.preString, "tempofont", "tempo", text);
        var preWidth = size.width;
        var charWidth = preWidth / params.tempo.preString.length;
        x += preWidth + charWidth;
      }
      if (params.note) {
        params.note.setX(x);
        for (var i2 = 0; i2 < params.note.children.length; i2++)
          drawRelativeElement(renderer, params.note.children[i2], x);
        x += params.note.w + 5;
        var str = "= " + params.tempo.bpm;
        text = renderText(renderer, { x, y, text: str, type: "tempofont", klass: "abcjs-tempo", anchor: "start", noClass: true, name: "beats" });
        size = renderer.controller.getTextSize.calc(str, "tempofont", "tempo", text);
        var postWidth = size.width;
        var charWidth2 = postWidth / str.length;
        x += postWidth + charWidth2;
      }
      if (params.tempo.postString) {
        renderText(renderer, { x, y, text: params.tempo.postString, type: "tempofont", klass: "abcjs-tempo", anchor: "start", noClass: true, name: "post" }, true);
      }
    }
    module.exports = drawTempo;
  }
});

// node_modules/abcjs/src/write/draw/absolute.js
var require_absolute = __commonJS({
  "node_modules/abcjs/src/write/draw/absolute.js"(exports, module) {
    var drawTempo = require_tempo();
    var drawRelativeElement = require_relative();
    var spacing = require_spacing();
    var setClass = require_set_class();
    var elementGroup = require_group_elements();
    function drawAbsolute(renderer, params, bartop, selectables, staffPos) {
      if (params.invisible) return;
      var isTempo = params.children.length > 0 && params.children[0].type === "TempoElement";
      params.elemset = [];
      elementGroup.beginGroup(renderer.paper, renderer.controller);
      for (var i2 = 0; i2 < params.children.length; i2++) {
        var child = params.children[i2];
        switch (child.type) {
          case "TempoElement":
            drawTempo(renderer, child);
            break;
          default:
            var el = drawRelativeElement(renderer, child, bartop);
            if (child.type === "symbol" && child.c && child.c.indexOf("notehead") >= 0) {
              el.setAttribute("class", "abcjs-notehead");
            }
        }
      }
      var klass = params.type;
      if (params.type === "note" || params.type === "rest") {
        params.counters = renderer.controller.classes.getCurrent();
        klass += " d" + Math.round(params.durationClass * 1e3) / 1e3;
        klass = klass.replace(/\./g, "-");
        if (params.abcelem.pitches) {
          for (var j = 0; j < params.abcelem.pitches.length; j++) {
            klass += " p" + params.abcelem.pitches[j].pitch;
          }
        }
      }
      var g = elementGroup.endGroup(klass, params.type);
      if (g) {
        if (params.cloned) {
          params.cloned.overrideClasses = g.className.baseVal;
        }
        if (params.overrideClasses) {
          var type = g.classList && g.classList.length > 0 ? g.classList[0] + " " : "";
          g.setAttribute("class", type + params.overrideClasses);
        }
        if (isTempo) {
          params.startChar = params.abcelem.startChar;
          params.endChar = params.abcelem.endChar;
          selectables.add(params, g, false, staffPos);
        } else {
          params.elemset.push(g);
          var isSelectable = false;
          if (params.type === "note" || params.type === "tabNumber") {
            isSelectable = true;
          }
          selectables.add(params, g, isSelectable, staffPos);
        }
      } else if (params.elemset.length > 0)
        selectables.add(params, params.elemset[0], params.type === "note", staffPos);
      if (params.klass)
        setClass(params.elemset, "mark", "", "#00ff00");
      if (params.hint)
        setClass(params.elemset, "abcjs-hint", "", null);
      params.abcelem.abselem = params;
      if (params.heads && params.heads.length > 0) {
        params.notePositions = [];
        for (var jj = 0; jj < params.heads.length; jj++) {
          params.notePositions.push({
            x: params.heads[jj].x + params.heads[jj].w / 2,
            y: staffPos.zero - params.heads[jj].pitch * spacing.STEP
          });
        }
      }
    }
    module.exports = drawAbsolute;
  }
});

// node_modules/abcjs/src/write/draw/voice.js
var require_voice2 = __commonJS({
  "node_modules/abcjs/src/write/draw/voice.js"(exports, module) {
    var drawGlissando = require_glissando();
    var drawCrescendo = require_crescendo();
    var drawDynamics = require_dynamics();
    var drawTriplet = require_triplet2();
    var drawEnding = require_ending();
    var drawTie = require_tie();
    var drawBeam = require_beam2();
    var renderText = require_text();
    var drawAbsolute = require_absolute();
    function drawVoice(renderer, params, bartop, selectables, staffPos) {
      var width = params.w - 1;
      renderer.staffbottom = params.staff.bottom;
      var saveColor = renderer.foregroundColor;
      if (params.color)
        renderer.foregroundColor = params.color;
      if (params.header) {
        var textEl = renderText(renderer, { x: renderer.padding.left, y: renderer.calcY(params.headerPosition), text: params.header, type: "voicefont", klass: "staff-extra voice-name", anchor: "start", centerVertically: true, name: "voice-name" }, true);
        selectables.wrapSvgEl({ el_type: "voiceName", startChar: -1, endChar: -1, text: params.header }, textEl);
      }
      var i2;
      var child;
      var foundNote = false;
      for (i2 = 0; i2 < params.children.length; i2++) {
        child = params.children[i2];
        if (child.type === "note" || child.type === "rest")
          foundNote = true;
        var justInitializedMeasureNumber = false;
        if (child.type !== "staff-extra" && !renderer.controller.classes.isInMeasure()) {
          renderer.controller.classes.startMeasure();
          justInitializedMeasureNumber = true;
        }
        if (params.staff.isTabStaff) {
          child.invisible = false;
          if (child.type == "bar") {
            if (child.abcelem.lastBar) {
              bartop = params.topLine;
            }
          }
        }
        drawAbsolute(renderer, child, params.barto || i2 === params.children.length - 1 ? bartop : 0, selectables, staffPos);
        if (child.type === "note" || isNonSpacerRest(child))
          renderer.controller.classes.incrNote();
        if (child.type === "bar" && !justInitializedMeasureNumber && foundNote) {
          renderer.controller.classes.incrMeasure();
        }
      }
      renderer.controller.classes.startMeasure();
      for (i2 = 0; i2 < params.beams.length; i2++) {
        var beam = params.beams[i2];
        if (beam === "bar") {
          renderer.controller.classes.incrMeasure();
        } else
          drawBeam(renderer, beam, selectables);
      }
      renderer.controller.classes.startMeasure();
      for (i2 = 0; i2 < params.otherchildren.length; i2++) {
        child = params.otherchildren[i2];
        if (child === "bar") {
          renderer.controller.classes.incrMeasure();
        } else {
          switch (child.type) {
            case "GlissandoElem":
              child.elemset = drawGlissando(renderer, child, selectables);
              break;
            case "CrescendoElem":
              child.elemset = drawCrescendo(renderer, child, selectables);
              break;
            case "DynamicDecoration":
              child.elemset = drawDynamics(renderer, child, selectables);
              break;
            case "TripletElem":
              drawTriplet(renderer, child, selectables);
              break;
            case "EndingElem":
              child.elemset = drawEnding(renderer, child, params.startx + 10, width, selectables);
              break;
            case "TieElem":
              child.elemset = drawTie(renderer, child, params.startx + 10, width, selectables);
              break;
            default:
              console.log(child);
              drawAbsolute(renderer, child, params.startx + 10, width, selectables, staffPos);
          }
        }
      }
      renderer.foregroundColor = saveColor;
    }
    function isNonSpacerRest(elem) {
      if (elem.type !== "rest")
        return false;
      if (elem.abcelem && elem.abcelem.rest && elem.abcelem.rest.type !== "spacer")
        return true;
      return false;
    }
    module.exports = drawVoice;
  }
});

// node_modules/abcjs/src/write/draw/staff.js
var require_staff = __commonJS({
  "node_modules/abcjs/src/write/draw/staff.js"(exports, module) {
    var printStaffLine = require_staff_line();
    function printStaff(renderer, startx, endx, numLines, linePitch, dy) {
      var klass = "abcjs-top-line";
      var pitch = 2;
      if (linePitch) {
        pitch = linePitch;
      }
      renderer.paper.openGroup({ prepend: true, klass: renderer.controller.classes.generate("abcjs-staff") });
      var firstYLine = 0;
      var lastYLine = 0;
      if (numLines === 1) {
        printStaffLine(renderer, startx, endx, 6, klass, null, dy + renderer.lineThickness);
        firstYLine = renderer.calcY(10);
        lastYLine = renderer.calcY(2);
      } else {
        for (var i2 = numLines - 1; i2 >= 0; i2--) {
          var curpitch = (i2 + 1) * pitch;
          lastYLine = renderer.calcY(curpitch);
          if (firstYLine === 0) {
            firstYLine = lastYLine;
          }
          printStaffLine(renderer, startx, endx, curpitch, klass, null, dy + renderer.lineThickness);
          klass = void 0;
        }
      }
      renderer.paper.closeGroup();
      return [firstYLine, lastYLine];
    }
    module.exports = printStaff;
  }
});

// node_modules/abcjs/src/write/draw/debug-box.js
var require_debug_box = __commonJS({
  "node_modules/abcjs/src/write/draw/debug-box.js"(exports, module) {
    function printDebugBox(renderer, attr, comment) {
      var box = renderer.paper.rectBeneath(attr);
      if (comment)
        renderer.paper.text(comment, { x: 0, y: attr.y + 7, "text-anchor": "start", "font-size": "14px", fill: "rgba(0,0,255,.4)", stroke: "rgba(0,0,255,.4)" });
      return box;
    }
    module.exports = printDebugBox;
  }
});

// node_modules/abcjs/src/write/draw/separator.js
var require_separator2 = __commonJS({
  "node_modules/abcjs/src/write/draw/separator.js"(exports, module) {
    function drawSeparator(renderer, width) {
      var fill = "rgba(0,0,0,255)";
      var stroke = "rgba(0,0,0,0)";
      var y = Math.round(renderer.y);
      var staffWidth = renderer.controller.width;
      var x1 = (staffWidth - width) / 2;
      var x2 = x1 + width;
      var pathString = "M " + x1 + " " + y + " L " + x2 + " " + y + " L " + x2 + " " + (y + 1) + " L " + x1 + " " + (y + 1) + " L " + x1 + " " + y + " z";
      renderer.paper.pathToBack({ path: pathString, stroke, fill, "class": renderer.controller.classes.generate("defined-text") });
    }
    module.exports = drawSeparator;
  }
});

// node_modules/abcjs/src/write/draw/non-music.js
var require_non_music = __commonJS({
  "node_modules/abcjs/src/write/draw/non-music.js"(exports, module) {
    var drawSeparator = require_separator2();
    var renderText = require_text();
    function nonMusic(renderer, obj, selectables) {
      for (var i2 = 0; i2 < obj.rows.length; i2++) {
        var row = obj.rows[i2];
        if (row.absmove) {
          renderer.absolutemoveY(row.absmove);
        } else if (row.move) {
          renderer.moveY(row.move);
        } else if (row.text || row.phrases) {
          var x = row.left ? row.left : 0;
          var el = renderText(renderer, {
            x,
            y: renderer.y,
            text: row.text,
            phrases: row.phrases,
            "dominant-baseline": row["dominant-baseline"],
            type: row.font,
            klass: row.klass,
            name: row.name,
            anchor: row.anchor
          });
          if (row.absElemType) {
            selectables.wrapSvgEl({
              el_type: row.absElemType,
              name: row.name,
              startChar: row.startChar,
              endChar: row.endChar,
              text: row.text
            }, el);
          }
        } else if (row.separator) {
          drawSeparator(renderer, row.separator);
        } else if (row.startGroup) {
          renderer.paper.openGroup({ klass: row.klass, "data-name": row.name });
        } else if (row.endGroup) {
          var g = renderer.paper.closeGroup();
          if (row.absElemType)
            selectables.wrapSvgEl({
              el_type: row.absElemType,
              name: row.name,
              startChar: row.startChar,
              endChar: row.endChar,
              text: ""
            }, g);
        }
      }
    }
    module.exports = nonMusic;
  }
});

// node_modules/abcjs/src/write/draw/staff-group.js
var require_staff_group2 = __commonJS({
  "node_modules/abcjs/src/write/draw/staff-group.js"(exports, module) {
    var spacing = require_spacing();
    var drawBrace = require_brace();
    var drawVoice = require_voice2();
    var printStaff = require_staff();
    var printDebugBox = require_debug_box();
    var printStem = require_print_stem();
    var nonMusic = require_non_music();
    function drawStaffGroup(renderer, params, selectables, lineNumber) {
      var colorIndex;
      var startY = renderer.y;
      for (var j = 0; j < params.staffs.length; j++) {
        var staff1 = params.staffs[j];
        renderer.moveY(spacing.STEP, staff1.top);
        staff1.absoluteY = renderer.y;
        if (renderer.showDebug) {
          if (renderer.showDebug.indexOf("box") >= 0 && staff1.voices) {
            boxAllElements(renderer, params.voices, staff1.voices);
          }
          if (renderer.showDebug.indexOf("grid") >= 0) {
            renderer.paper.dottedLine({ x1: renderer.padding.left, x2: renderer.padding.left + renderer.controller.width, y1: startY, y2: startY, stroke: "#0000ff" });
            printDebugBox(
              renderer,
              {
                x: renderer.padding.left,
                y: renderer.calcY(staff1.originalTop),
                width: renderer.controller.width,
                height: renderer.calcY(staff1.originalBottom) - renderer.calcY(staff1.originalTop),
                fill: renderer.foregroundColor,
                stroke: renderer.foregroundColor,
                "fill-opacity": 0.1,
                "stroke-opacity": 0.1
              }
            );
            colorIndex = 0;
            debugPrintGridItem(staff1, "chordHeightAbove");
            debugPrintGridItem(staff1, "chordHeightBelow");
            debugPrintGridItem(staff1, "dynamicHeightAbove");
            debugPrintGridItem(staff1, "dynamicHeightBelow");
            debugPrintGridItem(staff1, "endingHeightAbove");
            debugPrintGridItem(staff1, "lyricHeightAbove");
            debugPrintGridItem(staff1, "lyricHeightBelow");
            debugPrintGridItem(staff1, "partHeightAbove");
            debugPrintGridItem(staff1, "tempoHeightAbove");
            debugPrintGridItem(staff1, "volumeHeightAbove");
            debugPrintGridItem(staff1, "volumeHeightBelow");
          }
        }
        renderer.moveY(spacing.STEP, -staff1.bottom);
        if (renderer.showDebug) {
          if (renderer.showDebug.indexOf("grid") >= 0) {
            renderer.paper.dottedLine({
              x1: renderer.padding.left,
              x2: renderer.padding.left + renderer.controller.width,
              y1: renderer.y,
              y2: renderer.y,
              stroke: "#0000aa"
            });
          }
        }
      }
      var topLine;
      var bottomLine;
      var linePitch = 2;
      var bartop = 0;
      for (var i2 = 0; i2 < params.voices.length; i2++) {
        var staff = params.voices[i2].staff;
        var tabName = params.voices[i2].tabNameInfos;
        renderer.y = staff.absoluteY;
        renderer.controller.classes.incrVoice();
        if (!params.voices[i2].duplicate) {
          if (!topLine) topLine = renderer.calcY(10);
          bottomLine = renderer.calcY(linePitch);
          if (staff.lines !== 0) {
            if (staff.linePitch) {
              linePitch = staff.linePitch;
            }
            renderer.controller.classes.newMeasure();
            var lines = printStaff(renderer, params.startx, params.w, staff.lines, staff.linePitch, 0.35);
            bottomLine = lines[1];
            staff.bottomLine = bottomLine;
            staff.topLine = lines[0];
            if (staff.hasTab) {
              bartop = staff.topLine;
            }
            if (staff.hasStaff) {
              bartop = staff.hasStaff.topLine;
              params.voices[i2].barto = true;
              params.voices[i2].topLine = topLine;
            }
          }
          printBrace(renderer, staff.absoluteY, params.brace, i2, selectables);
          printBrace(renderer, staff.absoluteY, params.bracket, i2, selectables);
        }
        drawVoice(renderer, params.voices[i2], bartop, selectables, {
          top: startY,
          zero: renderer.y,
          height: params.height * spacing.STEP
        });
        var tabNameHeight = 0;
        if (tabName) {
          var r = { rows: [] };
          r.rows.push({ absmove: bottomLine + 2 });
          var leftMargin = 8;
          r.rows.push({ left: params.startx + leftMargin, text: tabName.name, font: "tablabelfont", klass: "text instrument-name", anchor: "start" });
          r.rows.push({ move: tabName.textSize.height });
          nonMusic(renderer, r);
          tabNameHeight = tabName.textSize.height;
        }
        renderer.controller.classes.newMeasure();
        if (!params.voices[i2].duplicate) {
          bartop = renderer.calcY(2 + tabNameHeight);
        }
      }
      renderer.controller.classes.newMeasure();
      var staffSize = params.staffs.length;
      if (staffSize > 1) {
        topLine = params.staffs[0].topLine;
        bottomLine = params.staffs[staffSize - 1].bottomLine;
        printStem(renderer, params.startx, 0.6, topLine, bottomLine, null);
      }
      renderer.y = startY;
      function debugPrintGridItem(staff2, key) {
        var colors = [
          "rgb(207,27,36)",
          "rgb(168,214,80)",
          "rgb(110,161,224)",
          "rgb(191,119,218)",
          "rgb(195,30,151)",
          "rgb(31,170,177)",
          "rgb(220,166,142)"
        ];
        if (staff2.positionY && staff2.positionY[key]) {
          var height = staff2.specialY[key] * spacing.STEP;
          if (key === "chordHeightAbove" && staff2.specialY.chordLines && staff2.specialY.chordLines.above)
            height *= staff2.specialY.chordLines.above;
          if (key === "chordHeightBelow" && staff2.specialY.chordLines && staff2.specialY.chordLines.below)
            height *= staff2.specialY.chordLines.below;
          printDebugBox(
            renderer,
            {
              x: renderer.padding.left,
              y: renderer.calcY(staff2.positionY[key]),
              width: renderer.controller.width,
              height,
              fill: colors[colorIndex],
              stroke: colors[colorIndex],
              "fill-opacity": 0.4,
              "stroke-opacity": 0.4
            },
            key.substr(0, 4)
          );
          colorIndex += 1;
          if (colorIndex > 6) colorIndex = 0;
        }
      }
    }
    function printBrace(renderer, absoluteY, brace, index, selectables) {
      if (brace) {
        for (var i2 = 0; i2 < brace.length; i2++) {
          if (brace[i2].isStartVoice(index)) {
            brace[i2].startY = absoluteY - spacing.STEP * 10;
            brace[i2].elemset = drawBrace(renderer, brace[i2], selectables);
          }
        }
      }
    }
    function boxAllElements(renderer, voices, which) {
      for (var i2 = 0; i2 < which.length; i2++) {
        var children = voices[which[i2]].children;
        for (var j = 0; j < children.length; j++) {
          var elem = children[j];
          var coords = elem.getFixedCoords();
          if (elem.invisible || coords.t === void 0 || coords.b === void 0)
            continue;
          var height = (coords.t - coords.b) * spacing.STEP;
          printDebugBox(
            renderer,
            {
              x: coords.x,
              y: renderer.calcY(coords.t),
              width: coords.w,
              height,
              fill: "#88e888",
              "fill-opacity": 0.4,
              stroke: "#4aa93d",
              "stroke-opacity": 0.8
            }
          );
          for (var k = 0; k < elem.children.length; k++) {
            var relElem = elem.children[k];
            var chord = relElem.getChordDim();
            if (chord) {
              var y = renderer.calcY(relElem.pitch);
              y += relElem.dim.font.size * relElem.getLane();
              printDebugBox(
                renderer,
                {
                  x: chord.left,
                  y,
                  width: chord.right - chord.left,
                  height: relElem.dim.font.size,
                  fill: "none",
                  stroke: "#4aa93d",
                  "stroke-opacity": 0.8
                }
              );
            }
          }
        }
      }
    }
    module.exports = drawStaffGroup;
  }
});

// node_modules/abcjs/src/write/draw/set-paper-size.js
var require_set_paper_size = __commonJS({
  "node_modules/abcjs/src/write/draw/set-paper-size.js"(exports, module) {
    function setPaperSize(renderer, maxwidth, scale, responsive) {
      var w = (maxwidth + renderer.padding.left + renderer.padding.right) * scale;
      var h = (renderer.y + renderer.padding.bottom) * scale;
      if (renderer.isPrint)
        h = Math.max(h, 1056);
      if (renderer.ariaLabel !== "") {
        var text = "Sheet Music";
        if (renderer.abctune && renderer.abctune.metaText && renderer.abctune.metaText.title)
          text += ' for "' + renderer.abctune.metaText.title + '"';
        renderer.paper.setTitle(text);
        var label = renderer.ariaLabel ? renderer.ariaLabel : text;
        renderer.paper.setAttribute("aria-label", label);
      }
      var styles = [
        "-webkit-touch-callout: none;",
        "-webkit-user-select: none;",
        "-khtml-user-select: none;",
        "-moz-user-select: none;",
        "-ms-user-select: none;",
        "user-select: none;"
      ];
      renderer.paper.insertStyles(".abcjs-dragging-in-progress text, .abcjs-dragging-in-progress tspan {" + styles.join(" ") + "}");
      var parentStyles = { overflow: "hidden" };
      if (responsive === "resize") {
        renderer.paper.setResponsiveWidth(w, h);
      } else {
        parentStyles.width = "";
        parentStyles.height = h + "px";
        if (scale < 1) {
          parentStyles.width = w + "px";
          renderer.paper.setSize(w / scale, h / scale);
        } else
          renderer.paper.setSize(w, h);
      }
      renderer.paper.setScale(scale);
      renderer.paper.setParentStyles(parentStyles);
    }
    module.exports = setPaperSize;
  }
});

// node_modules/abcjs/src/write/draw/selectables.js
var require_selectables = __commonJS({
  "node_modules/abcjs/src/write/draw/selectables.js"(exports, module) {
    var highlight = require_highlight();
    var unhighlight = require_unhighlight();
    function Selectables(paper, selectTypes, tuneNumber) {
      this.elements = [];
      this.paper = paper;
      this.tuneNumber = tuneNumber;
      this.selectTypes = selectTypes;
    }
    Selectables.prototype.getElements = function() {
      return this.elements;
    };
    Selectables.prototype.add = function(absEl, svgEl, isNoteOrTabNumber, staffPos) {
      if (!this.canSelect(absEl))
        return;
      var params;
      if (this.selectTypes === void 0)
        params = { selectable: false, "data-index": this.elements.length };
      else
        params = { selectable: true, tabindex: 0, "data-index": this.elements.length };
      this.paper.setAttributeOnElement(svgEl, params);
      var sel = { absEl, svgEl, isDraggable: isNoteOrTabNumber };
      if (staffPos !== void 0)
        sel.staffPos = staffPos;
      this.elements.push(sel);
    };
    Selectables.prototype.canSelect = function(absEl) {
      if (this.selectTypes === false)
        return false;
      if (!absEl || !absEl.abcelem)
        return false;
      if (this.selectTypes === true)
        return true;
      if (this.selectTypes === void 0) {
        if (absEl.abcelem.el_type === "note" || absEl.abcelem.el_type === "tabNumber") {
          return true;
        }
        return false;
      }
      return this.selectTypes.indexOf(absEl.abcelem.el_type) >= 0;
    };
    Selectables.prototype.wrapSvgEl = function(abcelem, el) {
      var absEl = {
        tuneNumber: this.tuneNumber,
        abcelem,
        elemset: [el],
        highlight,
        unhighlight
      };
      this.add(absEl, el, false);
    };
    module.exports = Selectables;
  }
});

// node_modules/abcjs/src/write/draw/draw.js
var require_draw = __commonJS({
  "node_modules/abcjs/src/write/draw/draw.js"(exports, module) {
    var drawStaffGroup = require_staff_group2();
    var setPaperSize = require_set_paper_size();
    var nonMusic = require_non_music();
    var spacing = require_spacing();
    var Selectables = require_selectables();
    function draw(renderer, classes, abcTune, width, maxWidth, responsive, scale, selectTypes, tuneNumber, lineOffset) {
      var selectables = new Selectables(renderer.paper, selectTypes, tuneNumber);
      var groupClasses = {};
      if (classes.shouldAddClasses)
        groupClasses.klass = "abcjs-meta-top";
      renderer.paper.openGroup(groupClasses);
      renderer.moveY(renderer.padding.top);
      nonMusic(renderer, abcTune.topText, selectables);
      renderer.paper.closeGroup();
      renderer.moveY(renderer.spacing.music);
      var staffgroups = [];
      for (var line = 0; line < abcTune.lines.length; line++) {
        classes.incrLine();
        var abcLine = abcTune.lines[line];
        if (abcLine.staff) {
          if (classes.shouldAddClasses)
            groupClasses.klass = "abcjs-staff-wrapper abcjs-l" + classes.lineNumber;
          renderer.paper.openGroup(groupClasses);
          if (abcLine.vskip) {
            renderer.moveY(abcLine.vskip);
          }
          if (staffgroups.length >= 1)
            addStaffPadding(renderer, renderer.spacing.staffSeparation, staffgroups[staffgroups.length - 1], abcLine.staffGroup);
          var staffgroup = engraveStaffLine(renderer, abcLine.staffGroup, selectables, line);
          staffgroup.line = lineOffset + line;
          staffgroups.push(staffgroup);
          renderer.paper.closeGroup();
        } else if (abcLine.nonMusic) {
          if (classes.shouldAddClasses)
            groupClasses.klass = "abcjs-non-music";
          renderer.paper.openGroup(groupClasses);
          nonMusic(renderer, abcLine.nonMusic, selectables);
          renderer.paper.closeGroup();
        }
      }
      classes.reset();
      if (abcTune.bottomText && abcTune.bottomText.rows && abcTune.bottomText.rows.length > 0) {
        if (classes.shouldAddClasses)
          groupClasses.klass = "abcjs-meta-bottom";
        renderer.paper.openGroup(groupClasses);
        renderer.moveY(24);
        nonMusic(renderer, abcTune.bottomText, selectables);
        renderer.paper.closeGroup();
      }
      setPaperSize(renderer, maxWidth, scale, responsive);
      return { staffgroups, selectables: selectables.getElements() };
    }
    function engraveStaffLine(renderer, staffGroup, selectables, lineNumber) {
      drawStaffGroup(renderer, staffGroup, selectables, lineNumber);
      var height = staffGroup.height * spacing.STEP;
      renderer.y += height;
      return staffGroup;
    }
    function addStaffPadding(renderer, staffSeparation, lastStaffGroup, thisStaffGroup) {
      var lastStaff = lastStaffGroup.staffs[lastStaffGroup.staffs.length - 1];
      var lastBottomLine = -(lastStaff.bottom - 2);
      var nextTopLine = thisStaffGroup.staffs[0].top - 10;
      var naturalSeparation = nextTopLine + lastBottomLine;
      var separationInPixels = naturalSeparation * spacing.STEP;
      if (separationInPixels < staffSeparation)
        renderer.moveY(staffSeparation - separationInPixels);
    }
    module.exports = draw;
  }
});

// node_modules/abcjs/src/write/interactive/find-selectable-element.js
var require_find_selectable_element = __commonJS({
  "node_modules/abcjs/src/write/interactive/find-selectable-element.js"(exports, module) {
    var createAnalysis = require_create_analysis();
    function findSelectableElement(event) {
      var selectable = event;
      while (selectable && selectable.attributes && selectable.tagName.toLowerCase() !== "svg" && !selectable.attributes.selectable) {
        selectable = selectable.parentNode;
      }
      if (selectable && selectable.attributes && selectable.attributes.selectable) {
        var index = selectable.attributes["data-index"].nodeValue;
        if (index) {
          index = parseInt(index, 10);
          if (index >= 0 && index < this.selectables.length) {
            var element = this.selectables[index];
            var ret = createAnalysis(element, event);
            ret.index = index;
            ret.element = element;
            return ret;
          }
        }
      }
      return null;
    }
    module.exports = findSelectableElement;
  }
});

// node_modules/abcjs/src/write/engraver-controller.js
var require_engraver_controller = __commonJS({
  "node_modules/abcjs/src/write/engraver-controller.js"(exports, module) {
    var spacing = require_spacing();
    var AbstractEngraver = require_abstract_engraver();
    var Renderer = require_renderer();
    var FreeText = require_free_text();
    var Separator = require_separator();
    var Subtitle = require_subtitle();
    var TopText = require_top_text();
    var BottomText = require_bottom_text();
    var setupSelection = require_selection();
    var layout = require_layout();
    var Classes = require_classes();
    var GetFontAndAttr = require_get_font_and_attr();
    var GetTextSize = require_get_text_size();
    var draw = require_draw();
    var tablatures = require_abc_tablatures();
    var findSelectableElement = require_find_selectable_element();
    var EngraverController = function(paper, params) {
      params = params || {};
      this.findSelectableElement = findSelectableElement;
      this.oneSvgPerLine = params.oneSvgPerLine;
      this.selectionColor = params.selectionColor;
      this.dragColor = params.dragColor ? params.dragColor : params.selectionColor;
      this.dragging = !!params.dragging;
      this.selectTypes = params.selectTypes;
      this.responsive = params.responsive;
      this.space = 3 * spacing.SPACE;
      this.initialClef = params.initialClef;
      this.timeBasedLayout = params.timeBasedLayout;
      this.expandToWidest = !!params.expandToWidest;
      this.scale = params.scale ? parseFloat(params.scale) : 0;
      this.classes = new Classes({ shouldAddClasses: params.add_classes });
      if (!(this.scale > 0.1))
        this.scale = void 0;
      if (params.staffwidth) {
        this.staffwidthScreen = params.staffwidth;
        this.staffwidthPrint = params.staffwidth;
      } else {
        this.staffwidthScreen = 740;
        this.staffwidthPrint = 680;
      }
      this.listeners = [];
      if (params.clickListener)
        this.addSelectListener(params.clickListener);
      this.renderer = new Renderer(paper);
      this.renderer.setPaddingOverride(params);
      if (params.showDebug)
        this.renderer.showDebug = params.showDebug;
      if (params.jazzchords)
        this.jazzchords = params.jazzchords;
      if (params.accentAbove)
        this.accentAbove = params.accentAbove;
      if (params.germanAlphabet)
        this.germanAlphabet = params.germanAlphabet;
      if (params.lineThickness)
        this.lineThickness = params.lineThickness;
      this.renderer.controller = this;
      this.renderer.foregroundColor = params.foregroundColor ? params.foregroundColor : "currentColor";
      if (params.ariaLabel !== void 0)
        this.renderer.ariaLabel = params.ariaLabel;
      this.renderer.minPadding = params.minPadding ? params.minPadding : 0;
      this.reset();
    };
    EngraverController.prototype.reset = function() {
      this.selected = [];
      this.staffgroups = [];
      if (this.engraver)
        this.engraver.reset();
      this.engraver = null;
      this.renderer.reset();
      this.dragTarget = null;
      this.dragIndex = -1;
      this.dragMouseStart = { x: -1, y: -1 };
      this.dragYStep = 0;
      if (this.lineThickness)
        this.renderer.setLineThickness(this.lineThickness);
    };
    EngraverController.prototype.engraveABC = function(abctunes, tuneNumber, lineOffset) {
      if (abctunes[0] === void 0) {
        abctunes = [abctunes];
      }
      this.reset();
      for (var i2 = 0; i2 < abctunes.length; i2++) {
        if (tuneNumber === void 0)
          tuneNumber = i2;
        this.getFontAndAttr = new GetFontAndAttr(abctunes[i2].formatting, this.classes);
        this.getTextSize = new GetTextSize(this.getFontAndAttr, this.renderer.paper);
        this.engraveTune(abctunes[i2], tuneNumber, lineOffset);
      }
    };
    EngraverController.prototype.adjustNonScaledItems = function(scale) {
      this.width /= scale;
      this.renderer.adjustNonScaledItems(scale);
    };
    EngraverController.prototype.getMeasureWidths = function(abcTune) {
      this.reset();
      this.getFontAndAttr = new GetFontAndAttr(abcTune.formatting, this.classes);
      this.getTextSize = new GetTextSize(this.getFontAndAttr, this.renderer.paper);
      var origJazzChords = this.jazzchords;
      this.setupTune(abcTune, 0);
      this.constructTuneElements(abcTune);
      layout(this.renderer, abcTune, 0, this.space, this.timeBasedLayout);
      var ret = [];
      var section;
      var needNewSection = true;
      for (var i2 = 0; i2 < abcTune.lines.length; i2++) {
        var abcLine = abcTune.lines[i2];
        if (abcLine.staff) {
          if (needNewSection) {
            section = {
              left: 0,
              measureWidths: [],
              //height: this.renderer.padding.top + this.renderer.spacing.music + this.renderer.padding.bottom + 24, // the 24 is the empirical value added to the bottom of all tunes.
              total: 0
            };
            ret.push(section);
            needNewSection = false;
          }
          if (abcLine.staffGroup.voices.length > 0) {
            var voice = abcLine.staffGroup.voices[0];
            var foundNotStaffExtra = false;
            var lastXPosition = 0;
            for (var k = 0; k < voice.children.length; k++) {
              var child = voice.children[k];
              if (!foundNotStaffExtra && !child.isClef && !child.isKeySig) {
                foundNotStaffExtra = true;
                section.left = child.x;
                lastXPosition = child.x;
              }
              if (child.type === "bar") {
                section.measureWidths.push(child.x - lastXPosition);
                section.total += child.x - lastXPosition;
                lastXPosition = child.x;
              }
            }
          }
        } else
          needNewSection = true;
      }
      this.jazzchords = origJazzChords;
      return ret;
    };
    EngraverController.prototype.setupTune = function(abcTune, tuneNumber) {
      this.classes.reset();
      if (abcTune.formatting.jazzchords !== void 0)
        this.jazzchords = abcTune.formatting.jazzchords;
      if (abcTune.formatting.accentAbove !== void 0)
        this.accentAbove = abcTune.formatting.accentAbove;
      this.renderer.newTune(abcTune);
      this.engraver = new AbstractEngraver(this.getTextSize, tuneNumber, {
        bagpipes: abcTune.formatting.bagpipes,
        flatbeams: abcTune.formatting.flatbeams,
        graceSlurs: abcTune.formatting.graceSlurs !== false,
        // undefined is the default, which is true
        percmap: abcTune.formatting.percmap,
        initialClef: this.initialClef,
        jazzchords: this.jazzchords,
        timeBasedLayout: this.timeBasedLayout,
        accentAbove: this.accentAbove,
        germanAlphabet: this.germanAlphabet
      });
      this.engraver.setStemHeight(this.renderer.spacing.stemHeight);
      this.engraver.measureLength = abcTune.getMeterFraction().num / abcTune.getMeterFraction().den;
      if (abcTune.formatting.staffwidth) {
        this.width = abcTune.formatting.staffwidth * 1.33;
      } else {
        this.width = this.renderer.isPrint ? this.staffwidthPrint : this.staffwidthScreen;
      }
      var scale = abcTune.formatting.scale ? abcTune.formatting.scale : this.scale;
      if (this.responsive === "resize")
        scale = void 0;
      if (scale === void 0) scale = this.renderer.isPrint ? 0.75 : 1;
      this.adjustNonScaledItems(scale);
      return scale;
    };
    EngraverController.prototype.constructTuneElements = function(abcTune) {
      abcTune.topText = new TopText(abcTune.metaText, abcTune.metaTextInfo, abcTune.formatting, abcTune.lines, this.width, this.renderer.isPrint, this.renderer.padding.left, this.renderer.spacing, this.classes.shouldAddClasses, this.getTextSize);
      var i2;
      var abcLine;
      var hasPrintedTempo = false;
      var hasSeenNonSubtitle = false;
      for (i2 = 0; i2 < abcTune.lines.length; i2++) {
        abcLine = abcTune.lines[i2];
        if (abcLine.staff) {
          hasSeenNonSubtitle = true;
          abcLine.staffGroup = this.engraver.createABCLine(abcLine.staff, !hasPrintedTempo ? abcTune.metaText.tempo : null, i2);
          hasPrintedTempo = true;
        } else if (abcLine.subtitle) {
          if (hasSeenNonSubtitle) {
            var center = this.width / 2 + this.renderer.padding.left;
            abcLine.nonMusic = new Subtitle(this.renderer.spacing.subtitle, abcTune.formatting, abcLine.subtitle, center, this.renderer.padding.left, this.getTextSize);
          }
        } else if (abcLine.text !== void 0) {
          hasSeenNonSubtitle = true;
          abcLine.nonMusic = new FreeText(abcLine.text, abcLine.vskip, this.getFontAndAttr, this.renderer.padding.left, this.width, this.getTextSize);
        } else if (abcLine.separator !== void 0 && abcLine.separator.lineLength) {
          hasSeenNonSubtitle = true;
          abcLine.nonMusic = new Separator(abcLine.separator.spaceAbove, abcLine.separator.lineLength, abcLine.separator.spaceBelow);
        }
      }
      abcTune.bottomText = new BottomText(abcTune.metaText, this.width, this.renderer.isPrint, this.renderer.padding.left, this.renderer.spacing, this.classes.shouldAddClasses, this.getTextSize);
    };
    EngraverController.prototype.engraveTune = function(abcTune, tuneNumber, lineOffset) {
      var origJazzChords = this.jazzchords;
      var scale = this.setupTune(abcTune, tuneNumber);
      this.constructTuneElements(abcTune);
      var maxWidth = layout(this.renderer, abcTune, this.width, this.space, this.expandToWidest, this.timeBasedLayout);
      if (this.expandToWidest && maxWidth > this.width + 1) {
        abcTune.topText = new TopText(abcTune.metaText, abcTune.metaTextInfo, abcTune.formatting, abcTune.lines, maxWidth, this.renderer.isPrint, this.renderer.padding.left, this.renderer.spacing, this.classes.shouldAddClasses, this.getTextSize);
        if (abcTune.lines && abcTune.lines.length > 0) {
          var nlines = abcTune.lines.length;
          for (var i2 = 0; i2 < nlines; ++i2) {
            var entry = abcTune.lines[i2];
            if (entry.nonMusic) {
              if (entry.nonMusic.rows && entry.nonMusic.rows.length > 0) {
                var nRows = entry.nonMusic.rows.length;
                for (var j = 0; j < nRows; ++j) {
                  var thisRow = entry.nonMusic.rows[j];
                  if (thisRow.left) {
                    if (entry.subtitle) {
                      thisRow.left = maxWidth / 2 + this.renderer.padding.left;
                    } else {
                      if (entry.text && entry.text.length > 0) {
                        if (entry.text[0].center) {
                          thisRow.left = maxWidth / 2 + this.renderer.padding.left;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (abcTune.tablatures) {
        tablatures.layoutTablatures(this.renderer, abcTune);
      }
      var ret = draw(this.renderer, this.classes, abcTune, this.width, maxWidth, this.responsive, scale, this.selectTypes, tuneNumber, lineOffset);
      this.staffgroups = ret.staffgroups;
      this.selectables = ret.selectables;
      if (this.oneSvgPerLine) {
        var div = this.renderer.paper.svg.parentNode;
        this.svgs = splitSvgIntoLines(this.renderer, div, abcTune.metaText.title, this.responsive, scale);
      } else {
        this.svgs = [this.renderer.paper.svg];
      }
      setupSelection(this, this.svgs);
      this.jazzchords = origJazzChords;
    };
    function splitSvgIntoLines(renderer, output, title, responsive, scale) {
      if (!title) title = "Untitled";
      var source = output.querySelector("svg");
      if (responsive === "resize")
        output.style.paddingBottom = "";
      var style = source.querySelector("style");
      var width = responsive === "resize" ? source.viewBox.baseVal.width : source.getAttribute("width");
      var sections = output.querySelectorAll("svg > g");
      var nextTop = 0;
      var wrappers = [];
      var svgs = [];
      for (var i2 = 0; i2 < sections.length; i2++) {
        var section = sections[i2];
        var box = section.getBBox();
        var gapBetweenLines = box.y - nextTop;
        var height = box.height + gapBetweenLines;
        var wrapper = document.createElement("div");
        var divStyles = "overflow: hidden;";
        if (responsive !== "resize")
          divStyles += "height:" + height * scale + "px;";
        wrapper.setAttribute("style", divStyles);
        var svg = duplicateSvg(source);
        var fullTitle = 'Sheet Music for "' + title + '" section ' + (i2 + 1);
        svg.setAttribute("aria-label", fullTitle);
        if (responsive !== "resize")
          svg.setAttribute("height", height);
        if (responsive === "resize")
          svg.style.position = "";
        var viewBoxHeight = renderer.firefox112 ? height + 1 : height;
        svg.setAttribute("viewBox", "0 " + nextTop + " " + width + " " + viewBoxHeight);
        svg.appendChild(style.cloneNode(true));
        var titleEl = document.createElement("title");
        titleEl.innerText = fullTitle;
        svg.appendChild(titleEl);
        svg.appendChild(section);
        wrapper.appendChild(svg);
        svgs.push(svg);
        output.appendChild(wrapper);
        nextTop = box.y + box.height;
      }
      output.removeChild(source);
      return svgs;
    }
    function duplicateSvg(source) {
      var svgNS = "http://www.w3.org/2000/svg";
      var svg = document.createElementNS(svgNS, "svg");
      for (var i2 = 0; i2 < source.attributes.length; i2++) {
        var attr = source.attributes[i2];
        if (attr.name !== "height" && attr.name != "aria-label")
          svg.setAttribute(attr.name, attr.value);
      }
      return svg;
    }
    EngraverController.prototype.getDim = function(historyEl) {
      if (!historyEl.dim) {
        var box = historyEl.svgEl.getBBox();
        historyEl.dim = { left: Math.round(box.x), top: Math.round(box.y), right: Math.round(box.x + box.width), bottom: Math.round(box.y + box.height) };
      }
      return historyEl.dim;
    };
    EngraverController.prototype.addSelectListener = function(clickListener) {
      this.listeners[this.listeners.length] = clickListener;
    };
    module.exports = EngraverController;
  }
});

// node_modules/abcjs/src/api/abc_tunebook_svg.js
var require_abc_tunebook_svg = __commonJS({
  "node_modules/abcjs/src/api/abc_tunebook_svg.js"(exports, module) {
    var tunebook = require_abc_tunebook();
    var Tune = require_abc_tune();
    var EngraverController = require_engraver_controller();
    var Parse = require_abc_parse();
    var wrap = require_wrap_lines();
    var resizeDivs = {};
    function resizeOuter() {
      var width = window.innerWidth;
      for (var id in resizeDivs) {
        if (resizeDivs.hasOwnProperty(id)) {
          var outer = resizeDivs[id];
          var ofs = outer.offsetLeft;
          width -= ofs * 2;
          outer.style.width = width + "px";
        }
      }
    }
    try {
      window.addEventListener("resize", resizeOuter);
      window.addEventListener("orientationChange", resizeOuter);
    } catch (e) {
    }
    function renderOne(div, tune, params, tuneNumber, lineOffset) {
      if (params.viewportHorizontal) {
        div.innerHTML = '<div class="abcjs-inner"></div>';
        if (params.scrollHorizontal) {
          div.style.overflowX = "auto";
          div.style.overflowY = "hidden";
        } else
          div.style.overflow = "hidden";
        resizeDivs[div.id] = div;
        div = div.children[0];
      } else if (params.viewportVertical) {
        div.innerHTML = '<div class="abcjs-inner scroll-amount"></div>';
        div.style.overflowX = "hidden";
        div.style.overflowY = "auto";
        div = div.children[0];
      } else
        div.innerHTML = "";
      var engraver_controller = new EngraverController(div, params);
      engraver_controller.engraveABC(tune, tuneNumber, lineOffset);
      tune.engraver = engraver_controller;
      if (params.viewportVertical || params.viewportHorizontal) {
        var parent = div.parentNode;
        parent.style.width = div.style.width;
      }
    }
    var renderAbc = function(output, abc, parserParams, engraverParams, renderParams) {
      var params = {};
      var key;
      if (parserParams) {
        for (key in parserParams) {
          if (parserParams.hasOwnProperty(key)) {
            params[key] = parserParams[key];
          }
        }
        if (params.warnings_id && params.tablature) {
          params.tablature.warning_id = params.warnings_id;
        }
      }
      if (engraverParams) {
        for (key in engraverParams) {
          if (engraverParams.hasOwnProperty(key)) {
            if (key === "listener") {
              if (engraverParams[key].highlight)
                params.clickListener = engraverParams[key].highlight;
            } else
              params[key] = engraverParams[key];
          }
        }
      }
      if (renderParams) {
        for (key in renderParams) {
          if (renderParams.hasOwnProperty(key)) {
            params[key] = renderParams[key];
          }
        }
      }
      function callback(div, tune, tuneNumber, abcString) {
        var removeDiv = false;
        if (div === "*") {
          removeDiv = true;
          div = document.createElement("div");
          div.setAttribute("style", "visibility: hidden;");
          document.body.appendChild(div);
        }
        if (!removeDiv && params.wrap && params.staffwidth) {
          tune = doLineWrapping(div, tune, tuneNumber, abcString, params);
          return tune;
        }
        if (params.afterParsing)
          params.afterParsing(tune, tuneNumber, abcString);
        renderOne(div, tune, params, tuneNumber, 0);
        if (removeDiv)
          div.parentNode.removeChild(div);
        return null;
      }
      return tunebook.renderEngine(callback, output, abc, params);
    };
    function doLineWrapping(div, tune, tuneNumber, abcString, params) {
      var engraver_controller = new EngraverController(div, params);
      var widths = engraver_controller.getMeasureWidths(tune);
      var ret = wrap.calcLineWraps(tune, widths, params);
      if (ret.reParse) {
        var abcParser = new Parse();
        abcParser.parse(abcString, ret.revisedParams);
        tune = abcParser.getTune();
        var warnings = abcParser.getWarnings();
        if (warnings)
          tune.warnings = warnings;
      }
      if (params.afterParsing)
        params.afterParsing(tune, tuneNumber, abcString);
      renderOne(div, tune, ret.revisedParams, tuneNumber, 0);
      tune.explanation = ret.explanation;
      return tune;
    }
    module.exports = renderAbc;
  }
});

// node_modules/abcjs/src/api/tune-metrics.js
var require_tune_metrics = __commonJS({
  "node_modules/abcjs/src/api/tune-metrics.js"(exports, module) {
    var tunebook = require_abc_tunebook();
    var EngraverController = require_engraver_controller();
    var tuneMetrics = function(abc, params) {
      function callback(div, tune, tuneNumber, abcString) {
        div = document.createElement("div");
        div.setAttribute("style", "visibility: hidden;");
        document.body.appendChild(div);
        var engraver_controller = new EngraverController(div, params);
        var widths = engraver_controller.getMeasureWidths(tune);
        div.parentNode.removeChild(div);
        return { sections: widths };
      }
      return tunebook.renderEngine(callback, "*", abc, params);
    };
    module.exports = tuneMetrics;
  }
});

// node_modules/abcjs/src/synth/sounds-cache.js
var require_sounds_cache = __commonJS({
  "node_modules/abcjs/src/synth/sounds-cache.js"(exports, module) {
    var soundsCache = {};
    module.exports = soundsCache;
  }
});

// node_modules/abcjs/src/synth/load-note.js
var require_load_note = __commonJS({
  "node_modules/abcjs/src/synth/load-note.js"(exports, module) {
    var soundsCache = require_sounds_cache();
    var getNote = function(url, instrument, name, audioContext) {
      if (!soundsCache[instrument]) soundsCache[instrument] = {};
      var instrumentCache = soundsCache[instrument];
      if (!instrumentCache[name])
        instrumentCache[name] = new Promise(function(resolve, reject) {
          var xhr = new XMLHttpRequest();
          let noteUrl = url + instrument + "-mp3/" + name + ".mp3";
          xhr.open("GET", noteUrl, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            if (xhr.status !== 200) {
              reject(Error("Can't load sound at " + noteUrl + " status=" + xhr.status));
              return;
            }
            var noteDecoded = function(audioBuffer) {
              resolve({ instrument, name, status: "loaded", audioBuffer });
            };
            var maybePromise = audioContext.decodeAudioData(xhr.response, noteDecoded, function() {
              reject(Error("Can't decode sound at " + noteUrl));
            });
            if (maybePromise && typeof maybePromise.catch === "function") maybePromise.catch(reject);
          };
          xhr.onerror = function() {
            reject(Error("Can't load sound at " + noteUrl));
          };
          xhr.send();
        }).catch((err) => {
          console.error("Didn't load note", instrument, name, ":", err.message);
          throw err;
        });
      return instrumentCache[name];
    };
    module.exports = getNote;
  }
});

// node_modules/abcjs/src/synth/instrument-index-to-name.js
var require_instrument_index_to_name = __commonJS({
  "node_modules/abcjs/src/synth/instrument-index-to-name.js"(exports, module) {
    var instrumentIndexToName = [
      "acoustic_grand_piano",
      "bright_acoustic_piano",
      "electric_grand_piano",
      "honkytonk_piano",
      "electric_piano_1",
      "electric_piano_2",
      "harpsichord",
      "clavinet",
      "celesta",
      "glockenspiel",
      "music_box",
      "vibraphone",
      "marimba",
      "xylophone",
      "tubular_bells",
      "dulcimer",
      "drawbar_organ",
      "percussive_organ",
      "rock_organ",
      "church_organ",
      "reed_organ",
      "accordion",
      "harmonica",
      "tango_accordion",
      "acoustic_guitar_nylon",
      "acoustic_guitar_steel",
      "electric_guitar_jazz",
      "electric_guitar_clean",
      "electric_guitar_muted",
      "overdriven_guitar",
      "distortion_guitar",
      "guitar_harmonics",
      "acoustic_bass",
      "electric_bass_finger",
      "electric_bass_pick",
      "fretless_bass",
      "slap_bass_1",
      "slap_bass_2",
      "synth_bass_1",
      "synth_bass_2",
      "violin",
      "viola",
      "cello",
      "contrabass",
      "tremolo_strings",
      "pizzicato_strings",
      "orchestral_harp",
      "timpani",
      "string_ensemble_1",
      "string_ensemble_2",
      "synth_strings_1",
      "synth_strings_2",
      "choir_aahs",
      "voice_oohs",
      "synth_choir",
      "orchestra_hit",
      "trumpet",
      "trombone",
      "tuba",
      "muted_trumpet",
      "french_horn",
      "brass_section",
      "synth_brass_1",
      "synth_brass_2",
      "soprano_sax",
      "alto_sax",
      "tenor_sax",
      "baritone_sax",
      "oboe",
      "english_horn",
      "bassoon",
      "clarinet",
      "piccolo",
      "flute",
      "recorder",
      "pan_flute",
      "blown_bottle",
      "shakuhachi",
      "whistle",
      "ocarina",
      "lead_1_square",
      "lead_2_sawtooth",
      "lead_3_calliope",
      "lead_4_chiff",
      "lead_5_charang",
      "lead_6_voice",
      "lead_7_fifths",
      "lead_8_bass_lead",
      "pad_1_new_age",
      "pad_2_warm",
      "pad_3_polysynth",
      "pad_4_choir",
      "pad_5_bowed",
      "pad_6_metallic",
      "pad_7_halo",
      "pad_8_sweep",
      "fx_1_rain",
      "fx_2_soundtrack",
      "fx_3_crystal",
      "fx_4_atmosphere",
      "fx_5_brightness",
      "fx_6_goblins",
      "fx_7_echoes",
      "fx_8_scifi",
      "sitar",
      "banjo",
      "shamisen",
      "koto",
      "kalimba",
      "bagpipe",
      "fiddle",
      "shanai",
      "tinkle_bell",
      "agogo",
      "steel_drums",
      "woodblock",
      "taiko_drum",
      "melodic_tom",
      "synth_drum",
      "reverse_cymbal",
      "guitar_fret_noise",
      "breath_noise",
      "seashore",
      "bird_tweet",
      "telephone_ring",
      "helicopter",
      "applause",
      "gunshot",
      "percussion"
    ];
    module.exports = instrumentIndexToName;
  }
});

// node_modules/abcjs/src/synth/create-note-map.js
var require_create_note_map = __commonJS({
  "node_modules/abcjs/src/synth/create-note-map.js"(exports, module) {
    var instrumentIndexToName = require_instrument_index_to_name();
    var createNoteMap = function(sequence) {
      var map = [];
      for (var i2 = 0; i2 < sequence.tracks.length; i2++)
        map.push([]);
      var nextNote = {};
      var currentInstrument = instrumentIndexToName[0];
      sequence.tracks.forEach(function(track, i3) {
        track.forEach(function(ev) {
          switch (ev.cmd) {
            case "note":
              var inst = ev.instrument !== void 0 ? instrumentIndexToName[ev.instrument] : currentInstrument;
              if (ev.duration > 0) {
                var gap = ev.gap ? ev.gap : 0;
                var len = ev.duration;
                gap = Math.min(gap, len * 2 / 3);
                var obj = {
                  pitch: ev.pitch,
                  instrument: inst,
                  start: Math.round(ev.start * 1e6) / 1e6,
                  end: Math.round((ev.start + len - gap) * 1e6) / 1e6,
                  volume: ev.volume
                };
                if (ev.startChar)
                  obj.startChar = ev.startChar;
                if (ev.endChar)
                  obj.endChar = ev.endChar;
                if (ev.style)
                  obj.style = ev.style;
                if (ev.cents)
                  obj.cents = ev.cents;
                map[i3].push(obj);
              }
              break;
            case "program":
              currentInstrument = instrumentIndexToName[ev.instrument];
              break;
            case "text":
              break;
            default:
              console.log("Unhandled midi event", ev);
          }
        });
      });
      return map;
    };
    module.exports = createNoteMap;
  }
});

// node_modules/abcjs/src/synth/register-audio-context.js
var require_register_audio_context = __commonJS({
  "node_modules/abcjs/src/synth/register-audio-context.js"(exports, module) {
    function registerAudioContext(ac) {
      if (ac)
        window.abcjsAudioContext = ac;
      else {
        if (!window.abcjsAudioContext) {
          var AudioContext = window.AudioContext || window.webkitAudioContext;
          if (AudioContext)
            window.abcjsAudioContext = new AudioContext();
          else
            return false;
        }
      }
      return window.abcjsAudioContext.state !== "suspended";
    }
    module.exports = registerAudioContext;
  }
});

// node_modules/abcjs/src/synth/active-audio-context.js
var require_active_audio_context = __commonJS({
  "node_modules/abcjs/src/synth/active-audio-context.js"(exports, module) {
    var registerAudioContext = require_register_audio_context();
    function activeAudioContext() {
      if (!window.abcjsAudioContext)
        registerAudioContext();
      return window.abcjsAudioContext;
    }
    module.exports = activeAudioContext;
  }
});

// node_modules/abcjs/src/synth/supports-audio.js
var require_supports_audio = __commonJS({
  "node_modules/abcjs/src/synth/supports-audio.js"(exports, module) {
    var activeAudioContext = require_active_audio_context();
    function supportsAudio() {
      if (!window.Promise)
        return false;
      if (!window.AudioContext && !window.webkitAudioContext && !navigator.mozAudioContext && !navigator.msAudioContext)
        return false;
      var aac = activeAudioContext();
      if (aac)
        return aac.resume !== void 0;
    }
    module.exports = supportsAudio;
  }
});

// node_modules/abcjs/src/synth/pitch-to-note-name.js
var require_pitch_to_note_name = __commonJS({
  "node_modules/abcjs/src/synth/pitch-to-note-name.js"(exports, module) {
    var pitchToNoteName = {
      21: "A0",
      22: "Bb0",
      23: "B0",
      24: "C1",
      25: "Db1",
      26: "D1",
      27: "Eb1",
      28: "E1",
      29: "F1",
      30: "Gb1",
      31: "G1",
      32: "Ab1",
      33: "A1",
      34: "Bb1",
      35: "B1",
      36: "C2",
      37: "Db2",
      38: "D2",
      39: "Eb2",
      40: "E2",
      41: "F2",
      42: "Gb2",
      43: "G2",
      44: "Ab2",
      45: "A2",
      46: "Bb2",
      47: "B2",
      48: "C3",
      49: "Db3",
      50: "D3",
      51: "Eb3",
      52: "E3",
      53: "F3",
      54: "Gb3",
      55: "G3",
      56: "Ab3",
      57: "A3",
      58: "Bb3",
      59: "B3",
      60: "C4",
      61: "Db4",
      62: "D4",
      63: "Eb4",
      64: "E4",
      65: "F4",
      66: "Gb4",
      67: "G4",
      68: "Ab4",
      69: "A4",
      70: "Bb4",
      71: "B4",
      72: "C5",
      73: "Db5",
      74: "D5",
      75: "Eb5",
      76: "E5",
      77: "F5",
      78: "Gb5",
      79: "G5",
      80: "Ab5",
      81: "A5",
      82: "Bb5",
      83: "B5",
      84: "C6",
      85: "Db6",
      86: "D6",
      87: "Eb6",
      88: "E6",
      89: "F6",
      90: "Gb6",
      91: "G6",
      92: "Ab6",
      93: "A6",
      94: "Bb6",
      95: "B6",
      96: "C7",
      97: "Db7",
      98: "D7",
      99: "Eb7",
      100: "E7",
      101: "F7",
      102: "Gb7",
      103: "G7",
      104: "Ab7",
      105: "A7",
      106: "Bb7",
      107: "B7",
      108: "C8",
      109: "Db8",
      110: "D8",
      111: "Eb8",
      112: "E8",
      113: "F8",
      114: "Gb8",
      115: "G8",
      116: "Ab8",
      117: "A8",
      118: "Bb8",
      119: "B8",
      120: "C9",
      121: "Db9"
    };
    module.exports = pitchToNoteName;
  }
});

// node_modules/abcjs/src/synth/download-buffer.js
var require_download_buffer = __commonJS({
  "node_modules/abcjs/src/synth/download-buffer.js"(exports, module) {
    var downloadBuffer = function(buffer) {
      return window.URL.createObjectURL(bufferToWave(buffer.audioBuffers));
    };
    function bufferToWave(audioBuffers) {
      var audioBuffer = audioBuffers[0];
      var numOfChan = audioBuffer.numberOfChannels;
      var length = audioBuffer.length * numOfChan * 2 + 44;
      var buffer = new ArrayBuffer(length);
      var view = new DataView(buffer);
      var channels = [];
      var i2;
      var sample;
      var offset = 0;
      var pos = 0;
      setUint32(1179011410);
      setUint32(length - 8);
      setUint32(1163280727);
      setUint32(544501094);
      setUint32(16);
      setUint16(1);
      setUint16(numOfChan);
      setUint32(audioBuffer.sampleRate);
      setUint32(audioBuffer.sampleRate * 2 * numOfChan);
      setUint16(numOfChan * 2);
      setUint16(16);
      setUint32(1635017060);
      setUint32(length - pos - 4);
      for (i2 = 0; i2 < numOfChan; i2++)
        channels.push(audioBuffer.getChannelData(i2));
      while (pos < length) {
        for (i2 = 0; i2 < channels.length; i2++) {
          sample = Math.max(-1, Math.min(1, channels[i2][offset]));
          sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
          view.setInt16(pos, sample, true);
          pos += 2;
        }
        offset++;
      }
      return new Blob([buffer], { type: "audio/wav" });
      function setUint16(data) {
        view.setUint16(pos, data, true);
        pos += 2;
      }
      function setUint32(data) {
        view.setUint32(pos, data, true);
        pos += 4;
      }
    }
    module.exports = downloadBuffer;
  }
});

// node_modules/abcjs/src/synth/cents-to-factor.js
var require_cents_to_factor = __commonJS({
  "node_modules/abcjs/src/synth/cents-to-factor.js"(exports, module) {
    function centsToFactor(cents) {
      return Math.pow(2, cents / 1200);
    }
    module.exports = centsToFactor;
  }
});

// node_modules/abcjs/src/synth/place-note.js
var require_place_note = __commonJS({
  "node_modules/abcjs/src/synth/place-note.js"(exports, module) {
    var soundsCache = require_sounds_cache();
    var pitchToNoteName = require_pitch_to_note_name();
    var centsToFactor = require_cents_to_factor();
    function placeNote(outputAudioBuffer, sampleRate, sound, startArray, volumeMultiplier, ofsMs, fadeTimeSec, noteEndSec, debugCallback) {
      var OfflineAC = window.OfflineAudioContext || window.webkitOfflineAudioContext;
      var len = sound.len * sound.tempoMultiplier;
      if (ofsMs)
        len += ofsMs / 1e3;
      len -= noteEndSec;
      if (len < 0)
        len = 5e-3;
      var offlineCtx = new OfflineAC(2, Math.floor((len + fadeTimeSec) * sampleRate), sampleRate);
      var noteName = pitchToNoteName[sound.pitch];
      if (!soundsCache[sound.instrument]) {
        if (debugCallback)
          debugCallback("placeNote skipped (instrument empty): " + sound.instrument + ":" + noteName);
        return Promise.resolve();
      }
      var noteBufferPromise = soundsCache[sound.instrument][noteName];
      if (!noteBufferPromise) {
        if (debugCallback)
          debugCallback("placeNote skipped: " + sound.instrument + ":" + noteName);
        return Promise.resolve();
      }
      return noteBufferPromise.then(function(response) {
        var source = offlineCtx.createBufferSource();
        source.buffer = response.audioBuffer;
        var volume = sound.volume / 96 * volumeMultiplier;
        source.gainNode = offlineCtx.createGain();
        if (sound.pan && offlineCtx.createStereoPanner) {
          source.panNode = offlineCtx.createStereoPanner();
          source.panNode.pan.setValueAtTime(sound.pan, 0);
        }
        source.gainNode.gain.value = volume;
        source.gainNode.gain.linearRampToValueAtTime(source.gainNode.gain.value, len);
        source.gainNode.gain.linearRampToValueAtTime(0, len + fadeTimeSec);
        if (sound.cents) {
          source.playbackRate.value = centsToFactor(sound.cents);
        }
        if (source.panNode) {
          source.panNode.connect(offlineCtx.destination);
          source.gainNode.connect(source.panNode);
        } else {
          source.gainNode.connect(offlineCtx.destination);
        }
        source.connect(source.gainNode);
        source.start(0);
        if (source.noteOff) {
          source.noteOff(len + fadeTimeSec);
        } else {
          source.stop(len + fadeTimeSec);
        }
        var fnResolve;
        offlineCtx.oncomplete = function(e) {
          if (e.renderedBuffer && e.renderedBuffer.getChannelData) {
            for (var i2 = 0; i2 < startArray.length; i2++) {
              var start = startArray[i2] * sound.tempoMultiplier;
              if (ofsMs)
                start -= ofsMs / 1e3;
              if (start < 0)
                start = 0;
              start = Math.floor(start * sampleRate);
              copyToChannel(outputAudioBuffer, e.renderedBuffer, start);
            }
          }
          if (debugCallback)
            debugCallback("placeNote: " + sound.instrument + ":" + noteName);
          fnResolve();
        };
        offlineCtx.startRendering();
        return new Promise(function(resolve) {
          fnResolve = resolve;
        });
      }).catch(function(error) {
        if (debugCallback)
          debugCallback("placeNote catch: " + error.message);
        return Promise.resolve();
      });
    }
    var copyToChannel = function(toBuffer, fromBuffer, start) {
      for (var ch = 0; ch < 2; ch++) {
        var fromData = fromBuffer.getChannelData(ch);
        var toData = toBuffer.getChannelData(ch);
        for (var n = 0; n < fromData.length; n++) {
          toData[n + start] += fromData[n];
        }
      }
    };
    module.exports = placeNote;
  }
});

// node_modules/abcjs/src/synth/create-synth.js
var require_create_synth = __commonJS({
  "node_modules/abcjs/src/synth/create-synth.js"(exports, module) {
    var getNote = require_load_note();
    var createNoteMap = require_create_note_map();
    var registerAudioContext = require_register_audio_context();
    var activeAudioContext = require_active_audio_context();
    var supportsAudio = require_supports_audio();
    var pitchToNoteName = require_pitch_to_note_name();
    var instrumentIndexToName = require_instrument_index_to_name();
    var downloadBuffer = require_download_buffer();
    var placeNote = require_place_note();
    var soundsCache = require_sounds_cache();
    var notSupportedMessage = "MIDI is not supported in this browser.";
    var originalSoundFontUrl = "https://paulrosen.github.io/midi-js-soundfonts/abcjs/";
    var defaultSoundFontUrl = "https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/";
    var alternateSoundFontUrl = "https://paulrosen.github.io/midi-js-soundfonts/MusyngKite/";
    function CreateSynth() {
      var self = this;
      self.audioBufferPossible = void 0;
      self.directSource = [];
      self.startTimeSec = void 0;
      self.pausedTimeSec = void 0;
      self.audioBuffers = [];
      self.duration = void 0;
      self.isRunning = false;
      self.options = void 0;
      self.pickupLength = 0;
      self.init = function(options) {
        if (!options)
          options = {};
        if (options.options)
          self.options = options.options;
        registerAudioContext(options.audioContext);
        var startTime = activeAudioContext().currentTime;
        self.debugCallback = options.debugCallback;
        if (self.debugCallback)
          self.debugCallback("init called");
        self.audioBufferPossible = self._deviceCapable();
        if (!self.audioBufferPossible)
          return Promise.reject({ status: "NotSupported", message: notSupportedMessage });
        var params = options.options ? options.options : {};
        self.soundFontUrl = params.soundFontUrl ? params.soundFontUrl : defaultSoundFontUrl;
        if (self.soundFontUrl[self.soundFontUrl.length - 1] !== "/")
          self.soundFontUrl += "/";
        if (params.soundFontVolumeMultiplier || params.soundFontVolumeMultiplier === 0)
          self.soundFontVolumeMultiplier = params.soundFontVolumeMultiplier;
        else if (self.soundFontUrl === defaultSoundFontUrl || self.soundFontUrl === alternateSoundFontUrl)
          self.soundFontVolumeMultiplier = 3;
        else if (self.soundFontUrl === originalSoundFontUrl)
          self.soundFontVolumeMultiplier = 0.4;
        else
          self.soundFontVolumeMultiplier = 1;
        if (params.programOffsets)
          self.programOffsets = params.programOffsets;
        else if (self.soundFontUrl === originalSoundFontUrl)
          self.programOffsets = {
            "bright_acoustic_piano": 20,
            "honkytonk_piano": 20,
            "electric_piano_1": 30,
            "electric_piano_2": 30,
            "harpsichord": 40,
            "clavinet": 20,
            "celesta": 20,
            "glockenspiel": 40,
            "vibraphone": 30,
            "marimba": 35,
            "xylophone": 30,
            "tubular_bells": 35,
            "dulcimer": 30,
            "drawbar_organ": 20,
            "percussive_organ": 25,
            "rock_organ": 20,
            "church_organ": 40,
            "reed_organ": 40,
            "accordion": 40,
            "harmonica": 40,
            "acoustic_guitar_nylon": 20,
            "acoustic_guitar_steel": 30,
            "electric_guitar_jazz": 25,
            "electric_guitar_clean": 15,
            "electric_guitar_muted": 35,
            "overdriven_guitar": 25,
            "distortion_guitar": 20,
            "guitar_harmonics": 30,
            "electric_bass_finger": 15,
            "electric_bass_pick": 30,
            "fretless_bass": 40,
            "violin": 105,
            "viola": 50,
            "cello": 40,
            "contrabass": 60,
            "trumpet": 10,
            "trombone": 90,
            "alto_sax": 20,
            "tenor_sax": 20,
            "clarinet": 20,
            "flute": 50,
            "banjo": 50,
            "woodblock": 20
          };
        else
          self.programOffsets = {};
        var p = params.fadeLength !== void 0 ? parseInt(params.fadeLength, 10) : NaN;
        self.fadeLength = isNaN(p) ? 200 : p;
        p = params.noteEnd !== void 0 ? parseInt(params.noteEnd, 10) : NaN;
        self.noteEnd = isNaN(p) ? 0 : p;
        self.pan = params.pan;
        self.meterSize = 1;
        if (options.visualObj) {
          self.flattened = options.visualObj.setUpAudio(params);
          var meter = options.visualObj.getMeterFraction();
          if (meter.den)
            self.meterSize = options.visualObj.getMeterFraction().num / options.visualObj.getMeterFraction().den;
          self.pickupLength = options.visualObj.getPickupLength();
        } else if (options.sequence)
          self.flattened = options.sequence;
        else
          return Promise.reject(new Error("Must pass in either a visualObj or a sequence"));
        self.millisecondsPerMeasure = options.millisecondsPerMeasure ? options.millisecondsPerMeasure : options.visualObj ? options.visualObj.millisecondsPerMeasure(self.flattened.tempo) : 1e3;
        self.beatsPerMeasure = options.visualObj ? options.visualObj.getBeatsPerMeasure() : 4;
        self.sequenceCallback = params.sequenceCallback;
        self.callbackContext = params.callbackContext;
        self.onEnded = params.onEnded;
        self.meterFraction = options.visualObj ? options.visualObj.getMeterFraction() : { den: 1 };
        var allNotes = {};
        var cached = [];
        var errorNotes = [];
        var currentInstrument = instrumentIndexToName[0];
        self.flattened.tracks.forEach(function(track) {
          track.forEach(function(event) {
            if (event.cmd === "program" && instrumentIndexToName[event.instrument])
              currentInstrument = instrumentIndexToName[event.instrument];
            if (event.pitch !== void 0) {
              var pitchNumber = event.pitch;
              var noteName = pitchToNoteName[pitchNumber];
              var inst = event.instrument !== void 0 ? instrumentIndexToName[event.instrument] : currentInstrument;
              if (noteName) {
                if (!allNotes[inst])
                  allNotes[inst] = {};
                if (!soundsCache[inst] || !soundsCache[inst][noteName])
                  allNotes[inst][noteName] = true;
                else {
                  var label2 = inst + ":" + noteName;
                  if (cached.indexOf(label2) < 0)
                    cached.push(label2);
                }
              } else {
                var label = inst + ":" + noteName;
                console.log("Can't find note: ", pitchNumber, label);
                if (errorNotes.indexOf(label) < 0)
                  errorNotes.push(label);
              }
            }
          });
        });
        if (self.debugCallback)
          self.debugCallback("note gathering time = " + Math.floor((activeAudioContext().currentTime - startTime) * 1e3) + "ms");
        startTime = activeAudioContext().currentTime;
        var notes = [];
        Object.keys(allNotes).forEach(function(instrument) {
          Object.keys(allNotes[instrument]).forEach(function(note) {
            notes.push({ instrument, note });
          });
        });
        if (self.debugCallback)
          self.debugCallback("notes " + JSON.stringify(notes));
        var batches = [];
        var CHUNK = 256;
        for (var i2 = 0; i2 < notes.length; i2 += CHUNK) {
          batches.push(notes.slice(i2, i2 + CHUNK));
        }
        return new Promise(function(resolve, reject) {
          var results = {
            cached,
            error: errorNotes,
            loaded: []
          };
          var index = 0;
          var next = function() {
            if (self.debugCallback)
              self.debugCallback("loadBatch idx=" + index + " len=" + batches.length);
            if (index < batches.length) {
              self._loadBatch(batches[index], self.soundFontUrl, startTime).then(function(data) {
                if (self.debugCallback)
                  self.debugCallback("loadBatch then");
                startTime = activeAudioContext().currentTime;
                if (data) {
                  if (data.error)
                    results.error = results.error.concat(data.error);
                  if (data.loaded)
                    results.loaded = results.loaded.concat(data.loaded);
                }
                index++;
                next();
              }, reject);
            } else {
              if (self.debugCallback)
                self.debugCallback("resolve init");
              resolve(results);
            }
          };
          next();
        });
      };
      self._loadBatch = function(batch, soundFontUrl, startTime, delay) {
        var promises = [];
        batch.forEach(function(item) {
          if (self.debugCallback)
            self.debugCallback("getNote " + item.instrument + ":" + item.note);
          promises.push(getNote(soundFontUrl, item.instrument, item.note, activeAudioContext()));
        });
        return Promise.all(promises).then(function(response) {
          if (self.debugCallback)
            self.debugCallback("mp3 load time = " + Math.floor((activeAudioContext().currentTime - startTime) * 1e3) + "ms");
          var loaded = [];
          var cached = [];
          var pending = [];
          var error = [];
          for (var i2 = 0; i2 < response.length; i2++) {
            var oneResponse = response[i2];
            var which = oneResponse.instrument + ":" + oneResponse.name;
            if (oneResponse.status === "loaded")
              loaded.push(which);
            else if (oneResponse.status === "pending")
              pending.push(which);
            else if (oneResponse.status === "cached")
              cached.push(which);
            else
              error.push(which + " " + oneResponse.message);
          }
          if (pending.length > 0) {
            if (self.debugCallback)
              self.debugCallback("pending " + JSON.stringify(pending));
            if (!delay)
              delay = 50;
            else
              delay = delay * 2;
            if (delay < 9e4) {
              return new Promise(function(resolve, reject) {
                setTimeout(function() {
                  var newBatch = [];
                  for (i2 = 0; i2 < pending.length; i2++) {
                    which = pending[i2].split(":");
                    newBatch.push({ instrument: which[0], note: which[1] });
                  }
                  if (self.debugCallback)
                    self.debugCallback("retry " + JSON.stringify(newBatch));
                  self._loadBatch(newBatch, soundFontUrl, startTime, delay).then(function(response2) {
                    resolve(response2);
                  }).catch(function(error2) {
                    reject(error2);
                  });
                }, delay);
              });
            } else {
              var list = [];
              for (var j = 0; j < batch.length; j++)
                list.push(batch[j].instrument + "/" + batch[j].note);
              if (self.debugCallback)
                self.debugCallback("loadBatch timeout");
              return Promise.reject(new Error("timeout attempting to load: " + list.join(", ")));
            }
          } else {
            if (self.debugCallback)
              self.debugCallback("loadBatch resolve");
            return Promise.resolve({ loaded, cached, error });
          }
        }).catch(function(error) {
          if (self.debugCallback)
            self.debugCallback("loadBatch catch " + error.message);
        });
      };
      self.prime = function() {
        var fadeTimeSec = self.fadeLength / 1e3;
        self.isRunning = false;
        if (!self.audioBufferPossible)
          return Promise.reject(new Error(notSupportedMessage));
        if (self.debugCallback)
          self.debugCallback("prime called");
        return new Promise(function(resolve) {
          var startTime = activeAudioContext().currentTime;
          var tempoMultiplier = self.millisecondsPerMeasure / 1e3 / self.meterSize;
          self.duration = self.flattened.totalDuration * tempoMultiplier;
          if (self.duration <= 0) {
            self.audioBuffers = [];
            return resolve({ status: "empty", seconds: 0 });
          }
          self.duration += fadeTimeSec;
          var totalSamples = Math.floor(activeAudioContext().sampleRate * self.duration);
          self.stop();
          var noteMapTracks = createNoteMap(self.flattened);
          if (self.options.swing)
            addSwing(noteMapTracks, self.options.swing, self.meterFraction, self.pickupLength);
          if (self.sequenceCallback)
            self.sequenceCallback(noteMapTracks, self.callbackContext);
          var panDistances = setPan(noteMapTracks.length, self.pan);
          var uniqueSounds = {};
          noteMapTracks.forEach(function(noteMap, trackNumber) {
            var panDistance = panDistances && panDistances.length > trackNumber ? panDistances[trackNumber] : 0;
            noteMap.forEach(function(note) {
              var key = note.instrument + ":" + note.pitch + ":" + note.volume + ":" + Math.round((note.end - note.start) * 1e3) / 1e3 + ":" + panDistance + ":" + tempoMultiplier + ":" + (note.cents ? note.cents : 0);
              if (self.debugCallback)
                self.debugCallback("noteMapTrack " + key);
              if (!uniqueSounds[key])
                uniqueSounds[key] = [];
              uniqueSounds[key].push(note.start);
            });
          });
          var allPromises = [];
          var audioBuffer = activeAudioContext().createBuffer(2, totalSamples, activeAudioContext().sampleRate);
          for (var key2 = 0; key2 < Object.keys(uniqueSounds).length; key2++) {
            var k = Object.keys(uniqueSounds)[key2];
            var parts = k.split(":");
            var cents = parts[6] !== void 0 ? parseFloat(parts[6]) : 0;
            parts = { instrument: parts[0], pitch: parseInt(parts[1], 10), volume: parseInt(parts[2], 10), len: parseFloat(parts[3]), pan: parseFloat(parts[4]), tempoMultiplier: parseFloat(parts[5]), cents };
            allPromises.push(placeNote(audioBuffer, activeAudioContext().sampleRate, parts, uniqueSounds[k], self.soundFontVolumeMultiplier, self.programOffsets[parts.instrument], fadeTimeSec, self.noteEnd / 1e3, self.debugCallback));
          }
          self.audioBuffers = [audioBuffer];
          if (self.debugCallback) {
            self.debugCallback("sampleRate = " + activeAudioContext().sampleRate);
            self.debugCallback("totalSamples = " + totalSamples);
            self.debugCallback("creationTime = " + Math.floor((activeAudioContext().currentTime - startTime) * 1e3) + "ms");
          }
          function resolveData(me) {
            var duration = me && me.audioBuffers && me.audioBuffers.length > 0 ? me.audioBuffers[0].duration : 0;
            return { status: activeAudioContext().state, duration };
          }
          Promise.all(allPromises).then(function() {
            if (activeAudioContext().state === "suspended") {
              activeAudioContext().resume().then(function() {
                resolve(resolveData(self));
              });
            } else if (activeAudioContext().state === "interrupted") {
              activeAudioContext().suspend().then(function() {
                activeAudioContext().resume().then(function() {
                  resolve(resolveData(self));
                });
              });
            } else {
              resolve(resolveData(self));
            }
          });
        });
      };
      function setPan(numTracks, panParam) {
        if (panParam === null || panParam === void 0)
          return null;
        var panDistances = [];
        if (panParam.length) {
          for (var pp = 0; pp < numTracks; pp++) {
            if (pp < panParam.length) {
              var x = parseFloat(panParam[pp]);
              if (x < -1)
                x = -1;
              else if (x > 1)
                x = 1;
              panDistances.push(x);
            } else
              panDistances.push(0);
          }
          return panDistances;
        } else {
          var panNumber = parseFloat(panParam);
          if (panNumber * (numTracks - 1) > 2)
            return null;
          var even = numTracks % 2 === 0;
          var currLow = even ? 0 - panNumber / 2 : 0;
          var currHigh = currLow + panNumber;
          for (var p = 0; p < numTracks; p++) {
            even = p % 2 === 0;
            if (even) {
              panDistances.push(currLow);
              currLow -= panNumber;
            } else {
              panDistances.push(currHigh);
              currHigh += panNumber;
            }
          }
          return panDistances;
        }
        return null;
      }
      self.start = function() {
        if (!self.audioBufferPossible)
          throw new Error(notSupportedMessage);
        if (self.debugCallback)
          self.debugCallback("start called");
        var resumePosition = self.pausedTimeSec ? self.pausedTimeSec : 0;
        self._kickOffSound(resumePosition);
        self.startTimeSec = activeAudioContext().currentTime - resumePosition;
        self.pausedTimeSec = void 0;
        if (self.debugCallback)
          self.debugCallback("MIDI STARTED", self.startTimeSec);
      };
      self.pause = function() {
        if (!self.audioBufferPossible)
          throw new Error(notSupportedMessage);
        if (self.debugCallback)
          self.debugCallback("pause called");
        self.pausedTimeSec = self.stop();
        return self.pausedTimeSec;
      };
      self.resume = function() {
        self.start();
      };
      self.seek = function(position, units) {
        var offset;
        switch (units) {
          case "seconds":
            offset = position;
            break;
          case "beats":
            offset = position * self.millisecondsPerMeasure / self.beatsPerMeasure / 1e3;
            break;
          default:
            offset = (self.duration - self.fadeLength / 1e3) * position;
            break;
        }
        if (!self.audioBufferPossible)
          throw new Error(notSupportedMessage);
        if (self.debugCallback)
          self.debugCallback("seek called sec=" + offset);
        if (self.isRunning) {
          self.stop();
          self._kickOffSound(offset);
        } else {
          self.pausedTimeSec = offset;
        }
        self.pausedTimeSec = offset;
      };
      self.stop = function() {
        self.isRunning = false;
        self.pausedTimeSec = void 0;
        self.directSource.forEach(function(source) {
          try {
            source.stop();
          } catch (error) {
            console.log("direct source didn't stop:", error);
          }
        });
        self.directSource = [];
        var elapsed = activeAudioContext().currentTime - self.startTimeSec;
        return elapsed;
      };
      self.finished = function() {
        self.startTimeSec = void 0;
        self.pausedTimeSec = void 0;
        self.isRunning = false;
      };
      self.download = function() {
        return downloadBuffer(self);
      };
      self.getAudioBuffer = function() {
        return self.audioBuffers[0];
      };
      self.getIsRunning = function() {
        return self.isRunning;
      };
      self._deviceCapable = function() {
        if (!supportsAudio()) {
          console.warn(notSupportedMessage);
          if (self.debugCallback)
            self.debugCallback(notSupportedMessage);
          return false;
        }
        return true;
      };
      self._kickOffSound = function(seconds) {
        self.isRunning = true;
        self.directSource = [];
        self.audioBuffers.forEach(function(audioBuffer, trackNum) {
          self.directSource[trackNum] = activeAudioContext().createBufferSource();
          self.directSource[trackNum].buffer = audioBuffer;
          self.directSource[trackNum].connect(activeAudioContext().destination);
        });
        self.directSource.forEach(function(source) {
          source.start(0, seconds);
        });
        if (self.onEnded) {
          self.directSource[0].onended = function() {
            self.onEnded(self.callbackContext);
          };
        }
      };
      function addSwing(noteMapTracks, swing, meterFraction, pickupLength) {
        if (meterFraction.den != 4 && meterFraction.den != 8)
          return;
        swing = parseFloat(swing);
        if (isNaN(swing) || swing <= 50)
          return;
        if (swing > 75)
          swing = 75;
        swing = swing / 50 - 1;
        var volumeIncrease = 0;
        var beatLength = 0.25;
        if (meterFraction.den === 8)
          beatLength = beatLength / 2;
        var halfbeatLength = beatLength / 2;
        var swingDuration = halfbeatLength * swing;
        for (var t = 0; t < noteMapTracks.length; t++) {
          var track = noteMapTracks[t];
          for (var i2 = 0; i2 < track.length; i2++) {
            var event = track[i2];
            if (
              // is halfbeat
              (event.start - pickupLength) % halfbeatLength == 0 && (event.start - pickupLength) % beatLength != 0 && // the previous note is on the beat or before OR there is no previous note 
              (i2 == 0 || track[i2 - 1].start <= track[i2].start - halfbeatLength) && // the next note is on the beat or after OR there is no next note
              (i2 == track.length - 1 || track[i2 + 1].start >= track[i2].start + halfbeatLength)
            ) {
              var oldEventStart = event.start;
              event.start += swingDuration;
              event.volume *= 1 + volumeIncrease;
              if (i2 > 0 && track[i2 - 1].end == oldEventStart) {
                track[i2 - 1].end = event.start;
                track[i2 - 1].volume *= 1 - volumeIncrease;
              }
            }
          }
        }
      }
    }
    module.exports = CreateSynth;
  }
});

// node_modules/abcjs/src/synth/synth-sequence.js
var require_synth_sequence = __commonJS({
  "node_modules/abcjs/src/synth/synth-sequence.js"(exports, module) {
    var SynthSequence = function() {
      var self = this;
      self.tracks = [];
      self.totalDuration = 0;
      self.currentInstrument = [];
      self.starts = [];
      self.addTrack = function() {
        self.tracks.push([]);
        self.currentInstrument.push(0);
        self.starts.push(0);
        return self.tracks.length - 1;
      };
      self.setInstrument = function(trackNumber, instrumentNumber) {
        self.tracks[trackNumber].push({
          channel: 0,
          cmd: "program",
          instrument: instrumentNumber
        });
        self.currentInstrument[trackNumber] = instrumentNumber;
      };
      self.appendNote = function(trackNumber, pitch, durationInMeasures, volume, cents) {
        var note = {
          cmd: "note",
          duration: durationInMeasures,
          gap: 0,
          instrument: self.currentInstrument[trackNumber],
          pitch,
          start: self.starts[trackNumber],
          volume
        };
        if (cents)
          note.cents = cents;
        self.tracks[trackNumber].push(note);
        self.starts[trackNumber] += durationInMeasures;
        self.totalDuration = Math.max(self.totalDuration, self.starts[trackNumber]);
      };
    };
    module.exports = SynthSequence;
  }
});

// node_modules/abcjs/src/synth/images/loop.svg.js
var require_loop_svg = __commonJS({
  "node_modules/abcjs/src/synth/images/loop.svg.js"(exports, module) {
    var svg = `
<svg version="1.0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 700" preserveAspectRatio="xMidYMid meet">
	<g transform="translate(0,700) scale(0.1,-0.1)" >
	<path d="M3111 6981 c-20 -37 -90 -55 -364 -96 -120 -18 -190 -33 -244 -55
	-42 -17 -124 -42 -182 -56 -78 -18 -119 -34 -157 -60 -28 -19 -86 -46 -128
	-60 -43 -13 -107 -42 -144 -64 -37 -23 -84 -46 -106 -52 -21 -7 -56 -29 -79
	-50 -22 -22 -61 -50 -86 -63 -26 -13 -67 -40 -91 -60 -24 -20 -65 -47 -90 -60
	-25 -13 -53 -31 -61 -41 -8 -9 -32 -30 -54 -46 -75 -54 -486 -460 -512 -507
	-15 -25 -48 -69 -75 -98 -26 -28 -48 -57 -48 -63 0 -6 -18 -29 -39 -53 -21
	-23 -56 -71 -77 -107 -20 -36 -50 -80 -65 -97 -16 -18 -33 -52 -40 -75 -12
	-47 -47 -115 -84 -166 -13 -18 -30 -56 -38 -83 -8 -27 -34 -80 -56 -118 -33
	-53 -46 -91 -62 -167 -12 -63 -34 -127 -59 -179 -42 -84 -60 -166 -60 -270 0
	-90 26 -122 125 -154 54 -17 96 -19 430 -20 305 -1 381 2 430 14 82 22 140 51
	153 78 6 12 22 47 37 77 14 30 38 77 54 103 15 27 34 73 40 103 7 30 28 78 48
	107 19 28 44 74 55 101 10 28 34 67 53 87 18 20 49 61 68 90 19 30 44 63 57
	74 13 11 36 40 52 65 59 94 232 270 306 313 20 11 57 37 82 58 25 20 70 52
	100 72 30 19 66 47 79 61 13 14 49 35 80 46 30 12 80 37 111 56 31 19 95 45
	143 58 48 12 110 37 139 55 63 40 127 55 323 76 83 9 208 28 279 41 156 29
	165 29 330 4 453 -71 514 -84 606 -130 31 -16 83 -36 116 -45 32 -9 84 -34
	115 -56 31 -21 82 -48 113 -60 32 -11 72 -33 89 -48 18 -16 59 -45 92 -65 33
	-21 74 -51 90 -66 17 -15 49 -40 73 -54 52 -32 65 -61 50 -113 -8 -31 -61 -90
	-277 -308 -300 -303 -361 -382 -369 -481 -2 -29 0 -66 6 -81 13 -40 88 -138
	115 -151 12 -6 54 -26 92 -44 l70 -33 945 -2 c520 -1 975 2 1012 7 64 8 191
	50 231 76 11 7 33 34 50 60 22 34 42 51 65 58 l32 9 0 1101 0 1102 -32 9 c-21
	7 -44 26 -64 55 -60 84 -77 97 -140 110 -44 9 -76 10 -127 2 -59 -9 -77 -17
	-134 -62 -37 -28 -172 -155 -301 -281 -129 -127 -249 -237 -267 -245 -25 -10
	-41 -11 -71 -2 -58 15 -112 45 -124 69 -6 11 -35 35 -64 54 -28 18 -58 41 -66
	50 -8 9 -41 35 -75 58 -33 22 -77 56 -99 75 -21 18 -64 46 -95 61 -31 14 -73
	39 -93 55 -20 15 -70 40 -110 55 -40 15 -97 44 -127 64 -29 21 -78 44 -107 53
	-30 8 -77 31 -105 51 -42 28 -73 39 -173 60 -68 14 -154 39 -196 58 -95 43
	-131 51 -343 76 -209 24 -242 32 -279 70 l-30 29 -328 0 c-312 0 -330 -1 -339
	-19z"></path>
	<path d="M254 2875 c-89 -16 -107 -26 -145 -78 -32 -44 -62 -66 -91 -67 -17 0
	-18 -61 -18 -1140 l0 -1140 24 0 c16 0 41 -17 72 -50 40 -42 61 -55 117 -72
	l69 -21 82 23 c44 12 96 30 114 39 18 9 148 132 290 272 141 141 267 261 279
	268 51 26 86 14 176 -61 32 -26 62 -48 66 -48 5 0 36 -25 70 -55 34 -30 74
	-61 89 -69 15 -8 37 -28 50 -45 12 -17 50 -45 84 -62 34 -17 78 -44 98 -60 19
	-16 61 -37 93 -48 32 -11 81 -37 107 -56 27 -20 76 -45 109 -56 33 -12 75 -31
	93 -44 62 -45 93 -58 191 -82 54 -12 130 -37 168 -54 68 -29 180 -58 226 -59
	62 0 183 -64 183 -96 0 -12 88 -14 639 -14 l639 0 12 30 c18 44 76 66 233 89
	89 14 160 30 200 47 34 15 106 42 159 60 54 18 112 44 130 57 47 35 85 52 146
	67 29 7 76 28 105 48 29 20 77 48 107 63 30 15 66 39 80 54 14 15 50 40 81 56
	31 15 78 46 104 69 26 22 61 46 79 54 17 7 43 26 56 42 14 16 41 41 60 56 64
	48 380 362 408 405 15 23 40 51 55 63 15 12 36 38 46 58 11 21 37 57 58 82 22
	25 49 62 62 83 13 20 38 56 57 78 19 23 50 74 69 113 19 39 46 86 59 104 14
	18 34 62 46 98 12 36 32 77 45 92 31 38 60 97 80 167 9 33 26 76 37 95 29 50
	47 103 68 206 10 52 32 117 51 155 29 56 33 74 34 140 0 94 -10 108 -101 138
	-61 20 -83 21 -463 21 -226 0 -421 -4 -451 -10 -63 -12 -86 -30 -110 -85 -10
	-22 -33 -63 -52 -92 -21 -31 -42 -80 -53 -123 -11 -44 -32 -93 -56 -128 -20
	-32 -47 -83 -59 -115 -12 -32 -37 -77 -56 -100 -19 -23 -50 -65 -69 -94 -19
	-29 -44 -57 -54 -63 -11 -5 -29 -27 -42 -47 -52 -85 -234 -277 -300 -315 -25
	-15 -53 -38 -62 -51 -9 -14 -42 -39 -74 -57 -32 -18 -75 -48 -95 -66 -21 -18
	-59 -44 -85 -58 -26 -13 -72 -40 -100 -59 -35 -24 -78 -41 -128 -52 -47 -11
	-99 -31 -139 -56 -69 -42 -94 -49 -391 -110 -245 -51 -425 -66 -595 -50 -168
	16 -230 27 -330 61 -47 16 -123 35 -170 44 -98 17 -123 25 -172 58 -20 14 -71
	37 -114 53 -44 15 -95 40 -115 56 -20 16 -70 42 -110 59 -40 16 -88 45 -108
	63 -20 19 -55 46 -78 61 -24 14 -49 35 -55 47 -7 11 -34 33 -60 49 -50 31 -65
	61 -53 102 4 13 130 147 281 298 236 238 277 283 299 335 15 32 35 71 46 86
	12 18 19 44 19 76 0 42 -8 63 -53 138 -92 151 11 139 -1207 141 -798 2 -1030
	0 -1086 -11z"></path>
	</g>
</svg>
`;
    module.exports = svg;
  }
});

// node_modules/abcjs/src/synth/images/play.svg.js
var require_play_svg = __commonJS({
  "node_modules/abcjs/src/synth/images/play.svg.js"(exports, module) {
    var svg = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" class="abcjs-play-svg">
    <g>
    <polygon points="4 0 23 12.5 4 25"/>
    </g>
</svg>
`;
    module.exports = svg;
  }
});

// node_modules/abcjs/src/synth/images/pause.svg.js
var require_pause_svg = __commonJS({
  "node_modules/abcjs/src/synth/images/pause.svg.js"(exports, module) {
    var svg = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" class="abcjs-pause-svg">
  <g>
    <rect width="8.23" height="25"/>
    <rect width="8.23" height="25" x="17"/>
  </g>
</svg>
`;
    module.exports = svg;
  }
});

// node_modules/abcjs/src/synth/images/loading.svg.js
var require_loading_svg = __commonJS({
  "node_modules/abcjs/src/synth/images/loading.svg.js"(exports, module) {
    var svg = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="abcjs-loading-svg">
    <circle cx="50" cy="50" fill="none" stroke-width="20" r="35" stroke-dasharray="160 55"></circle>
</svg>
`;
    module.exports = svg;
  }
});

// node_modules/abcjs/src/synth/images/reset.svg.js
var require_reset_svg = __commonJS({
  "node_modules/abcjs/src/synth/images/reset.svg.js"(exports, module) {
    var svg = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25">
  <g>
    <polygon points="5 12.5 24 0 24 25"/>
    <rect width="3" height="25" x="0" y="0"/>
  </g>
</svg>
`;
    module.exports = svg;
  }
});

// node_modules/abcjs/src/synth/create-synth-control.js
var require_create_synth_control = __commonJS({
  "node_modules/abcjs/src/synth/create-synth-control.js"(exports, module) {
    var supportsAudio = require_supports_audio();
    var registerAudioContext = require_register_audio_context();
    var activeAudioContext = require_active_audio_context();
    var loopImage = require_loop_svg();
    var playImage = require_play_svg();
    var pauseImage = require_pause_svg();
    var loadingImage = require_loading_svg();
    var resetImage = require_reset_svg();
    function CreateSynthControl(parent, options) {
      var self = this;
      if (typeof parent === "string") {
        var selector = parent;
        parent = document.querySelector(selector);
        if (!parent)
          throw new Error('Cannot find element "' + selector + '" in the DOM.');
      } else if (!(parent instanceof HTMLElement))
        throw new Error("The first parameter must be a valid element or selector in the DOM.");
      self.parent = parent;
      self.options = {};
      if (options)
        self.options = Object.assign({}, options);
      if (self.options.ac)
        registerAudioContext(self.options.ac);
      buildDom(self.parent, self.options);
      attachListeners(self);
      self.disable = function(isDisabled) {
        var el = self.parent.querySelector(".abcjs-inline-audio");
        if (isDisabled)
          el.classList.add("abcjs-disabled");
        else
          el.classList.remove("abcjs-disabled");
      };
      self.setWarp = function(tempo, warp) {
        var el = self.parent.querySelector(".abcjs-midi-tempo");
        el.value = Math.round(warp);
        self.setTempo(tempo);
      };
      self.setTempo = function(tempo) {
        var el = self.parent.querySelector(".abcjs-midi-current-tempo");
        if (el)
          el.innerHTML = Math.round(tempo);
      };
      self.resetAll = function() {
        var pushedButtons = self.parent.querySelectorAll(".abcjs-pushed");
        for (var i2 = 0; i2 < pushedButtons.length; i2++) {
          var button = pushedButtons[i2];
          button.classList.remove("abcjs-pushed");
        }
      };
      self.pushPlay = function(push) {
        var startButton = self.parent.querySelector(".abcjs-midi-start");
        if (!startButton)
          return;
        if (push)
          startButton.classList.add("abcjs-pushed");
        else
          startButton.classList.remove("abcjs-pushed");
      };
      self.pushLoop = function(push) {
        var loopButton = self.parent.querySelector(".abcjs-midi-loop");
        if (!loopButton)
          return;
        if (push)
          loopButton.classList.add("abcjs-pushed");
        else
          loopButton.classList.remove("abcjs-pushed");
      };
      self.setProgress = function(percent, totalTime) {
        var progressBackground = self.parent.querySelector(".abcjs-midi-progress-background");
        var progressThumb = self.parent.querySelector(".abcjs-midi-progress-indicator");
        if (!progressBackground || !progressThumb)
          return;
        var width = progressBackground.clientWidth;
        var left = width * percent;
        progressThumb.style.left = left + "px";
        var clock = self.parent.querySelector(".abcjs-midi-clock");
        if (clock) {
          var totalSeconds = totalTime * percent / 1e3;
          var minutes = Math.floor(totalSeconds / 60);
          var seconds = Math.floor(totalSeconds % 60);
          var secondsFormatted = seconds < 10 ? "0" + seconds : seconds;
          clock.innerHTML = minutes + ":" + secondsFormatted;
        }
      };
      if (self.options.afterResume) {
        var isResumed = false;
        if (self.options.ac) {
          isResumed = self.options.ac.state !== "suspended";
        } else if (activeAudioContext()) {
          isResumed = activeAudioContext().state !== "suspended";
        }
        if (isResumed)
          self.options.afterResume();
      }
    }
    function buildDom(parent, options) {
      var hasLoop = !!options.loopHandler;
      var hasRestart = !!options.restartHandler;
      var hasPlay = !!options.playHandler || !!options.playPromiseHandler;
      var hasProgress = !!options.progressHandler;
      var hasWarp = !!options.warpHandler;
      var hasClock = options.hasClock !== false;
      var html = '<div class="abcjs-inline-audio">\n';
      if (hasLoop) {
        var repeatTitle = options.repeatTitle ? options.repeatTitle : "Click to toggle play once/repeat.";
        var repeatAria = options.repeatAria ? options.repeatAria : repeatTitle;
        html += '<button type="button" class="abcjs-midi-loop abcjs-btn" title="' + repeatTitle + '" aria-label="' + repeatAria + '">' + loopImage + "</button>\n";
      }
      if (hasRestart) {
        var restartTitle = options.restartTitle ? options.restartTitle : "Click to go to beginning.";
        var restartAria = options.restartAria ? options.restartAria : restartTitle;
        html += '<button type="button" class="abcjs-midi-reset abcjs-btn" title="' + restartTitle + '" aria-label="' + restartAria + '">' + resetImage + "</button>\n";
      }
      if (hasPlay) {
        var playTitle = options.playTitle ? options.playTitle : "Click to play/pause.";
        var playAria = options.playAria ? options.playAria : playTitle;
        html += '<button type="button" class="abcjs-midi-start abcjs-btn" title="' + playTitle + '" aria-label="' + playAria + '">' + playImage + pauseImage + loadingImage + "</button>\n";
      }
      if (hasProgress) {
        var randomTitle = options.randomTitle ? options.randomTitle : "Click to change the playback position.";
        var randomAria = options.randomAria ? options.randomAria : randomTitle;
        html += '<button type="button" class="abcjs-midi-progress-background" title="' + randomTitle + '" aria-label="' + randomAria + '"><span class="abcjs-midi-progress-indicator"></span></button>\n';
      }
      if (hasClock) {
        html += '<span class="abcjs-midi-clock"></span>\n';
      }
      if (hasWarp) {
        var warpTitle = options.warpTitle ? options.warpTitle : "Change the playback speed.";
        var warpAria = options.warpAria ? options.warpAria : warpTitle;
        var bpm = options.bpm ? options.bpm : "BPM";
        html += '<span class="abcjs-tempo-wrapper"><label><input class="abcjs-midi-tempo" type="number" min="1" max="300" value="100" title="' + warpTitle + '" aria-label="' + warpAria + '">%</label><span>&nbsp;(<span class="abcjs-midi-current-tempo"></span> ' + bpm + ")</span></span>\n";
      }
      html += '<div class="abcjs-css-warning" style="font-size: 12px;color:red;border: 1px solid red;text-align: center;width: 300px;margin-top: 4px;font-weight: bold;border-radius: 4px;">CSS required: load abcjs-audio.css</div>';
      html += "</div>\n";
      parent.innerHTML = html;
    }
    function acResumerMiddleWare(next, ev, playBtn, afterResume, isPromise) {
      var needsInit = true;
      if (!activeAudioContext()) {
        registerAudioContext();
      } else {
        needsInit = activeAudioContext().state === "suspended";
      }
      if (!supportsAudio()) {
        throw { status: "NotSupported", message: "This browser does not support audio." };
      }
      if ((needsInit || isPromise) && playBtn)
        playBtn.classList.add("abcjs-loading");
      if (needsInit) {
        activeAudioContext().resume().then(function() {
          if (afterResume) {
            afterResume().then(function(response) {
              doNext(next, ev, playBtn, isPromise);
            });
          } else {
            doNext(next, ev, playBtn, isPromise);
          }
        });
      } else {
        doNext(next, ev, playBtn, isPromise);
      }
    }
    function doNext(next, ev, playBtn, isPromise) {
      if (isPromise) {
        next(ev).then(function() {
          if (playBtn)
            playBtn.classList.remove("abcjs-loading");
        });
      } else {
        next(ev);
        if (playBtn)
          playBtn.classList.remove("abcjs-loading");
      }
    }
    function attachListeners(self) {
      var hasLoop = !!self.options.loopHandler;
      var hasRestart = !!self.options.restartHandler;
      var hasPlay = !!self.options.playHandler || !!self.options.playPromiseHandler;
      var hasProgress = !!self.options.progressHandler;
      var hasWarp = !!self.options.warpHandler;
      var playBtn = self.parent.querySelector(".abcjs-midi-start");
      if (hasLoop)
        self.parent.querySelector(".abcjs-midi-loop").addEventListener("click", function(ev) {
          acResumerMiddleWare(self.options.loopHandler, ev, playBtn, self.options.afterResume);
        });
      if (hasRestart)
        self.parent.querySelector(".abcjs-midi-reset").addEventListener("click", function(ev) {
          acResumerMiddleWare(self.options.restartHandler, ev, playBtn, self.options.afterResume);
        });
      if (hasPlay)
        playBtn.addEventListener("click", function(ev) {
          acResumerMiddleWare(
            self.options.playPromiseHandler || self.options.playHandler,
            ev,
            playBtn,
            self.options.afterResume,
            !!self.options.playPromiseHandler
          );
        });
      if (hasProgress)
        self.parent.querySelector(".abcjs-midi-progress-background").addEventListener("click", function(ev) {
          acResumerMiddleWare(self.options.progressHandler, ev, playBtn, self.options.afterResume);
        });
      if (hasWarp)
        self.parent.querySelector(".abcjs-midi-tempo").addEventListener("change", function(ev) {
          acResumerMiddleWare(self.options.warpHandler, ev, playBtn, self.options.afterResume);
        });
    }
    module.exports = CreateSynthControl;
  }
});

// node_modules/abcjs/src/synth/play-event.js
var require_play_event = __commonJS({
  "node_modules/abcjs/src/synth/play-event.js"(exports, module) {
    var SynthSequence = require_synth_sequence();
    var CreateSynth = require_create_synth();
    var activeAudioContext = require_active_audio_context();
    function playEvent(midiPitches, midiGracePitches, millisecondsPerMeasure, soundFontUrl, debugCallback) {
      var sequence = new SynthSequence();
      for (var i2 = 0; i2 < midiPitches.length; i2++) {
        var note = midiPitches[i2];
        var trackNum = sequence.addTrack();
        sequence.setInstrument(trackNum, note.instrument);
        if (i2 === 0 && midiGracePitches) {
          for (var j = 0; j < midiGracePitches.length; j++) {
            var grace = midiGracePitches[j];
            sequence.appendNote(trackNum, grace.pitch, 1 / 64, grace.volume, grace.cents);
          }
        }
        sequence.appendNote(trackNum, note.pitch, note.duration, note.volume, note.cents);
      }
      var ac = activeAudioContext();
      if (ac.state === "suspended") {
        return ac.resume().then(function() {
          return doPlay(sequence, millisecondsPerMeasure, soundFontUrl, debugCallback);
        });
      } else {
        return doPlay(sequence, millisecondsPerMeasure, soundFontUrl, debugCallback);
      }
    }
    function doPlay(sequence, millisecondsPerMeasure, soundFontUrl, debugCallback) {
      var buffer = new CreateSynth();
      return buffer.init({
        sequence,
        millisecondsPerMeasure,
        options: { soundFontUrl },
        debugCallback
      }).then(function() {
        return buffer.prime();
      }).then(function() {
        buffer.start();
        return Promise.resolve();
      });
    }
    module.exports = playEvent;
  }
});

// node_modules/abcjs/src/synth/synth-controller.js
var require_synth_controller = __commonJS({
  "node_modules/abcjs/src/synth/synth-controller.js"(exports, module) {
    var CreateSynthControl = require_create_synth_control();
    var CreateSynth = require_create_synth();
    var TimingCallbacks = require_abc_timing_callbacks();
    var activeAudioContext = require_active_audio_context();
    function SynthController() {
      var self = this;
      self.warp = 100;
      self.cursorControl = null;
      self.visualObj = null;
      self.timer = null;
      self.midiBuffer = null;
      self.options = null;
      self.currentTempo = null;
      self.control = null;
      self.isLooping = false;
      self.isStarted = false;
      self.isLoaded = false;
      self.isLoading = false;
      self.load = function(selector, cursorControl, visualOptions) {
        if (!visualOptions)
          visualOptions = {};
        if (visualOptions.displayPlay === void 0)
          visualOptions.displayPlay = true;
        if (visualOptions.displayProgress === void 0)
          visualOptions.displayProgress = true;
        self.control = new CreateSynthControl(selector, {
          loopHandler: visualOptions.displayLoop ? self.toggleLoop : void 0,
          restartHandler: visualOptions.displayRestart ? self.restart : void 0,
          playPromiseHandler: visualOptions.displayPlay ? self.play : void 0,
          progressHandler: visualOptions.displayProgress ? self.randomAccess : void 0,
          warpHandler: visualOptions.displayWarp ? self.onWarp : void 0,
          afterResume: self.init
        });
        self.cursorControl = cursorControl;
        self.disable(true);
      };
      self.disable = function(isDisabled) {
        if (self.control)
          self.control.disable(isDisabled);
      };
      self.setTune = function(visualObj, userAction, audioParams) {
        self.visualObj = visualObj;
        self.disable(false);
        self.options = audioParams ? audioParams : {};
        if (self.control) {
          self.pause();
          self.setProgress(0, 1);
          self.control.resetAll();
          self.restart();
          self.isStarted = false;
        }
        self.isLooping = false;
        if (userAction)
          return self.go();
        else {
          return Promise.resolve({ status: "no-audio-context" });
        }
      };
      self.go = function() {
        self.isLoading = true;
        var millisecondsPerMeasure = self.visualObj.millisecondsPerMeasure() * 100 / self.warp;
        self.currentTempo = Math.round(self.visualObj.getBeatsPerMeasure() / millisecondsPerMeasure * 6e4);
        if (self.control)
          self.control.setTempo(self.currentTempo);
        self.percent = 0;
        var loadingResponse;
        if (!self.midiBuffer)
          self.midiBuffer = new CreateSynth();
        return activeAudioContext().resume().then(function(response) {
          return self.midiBuffer.init({
            visualObj: self.visualObj,
            options: self.options,
            millisecondsPerMeasure
          });
        }).then(function(response) {
          loadingResponse = response;
          return self.midiBuffer.prime();
        }).then(function() {
          var subdivisions = 16;
          if (self.cursorControl && self.cursorControl.beatSubdivisions !== void 0 && parseInt(self.cursorControl.beatSubdivisions, 10) >= 1 && parseInt(self.cursorControl.beatSubdivisions, 10) <= 64)
            subdivisions = parseInt(self.cursorControl.beatSubdivisions, 10);
          self.timer = new TimingCallbacks(self.visualObj, {
            beatCallback: self.beatCallback,
            eventCallback: self.eventCallback,
            lineEndCallback: self.lineEndCallback,
            qpm: self.currentTempo,
            extraMeasuresAtBeginning: self.cursorControl ? self.cursorControl.extraMeasuresAtBeginning : void 0,
            lineEndAnticipation: self.cursorControl ? self.cursorControl.lineEndAnticipation : 0,
            beatSubdivisions: subdivisions
          });
          if (self.cursorControl && self.cursorControl.onReady && typeof self.cursorControl.onReady === "function")
            self.cursorControl.onReady(self);
          self.isLoaded = true;
          self.isLoading = false;
          return Promise.resolve({ status: "created", notesStatus: loadingResponse });
        });
      };
      self.destroy = function() {
        if (self.timer) {
          self.timer.reset();
          self.timer.stop();
          self.timer = null;
        }
        if (self.midiBuffer) {
          self.midiBuffer.stop();
          self.midiBuffer = null;
        }
        self.setProgress(0, 1);
        if (self.control)
          self.control.resetAll();
      };
      self.play = function() {
        return self.runWhenReady(self._play, void 0);
      };
      function sleep(ms) {
        return new Promise(function(resolve) {
          setTimeout(resolve, ms);
        });
      }
      self.runWhenReady = function(fn, arg1) {
        if (!self.visualObj)
          return Promise.resolve({ status: "loading" });
        if (self.isLoading) {
          return sleep(500).then(function() {
            if (self.isLoading)
              return self.runWhenReady(fn, arg1);
            return fn(arg1);
          });
        } else if (!self.isLoaded) {
          return self.go().then(function() {
            return fn(arg1);
          });
        } else {
          return fn(arg1);
        }
      };
      self._play = function() {
        return activeAudioContext().resume().then(function() {
          self.isStarted = !self.isStarted;
          if (self.isStarted) {
            if (self.cursorControl && self.cursorControl.onStart && typeof self.cursorControl.onStart === "function")
              self.cursorControl.onStart();
            self.midiBuffer.start();
            self.timer.start(self.percent);
            if (self.control)
              self.control.pushPlay(true);
          } else {
            self.pause();
          }
          return Promise.resolve({ status: "ok" });
        });
      };
      self.pause = function() {
        if (self.timer) {
          self.timer.pause();
          self.midiBuffer.pause();
          if (self.control)
            self.control.pushPlay(false);
        }
      };
      self.toggleLoop = function() {
        self.isLooping = !self.isLooping;
        if (self.control)
          self.control.pushLoop(self.isLooping);
      };
      self.restart = function() {
        if (self.timer) {
          self.timer.setProgress(0);
          self.midiBuffer.seek(0);
        }
      };
      self.randomAccess = function(ev) {
        return self.runWhenReady(self._randomAccess, ev);
      };
      self._randomAccess = function(ev) {
        var background = ev.target.classList.contains("abcjs-midi-progress-indicator") ? ev.target.parentNode : ev.target;
        var percent = (ev.x - background.getBoundingClientRect().left) / background.offsetWidth;
        if (percent < 0)
          percent = 0;
        if (percent > 1)
          percent = 1;
        self.seek(percent);
        return Promise.resolve({ status: "ok" });
      };
      self.seek = function(percent, units) {
        if (self.timer && self.midiBuffer) {
          self.timer.setProgress(percent, units);
          self.midiBuffer.seek(percent, units);
        }
      };
      self.setWarp = function(newWarp) {
        if (parseInt(newWarp, 10) > 0) {
          self.warp = parseInt(newWarp, 10);
          var wasPlaying = self.isStarted;
          var startPercent = self.percent;
          self.destroy();
          self.isStarted = false;
          return self.go().then(function() {
            self.setProgress(startPercent, self.midiBuffer.duration * 1e3);
            if (self.control)
              self.control.setWarp(self.currentTempo, self.warp);
            if (wasPlaying) {
              return self.play().then(function() {
                self.seek(startPercent);
                return Promise.resolve();
              });
            }
            self.seek(startPercent);
            return Promise.resolve();
          });
        }
        return Promise.resolve();
      };
      self.onWarp = function(ev) {
        var newWarp = ev.target.value;
        return self.setWarp(newWarp);
      };
      self.setProgress = function(percent, totalTime) {
        self.percent = percent;
        if (self.control)
          self.control.setProgress(percent, totalTime);
      };
      self.finished = function() {
        self.timer.reset();
        if (self.isLooping) {
          self.timer.start(0);
          self.midiBuffer.finished();
          self.midiBuffer.start();
          return "continue";
        } else {
          self.timer.stop();
          if (self.isStarted) {
            if (self.control)
              self.control.pushPlay(false);
            self.isStarted = false;
            self.midiBuffer.finished();
            if (self.cursorControl && self.cursorControl.onFinished && typeof self.cursorControl.onFinished === "function")
              self.cursorControl.onFinished();
            self.setProgress(0, 1);
          }
        }
      };
      self.beatCallback = function(beatNumber, totalBeats, totalTime, position) {
        var percent = beatNumber / totalBeats;
        self.setProgress(percent, totalTime);
        if (self.cursorControl && self.cursorControl.onBeat && typeof self.cursorControl.onBeat === "function")
          self.cursorControl.onBeat(beatNumber, totalBeats, totalTime, position);
      };
      self.eventCallback = function(event) {
        if (event) {
          if (self.cursorControl && self.cursorControl.onEvent && typeof self.cursorControl.onEvent === "function")
            self.cursorControl.onEvent(event);
        } else {
          return self.finished();
        }
      };
      self.lineEndCallback = function(lineEvent, leftEvent) {
        if (self.cursorControl && self.cursorControl.onLineEnd && typeof self.cursorControl.onLineEnd === "function")
          self.cursorControl.onLineEnd(lineEvent, leftEvent);
      };
      self.getUrl = function() {
        return self.midiBuffer.download();
      };
      self.download = function(fileName) {
        var url = self.getUrl();
        var link = document.createElement("a");
        document.body.appendChild(link);
        link.setAttribute("style", "display: none;");
        link.href = url;
        link.download = fileName ? fileName : "output.wav";
        link.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(link);
      };
    }
    module.exports = SynthController;
  }
});

// node_modules/abcjs/src/synth/abc_midi_renderer.js
var require_abc_midi_renderer = __commonJS({
  "node_modules/abcjs/src/synth/abc_midi_renderer.js"(exports, module) {
    var centsToFactor = require_cents_to_factor();
    var rendererFactory;
    (function() {
      "use strict";
      function setAttributes(elm, attrs) {
        for (var attr in attrs)
          if (attrs.hasOwnProperty(attr))
            elm.setAttribute(attr, attrs[attr]);
        return elm;
      }
      function Midi() {
        this.trackstrings = "";
        this.trackcount = 0;
        this.noteOnAndChannel = "%90";
        this.noteOffAndChannel = "%80";
      }
      Midi.prototype.setTempo = function(qpm) {
        if (this.trackcount === 0) {
          this.startTrack();
          this.track += "%00%FF%51%03" + toHex(Math.round(6e7 / qpm), 6);
          this.endTrack();
        }
      };
      Midi.prototype.setGlobalInfo = function(qpm, name, key, time) {
        if (this.trackcount === 0) {
          this.startTrack();
          var divisions = Math.round(6e7 / qpm);
          this.track += "%00%FF%51%03" + toHex(divisions, 6);
          if (key)
            this.track += keySignature(key);
          if (time)
            this.track += timeSignature(time);
          if (name) {
            this.track += encodeString(name, "%01");
          }
          this.endTrack();
        }
      };
      Midi.prototype.startTrack = function() {
        this.noteWarped = {};
        this.track = "";
        this.trackName = "";
        this.trackInstrument = "";
        this.silencelength = 0;
        this.trackcount++;
        if (this.instrument) {
          this.setInstrument(this.instrument);
        }
      };
      Midi.prototype.endTrack = function() {
        this.track = this.trackName + this.trackInstrument + this.track;
        var tracklength = toHex(this.track.length / 3 + 4, 8);
        this.track = "MTrk" + tracklength + // track header
        this.track + "%00%FF%2F%00";
        this.trackstrings += this.track;
      };
      Midi.prototype.setText = function(type, text) {
        switch (type) {
          case "name":
            this.trackName = encodeString(text, "%03");
            break;
        }
      };
      Midi.prototype.setInstrument = function(number) {
        this.trackInstrument = "%00%C0" + toHex(number, 2);
        this.instrument = number;
      };
      Midi.prototype.setChannel = function(number, pan) {
        this.channel = number;
        var ccPrefix = "%00%B" + this.channel.toString(16);
        this.track += ccPrefix + "%79%00";
        this.track += ccPrefix + "%40%00";
        this.track += ccPrefix + "%5B%30";
        if (!pan)
          pan = 0;
        pan = Math.round((pan + 1) * 64);
        this.track += ccPrefix + "%0A" + toHex(pan, 2);
        this.track += ccPrefix + "%07%64";
        this.noteOnAndChannel = "%9" + this.channel.toString(16);
        this.noteOffAndChannel = "%8" + this.channel.toString(16);
      };
      var HALF_STEP = 4096;
      Midi.prototype.startNote = function(pitch, loudness, cents) {
        this.track += toDurationHex(this.silencelength);
        this.silencelength = 0;
        if (cents) {
          this.track += "%e" + this.channel.toString(16);
          var bend = Math.round(centsToFactor(cents) * HALF_STEP);
          this.track += to7BitHex(8192 + bend);
          this.track += toDurationHex(0);
          this.noteWarped[pitch] = true;
        }
        this.track += this.noteOnAndChannel;
        this.track += "%" + pitch.toString(16) + toHex(loudness, 2);
      };
      Midi.prototype.endNote = function(pitch) {
        this.track += toDurationHex(this.silencelength);
        this.silencelength = 0;
        if (this.noteWarped[pitch]) {
          this.track += "%e" + this.channel.toString(16);
          this.track += to7BitHex(8192);
          this.track += toDurationHex(0);
          this.noteWarped[pitch] = false;
        }
        this.track += this.noteOffAndChannel;
        this.track += "%" + pitch.toString(16) + "%00";
      };
      Midi.prototype.addRest = function(length) {
        this.silencelength += length;
        if (this.silencelength < 0)
          this.silencelength = 0;
      };
      Midi.prototype.getData = function() {
        return "data:audio/midi,MThd%00%00%00%06%00%01" + toHex(this.trackcount, 4) + "%01%e0" + // header
        this.trackstrings;
      };
      Midi.prototype.embed = function(parent, noplayer) {
        var data = this.getData();
        var link = setAttributes(document.createElement("a"), {
          href: data
        });
        link.innerHTML = "download midi";
        parent.insertBefore(link, parent.firstChild);
        if (noplayer) return;
        var embed = setAttributes(document.createElement("embed"), {
          src: data,
          type: "video/quicktime",
          controller: "true",
          autoplay: "false",
          loop: "false",
          enablejavascript: "true",
          style: "display:block; height: 20px;"
        });
        parent.insertBefore(embed, parent.firstChild);
      };
      function encodeString(str, cmdType) {
        var nameArray = "";
        for (var i2 = 0; i2 < str.length; i2++)
          nameArray += toHex(str.charCodeAt(i2), 2);
        return "%00%FF" + cmdType + toHex(nameArray.length / 3, 2) + nameArray;
      }
      function keySignature(key) {
        if (!key || !key.accidentals)
          return "";
        var hex = "%00%FF%59%02";
        var sharpCount = 0;
        var flatCount = 256;
        for (var i2 = 0; i2 < key.accidentals.length; i2++) {
          if (key.accidentals[i2].acc === "sharp") sharpCount++;
          else if (key.accidentals[i2].acc === "flat") flatCount--;
        }
        var sig = flatCount !== 256 ? toHex(flatCount, 2) : toHex(sharpCount, 2);
        var mode = key.mode === "m" ? "%01" : "%00";
        return hex + sig + mode;
      }
      function timeSignature(time) {
        var hex = "%00%FF%58%04" + toHex(time.num, 2);
        var dens = { 1: 0, 2: 1, 4: 2, 8: 3, 16: 4, 32: 5 };
        var den = dens[time.den];
        if (!den)
          return "";
        hex += toHex(den, 2);
        var clocks;
        switch (time.num + "/" + time.den) {
          case "2/4":
          case "3/4":
          case "4/4":
          case "5/4":
            clocks = 24;
            break;
          case "6/4":
            clocks = 72;
            break;
          case "2/2":
          case "3/2":
          case "4/2":
            clocks = 48;
            break;
          case "3/8":
          case "6/8":
          case "9/8":
          case "12/8":
            clocks = 36;
            break;
        }
        if (!clocks)
          return "";
        hex += toHex(clocks, 2);
        return hex + "%08";
      }
      function encodeHex(s2) {
        var ret = "";
        for (var i2 = 0; i2 < s2.length; i2 += 2) {
          ret += "%";
          ret += s2.substr(i2, 2);
        }
        return ret;
      }
      function toHex(n, padding) {
        var s2 = n.toString(16);
        s2 = s2.split(".")[0];
        while (s2.length < padding) {
          s2 = "0" + s2;
        }
        if (s2.length > padding)
          s2 = s2.substring(0, padding);
        return encodeHex(s2);
      }
      function to7BitHex(n) {
        n = Math.round(n);
        var lower = n % 128;
        var higher = n - lower;
        return toHex(higher * 2 + lower, 4);
      }
      function toDurationHex(n) {
        var res = 0;
        var a = [];
        n = Math.round(n);
        while (n !== 0) {
          a.push(n & 127);
          n = n >> 7;
        }
        for (var i2 = a.length - 1; i2 >= 0; i2--) {
          res = res << 8;
          var bits = a[i2];
          if (i2 !== 0) {
            bits = bits | 128;
          }
          res = res | bits;
        }
        var padding = res.toString(16).length;
        padding += padding % 2;
        return toHex(res, padding);
      }
      rendererFactory = function() {
        return new Midi();
      };
    })();
    module.exports = rendererFactory;
  }
});

// node_modules/abcjs/src/midi/abc_midi_create.js
var require_abc_midi_create = __commonJS({
  "node_modules/abcjs/src/midi/abc_midi_create.js"(exports, module) {
    var rendererFactory = require_abc_midi_renderer();
    var create;
    (function() {
      "use strict";
      var baseDuration = 480 * 4;
      create = function create2(abcTune, options) {
        if (options === void 0) options = {};
        var commands = abcTune.setUpAudio(options);
        var midi = rendererFactory();
        var title = abcTune.metaText ? abcTune.metaText.title : void 0;
        if (title && title.length > 128) title = title.substring(0, 124) + "...";
        var key = abcTune.getKeySignature();
        var time = abcTune.getMeterFraction();
        var tempo = commands.tempo;
        var beatsPerSecond = tempo / 60;
        if (time.den == 8) {
          var msPerMeasure = abcTune.millisecondsPerMeasure();
          tempo = 6e4 / (msPerMeasure / time.num) / 2;
          beatsPerSecond = tempo / 60;
        }
        midi.setGlobalInfo(tempo, title, key, time);
        for (var i2 = 0; i2 < commands.tracks.length; i2++) {
          midi.startTrack();
          var notePlacement = {};
          for (var j = 0; j < commands.tracks[i2].length; j++) {
            var event = commands.tracks[i2][j];
            switch (event.cmd) {
              case "text":
                midi.setText(event.type, event.text);
                break;
              case "program":
                var pan = 0;
                if (options.pan && options.pan.length > i2)
                  pan = options.pan[i2];
                if (event.instrument === 128) {
                  midi.setChannel(9, pan);
                  midi.setInstrument(0);
                } else {
                  midi.setChannel(event.channel, pan);
                  midi.setInstrument(event.instrument);
                }
                break;
              case "note":
                var gapLengthInBeats = event.gap * beatsPerSecond;
                var start = event.start;
                var end = start + event.duration - gapLengthInBeats;
                if (!notePlacement[start])
                  notePlacement[start] = [];
                notePlacement[start].push({ pitch: event.pitch, volume: event.volume, cents: event.cents });
                if (!notePlacement[end])
                  notePlacement[end] = [];
                notePlacement[end].push({ pitch: event.pitch, volume: 0 });
                break;
              default:
                console.log("MIDI create Unknown: " + event.cmd);
            }
          }
          addNotes(midi, notePlacement, baseDuration);
          midi.endTrack();
        }
        return midi.getData();
      };
      function addNotes(midi, notePlacement, baseDuration2) {
        var times = Object.keys(notePlacement);
        for (var h = 0; h < times.length; h++)
          times[h] = parseFloat(times[h]);
        times.sort(function(a, b) {
          return a - b;
        });
        var lastTime = 0;
        for (var i2 = 0; i2 < times.length; i2++) {
          var events = notePlacement[times[i2]];
          if (times[i2] > lastTime) {
            var distance = (times[i2] - lastTime) * baseDuration2;
            midi.addRest(distance);
            lastTime = times[i2];
          }
          for (var j = 0; j < events.length; j++) {
            var event = events[j];
            if (event.volume) {
              midi.startNote(event.pitch, event.volume, event.cents);
            } else {
              midi.endNote(event.pitch);
            }
          }
        }
      }
    })();
    module.exports = create;
  }
});

// node_modules/abcjs/src/synth/get-midi-file.js
var require_get_midi_file = __commonJS({
  "node_modules/abcjs/src/synth/get-midi-file.js"(exports, module) {
    var tunebook = require_abc_tunebook();
    var midiCreate = require_abc_midi_create();
    var getMidiFile = function(source, options) {
      var params = {};
      if (options) {
        for (var key in options) {
          if (options.hasOwnProperty(key)) {
            params[key] = options[key];
          }
        }
      }
      params.generateInline = false;
      function callback(div, tune, index) {
        var downloadMidi = midiCreate(tune, params);
        switch (params.midiOutputType) {
          case "encoded":
            return downloadMidi;
          case "binary":
            var decoded = downloadMidi.replace("data:audio/midi,", "");
            decoded = decoded.replace(/MThd/g, "%4d%54%68%64");
            decoded = decoded.replace(/MTrk/g, "%4d%54%72%6b");
            var buffer = new ArrayBuffer(decoded.length / 3);
            var output = new Uint8Array(buffer);
            for (var i2 = 0; i2 < decoded.length / 3; i2++) {
              var p = i2 * 3 + 1;
              var d = parseInt(decoded.substring(p, p + 2), 16);
              output[i2] = d;
            }
            return output;
          case "link":
          default:
            return generateMidiDownloadLink(tune, params, downloadMidi, index);
        }
      }
      if (typeof source === "string")
        return tunebook.renderEngine(callback, "*", source, params);
      else
        return callback(null, source, 0);
    };
    function isFunction(functionToCheck) {
      var getType = {};
      return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
    }
    var generateMidiDownloadLink = function(tune, midiParams, midi, index) {
      var divClasses = ["abcjs-download-midi", "abcjs-midi-" + index];
      if (midiParams.downloadClass)
        divClasses.push(midiParams.downloadClass);
      var html = '<div class="' + divClasses.join(" ") + '">';
      if (midiParams.preTextDownload)
        html += midiParams.preTextDownload;
      var title = tune.metaText && tune.metaText.title ? tune.metaText.title : "Untitled";
      var label;
      if (midiParams.downloadLabel && isFunction(midiParams.downloadLabel))
        label = midiParams.downloadLabel(tune, index);
      else if (midiParams.downloadLabel)
        label = midiParams.downloadLabel.replace(/%T/, title);
      else
        label = 'Download MIDI for "' + title + '"';
      title = title.toLowerCase().replace(/'/g, "").replace(/\W/g, "_").replace(/__/g, "_");
      var filename = midiParams.fileName ? midiParams.fileName : title + ".midi";
      html += '<a download="' + filename + '" href="' + midi + '">' + label + "</a>";
      if (midiParams.postTextDownload)
        html += midiParams.postTextDownload;
      return html + "</div>";
    };
    module.exports = getMidiFile;
  }
});

// node_modules/abcjs/src/edit/abc_editarea.js
var require_abc_editarea = __commonJS({
  "node_modules/abcjs/src/edit/abc_editarea.js"(exports, module) {
    try {
      if (typeof window.CustomEvent !== "function") {
        CustomEvent = function(event, params) {
          params = params || { bubbles: false, cancelable: false, detail: void 0 };
          var evt = document.createEvent("CustomEvent");
          evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
          return evt;
        };
        CustomEvent.prototype = window.Event.prototype;
        window.CustomEvent = CustomEvent;
      }
    } catch (e) {
    }
    var CustomEvent;
    var EditArea = function(textareaid) {
      if (typeof textareaid === "string")
        this.textarea = document.getElementById(textareaid);
      else
        this.textarea = textareaid;
      this.initialText = this.textarea.value;
      this.isDragging = false;
    };
    EditArea.prototype.addSelectionListener = function(listener) {
      this.textarea.onmousemove = function(ev) {
        if (this.isDragging)
          listener.fireSelectionChanged();
      };
    };
    EditArea.prototype.addChangeListener = function(listener) {
      this.changelistener = listener;
      this.textarea.onkeyup = function() {
        listener.fireChanged();
      };
      this.textarea.onmousedown = function() {
        this.isDragging = true;
        listener.fireSelectionChanged();
      };
      this.textarea.onmouseup = function() {
        this.isDragging = false;
        listener.fireChanged();
      };
      this.textarea.onchange = function() {
        listener.fireChanged();
      };
    };
    EditArea.prototype.getSelection = function() {
      return { start: this.textarea.selectionStart, end: this.textarea.selectionEnd };
    };
    EditArea.prototype.setSelection = function(start, end) {
      if (this.textarea.setSelectionRange)
        this.textarea.setSelectionRange(start, end);
      else if (this.textarea.createTextRange) {
        var e = this.textarea.createTextRange();
        e.collapse(true);
        e.moveEnd("character", end);
        e.moveStart("character", start);
        e.select();
      }
      this.textarea.focus();
    };
    EditArea.prototype.getString = function() {
      return this.textarea.value;
    };
    EditArea.prototype.setString = function(str) {
      this.textarea.value = str;
      this.initialText = this.getString();
      if (this.changelistener) {
        this.changelistener.fireChanged();
      }
    };
    EditArea.prototype.getElem = function() {
      return this.textarea;
    };
    module.exports = EditArea;
  }
});

// node_modules/abcjs/src/edit/abc_editor.js
var require_abc_editor = __commonJS({
  "node_modules/abcjs/src/edit/abc_editor.js"(exports, module) {
    var parseCommon = require_abc_common();
    var SynthController = require_synth_controller();
    var supportsAudio = require_supports_audio();
    var renderAbc = require_abc_tunebook_svg();
    var EditArea = require_abc_editarea();
    function gatherAbcParams(params) {
      var abcjsParams = {};
      var key;
      if (params.abcjsParams) {
        for (key in params.abcjsParams) {
          if (params.abcjsParams.hasOwnProperty(key)) {
            abcjsParams[key] = params.abcjsParams[key];
          }
        }
      }
      if (params.midi_options) {
        for (key in params.midi_options) {
          if (params.midi_options.hasOwnProperty(key)) {
            abcjsParams[key] = params.midi_options[key];
          }
        }
      }
      if (params.parser_options) {
        for (key in params.parser_options) {
          if (params.parser_options.hasOwnProperty(key)) {
            abcjsParams[key] = params.parser_options[key];
          }
        }
      }
      if (params.render_options) {
        for (key in params.render_options) {
          if (params.render_options.hasOwnProperty(key)) {
            abcjsParams[key] = params.render_options[key];
          }
        }
      }
      if (abcjsParams.tablature) {
        if (params.warnings_id) {
          abcjsParams.tablature.warnings_id = params.warnings_id;
        }
      }
      return abcjsParams;
    }
    var Editor = function(editarea, params) {
      this.abcjsParams = gatherAbcParams(params);
      if (params.indicate_changed)
        this.indicate_changed = true;
      if (typeof editarea === "string") {
        this.editarea = new EditArea(editarea);
      } else {
        this.editarea = editarea;
      }
      this.editarea.addSelectionListener(this);
      this.editarea.addChangeListener(this);
      if (params.canvas_id) {
        this.div = params.canvas_id;
      } else if (params.paper_id) {
        this.div = params.paper_id;
      } else {
        this.div = document.createElement("DIV");
        this.editarea.getElem().parentNode.insertBefore(this.div, this.editarea.getElem());
      }
      if (typeof this.div === "string")
        this.div = document.getElementById(this.div);
      if (params.selectionChangeCallback) {
        this.selectionChangeCallback = params.selectionChangeCallback;
      }
      this.clientClickListener = this.abcjsParams.clickListener;
      this.abcjsParams.clickListener = this.highlight.bind(this);
      if (params.synth) {
        if (supportsAudio()) {
          this.synth = {
            el: params.synth.el,
            cursorControl: params.synth.cursorControl,
            options: params.synth.options
          };
        }
      }
      if (params.generate_midi) {
        this.generate_midi = params.generate_midi;
        if (this.abcjsParams.generateDownload) {
          if (typeof params.midi_download_id === "string")
            this.downloadMidi = document.getElementById(params.midi_download_id);
          else if (params.midi_download_id)
            this.downloadMidi = params.midi_download_id;
        }
        if (this.abcjsParams.generateInline !== false) {
          if (typeof params.midi_id === "string")
            this.inlineMidi = document.getElementById(params.midi_id);
          else if (params.midi_id)
            this.inlineMidi = params.midi_id;
        }
      }
      if (params.warnings_id) {
        if (typeof params.warnings_id === "string")
          this.warningsdiv = document.getElementById(params.warnings_id);
        else
          this.warningsdiv = params.warnings_id;
      } else if (params.generate_warnings) {
        this.warningsdiv = document.createElement("div");
        this.div.parentNode.insertBefore(this.warningsdiv, this.div);
      }
      this.onchangeCallback = params.onchange;
      this.currentAbc = "";
      this.tunes = [];
      this.bReentry = false;
      this.parseABC();
      this.modelChanged();
      this.addClassName = function(element, className) {
        var hasClassName = function(element2, className2) {
          var elementClassName = element2.className;
          return elementClassName.length > 0 && (elementClassName === className2 || new RegExp("(^|\\s)" + className2 + "(\\s|$)").test(elementClassName));
        };
        if (!hasClassName(element, className))
          element.className += (element.className ? " " : "") + className;
        return element;
      };
      this.removeClassName = function(element, className) {
        element.className = parseCommon.strip(element.className.replace(
          new RegExp("(^|\\s+)" + className + "(\\s+|$)"),
          " "
        ));
        return element;
      };
      this.setReadOnly = function(readOnly) {
        var readonlyClass = "abc_textarea_readonly";
        var el = this.editarea.getElem();
        if (readOnly) {
          el.setAttribute("readonly", "yes");
          this.addClassName(el, readonlyClass);
        } else {
          el.removeAttribute("readonly");
          this.removeClassName(el, readonlyClass);
        }
      };
    };
    Editor.prototype.redrawMidi = function() {
      if (this.generate_midi && !this.midiPause) {
        var event = new window.CustomEvent("generateMidi", {
          detail: {
            tunes: this.tunes,
            abcjsParams: this.abcjsParams,
            downloadMidiEl: this.downloadMidi,
            inlineMidiEl: this.inlineMidi,
            engravingEl: this.div
          }
        });
        window.dispatchEvent(event);
      }
      if (this.synth) {
        var userAction = this.synth.synthControl;
        if (!this.synth.synthControl) {
          this.synth.synthControl = new SynthController();
          this.synth.synthControl.load(this.synth.el, this.synth.cursorControl, this.synth.options);
        }
        this.synth.synthControl.setTune(this.tunes[0], userAction, this.synth.options);
      }
    };
    Editor.prototype.modelChanged = function() {
      if (this.bReentry)
        return;
      this.bReentry = true;
      try {
        this.timerId = null;
        if (this.synth && this.synth.synthControl)
          this.synth.synthControl.disable(true);
        this.tunes = renderAbc(this.div, this.currentAbc, this.abcjsParams);
        if (this.tunes.length > 0) {
          this.warnings = this.tunes[0].warnings;
        }
        this.redrawMidi();
      } catch (error) {
        console.error("ABCJS error: ", error);
        if (!this.warnings)
          this.warnings = [];
        this.warnings.push(error.message);
      }
      if (this.warningsdiv) {
        this.warningsdiv.innerHTML = this.warnings ? this.warnings.join("<br />") : "No errors";
      }
      this.updateSelection();
      this.bReentry = false;
    };
    Editor.prototype.paramChanged = function(engraverParams) {
      if (engraverParams) {
        for (var key in engraverParams) {
          if (engraverParams.hasOwnProperty(key)) {
            this.abcjsParams[key] = engraverParams[key];
          }
        }
      }
      this.currentAbc = "";
      this.fireChanged();
    };
    Editor.prototype.synthParamChanged = function(options) {
      if (!this.synth)
        return;
      this.synth.options = {};
      if (options) {
        for (var key in options) {
          if (options.hasOwnProperty(key)) {
            this.synth.options[key] = options[key];
          }
        }
      }
      this.currentAbc = "";
      this.fireChanged();
    };
    Editor.prototype.parseABC = function() {
      var t = this.editarea.getString();
      if (t === this.currentAbc) {
        this.updateSelection();
        return false;
      }
      this.currentAbc = t;
      return true;
    };
    Editor.prototype.updateSelection = function() {
      var selection = this.editarea.getSelection();
      try {
        if (this.tunes.length > 0 && this.tunes[0].engraver)
          this.tunes[0].engraver.rangeHighlight(selection.start, selection.end);
      } catch (e) {
      }
      if (this.selectionChangeCallback)
        this.selectionChangeCallback(selection.start, selection.end);
    };
    Editor.prototype.fireSelectionChanged = function() {
      this.updateSelection();
    };
    Editor.prototype.setDirtyStyle = function(isDirty) {
      if (this.indicate_changed === void 0)
        return;
      var addClassName = function(element, className) {
        var hasClassName = function(element2, className2) {
          var elementClassName = element2.className;
          return elementClassName.length > 0 && (elementClassName === className2 || new RegExp("(^|\\s)" + className2 + "(\\s|$)").test(elementClassName));
        };
        if (!hasClassName(element, className))
          element.className += (element.className ? " " : "") + className;
        return element;
      };
      var removeClassName = function(element, className) {
        element.className = parseCommon.strip(element.className.replace(
          new RegExp("(^|\\s+)" + className + "(\\s+|$)"),
          " "
        ));
        return element;
      };
      var readonlyClass = "abc_textarea_dirty";
      var el = this.editarea.getElem();
      if (isDirty) {
        addClassName(el, readonlyClass);
      } else {
        removeClassName(el, readonlyClass);
      }
    };
    Editor.prototype.fireChanged = function() {
      if (this.bIsPaused)
        return;
      if (this.parseABC()) {
        var self = this;
        if (this.timerId)
          clearTimeout(this.timerId);
        this.timerId = setTimeout(function() {
          self.modelChanged();
        }, 300);
        var isDirty = this.isDirty();
        if (this.wasDirty !== isDirty) {
          this.wasDirty = isDirty;
          this.setDirtyStyle(isDirty);
        }
        if (this.onchangeCallback)
          this.onchangeCallback(this);
      }
    };
    Editor.prototype.setNotDirty = function() {
      this.editarea.initialText = this.editarea.getString();
      this.wasDirty = false;
      this.setDirtyStyle(false);
    };
    Editor.prototype.isDirty = function() {
      if (this.indicate_changed === void 0)
        return false;
      return this.editarea.initialText !== this.editarea.getString();
    };
    Editor.prototype.highlight = function(abcelem, tuneNumber, classes, analysis, drag, mouseEvent) {
      this.editarea.setSelection(abcelem.startChar, abcelem.endChar);
      if (this.selectionChangeCallback)
        this.selectionChangeCallback(abcelem.startChar, abcelem.endChar);
      if (this.clientClickListener)
        this.clientClickListener(abcelem, tuneNumber, classes, analysis, drag, mouseEvent);
    };
    Editor.prototype.pause = function(shouldPause) {
      this.bIsPaused = shouldPause;
      if (!shouldPause)
        this.fireChanged();
    };
    Editor.prototype.millisecondsPerMeasure = function() {
      if (!this.synth || !this.synth.synthControl || !this.synth.synthControl.visualObj)
        return 0;
      return this.synth.synthControl.visualObj.millisecondsPerMeasure();
    };
    Editor.prototype.pauseMidi = function(shouldPause) {
      this.midiPause = shouldPause;
      if (!shouldPause)
        this.redrawMidi();
    };
    module.exports = Editor;
  }
});

// node_modules/abcjs/index.js
var require_abcjs = __commonJS({
  "node_modules/abcjs/index.js"(exports, module) {
    var version = require_version();
    var animation = require_abc_animation();
    var tuneBook = require_abc_tunebook();
    var sequence = require_abc_midi_sequencer();
    var strTranspose = require_output();
    var abcjs = {};
    abcjs.signature = "abcjs-basic v" + version;
    Object.keys(animation).forEach(function(key) {
      abcjs[key] = animation[key];
    });
    Object.keys(tuneBook).forEach(function(key) {
      abcjs[key] = tuneBook[key];
    });
    abcjs.renderAbc = require_abc_tunebook_svg();
    abcjs.tuneMetrics = require_tune_metrics();
    abcjs.TimingCallbacks = require_abc_timing_callbacks();
    var glyphs = require_glyphs();
    abcjs.setGlyph = glyphs.setSymbol;
    abcjs.strTranspose = strTranspose;
    var CreateSynth = require_create_synth();
    var instrumentIndexToName = require_instrument_index_to_name();
    var pitchToNoteName = require_pitch_to_note_name();
    var SynthSequence = require_synth_sequence();
    var CreateSynthControl = require_create_synth_control();
    var registerAudioContext = require_register_audio_context();
    var activeAudioContext = require_active_audio_context();
    var supportsAudio = require_supports_audio();
    var playEvent = require_play_event();
    var SynthController = require_synth_controller();
    var getMidiFile = require_get_midi_file();
    var midiRenderer = require_abc_midi_renderer();
    abcjs.synth = {
      CreateSynth,
      instrumentIndexToName,
      pitchToNoteName,
      SynthController,
      SynthSequence,
      CreateSynthControl,
      registerAudioContext,
      activeAudioContext,
      supportsAudio,
      playEvent,
      getMidiFile,
      sequence,
      midiRenderer
    };
    abcjs["Editor"] = require_abc_editor();
    abcjs["EditArea"] = require_abc_editarea();
    module.exports = abcjs;
  }
});
export default require_abcjs();
//# sourceMappingURL=abcjs.js.map
